{"version":3,"file":"leafletMap.js","sources":["../Scripts/events.ts","../Scripts/map.ts","../Scripts/layer.ts","../Scripts/gridLayer.ts","../Scripts/tileLayer.ts","../Scripts/wmsTileLayer.ts","../Scripts/protobufVectorTileLayer.ts","../Scripts/slicerVectorTileLayer.ts","../Scripts/layerGroup.ts","../Scripts/featureGroup.ts","../Scripts/geoJsonLayer.ts","../Scripts/editableGeoJsonLayer.ts","../Scripts/polyline.ts","../Scripts/polygon.ts","../Scripts/rectangle.ts","../Scripts/marker.ts","../Scripts/circleMarker.ts","../Scripts/popup.ts","../Scripts/tooltip.ts","../Scripts/crs.ts","../Scripts/editingControl.ts","../Scripts/index.ts"],"sourcesContent":["declare const L: typeof import('leaflet');\ndeclare const Mvt: typeof import('leaflet-vectortile-mapbox');\n\nexport namespace LeafletEvents {\n    // DTO shapes sent to .NET using Leaflet classes directly, matching C# EventArgs properties\n    export interface LeafletEventArgsDto {\n        Type?: string | null;\n        Target?: any | null;\n        SourceTarget?: any | null;\n        PropagatedFrom?: any | null;\n    }\n\n    // Matches C# LeafletMouseEventArgs: LatLng, LayerPoint, ContainerPoint, OriginalEvent\n    export interface LeafletMouseEventArgsDto extends LeafletEventArgsDto {\n        LatLng?: L.LatLng | null;\n        LayerPoint?: L.Point | null;\n        ContainerPoint?: L.Point | null;\n        OriginalEvent?: any | null;\n    }\n\n    // Matches C# LeafletResizeEventArgs: OldSize, NewSize\n    export interface LeafletResizeEventArgsDto extends LeafletEventArgsDto {\n        OldSize?: L.Point | null;\n        NewSize?: L.Point | null;\n    }\n\n    // Matches C# LeafletPopupEventArgs: Popup\n    export interface LeafletPopupEventArgsDto extends LeafletEventArgsDto {\n        Popup?: L.Popup | null;\n    }\n\n    // Matches C# LeafletDragEndEventArgs: Distance\n    export interface LeafletDragEndEventArgsDto extends LeafletEventArgsDto {\n        Distance?: number | null;\n    }\n\n    // Matches C# LeafletErrorEventArgs: Message, Code\n    export interface LeafletErrorEventArgsDto extends LeafletEventArgsDto {\n        Message?: string | null;\n        Code?: number | null;\n    }\n\n    // Matches C# LeafletGeoJsonEventArgs: Layer, Properties, GeometryType, Id\n    export interface LeafletGeoJsonEventArgsDto extends LeafletEventArgsDto {\n        Layer?: L.Layer | null;\n        Properties?: any | null;\n        GeometryType?: string | null;\n        Id?: string | null;\n    }\n\n    // Matches C# LeafletKeyboardEventArgs: OriginalEvent\n    export interface LeafletKeyboardEventArgsDto extends LeafletEventArgsDto {\n        OriginalEvent?: any | null;\n    }\n\n    // Matches C# LeafletLayerEventArgs: Layer\n    export interface LeafletLayerEventArgsDto extends LeafletEventArgsDto {\n        Layer?: L.Layer | null;\n    }\n\n    // Matches C# LeafletLayersControlEventArgs: Layer, Name\n    export interface LeafletLayersControlEventArgsDto extends LeafletEventArgsDto {\n        Layer?: L.Layer | null;\n        Name?: string | null;\n    }\n\n    export interface LatLngBoundsDto {\n        NorthEast: L.LatLng;\n        SouthWest: L.LatLng;\n    }\n\n    // Matches C# LeafletLocationEventArgs: use plain serializable shapes to avoid circular refs\n    export interface LeafletLocationEventArgsDto extends LeafletEventArgsDto {\n        LatLng?: L.LatLng | null;\n        Bounds?: LatLngBoundsDto | null;\n        Accuracy?: number | null;\n        Altitude?: number | null;\n        AltitudeAccuracy?: number | null;\n        Heading?: number | null;\n        Speed?: number | null;\n        Timestamp?: number | null;\n    }\n\n    // Matches C# LeafletTileErrorEventArgs: Tile, Coords, Error\n    export interface LeafletTileErrorEventArgsDto extends LeafletEventArgsDto {\n        Tile?: any | null;\n        Coords?: L.Point | null;\n        Error?: any | null;\n    }\n\n    // Matches C# LeafletTileEventArgs: Tile, Coords\n    export interface LeafletTileEventArgsDto extends LeafletEventArgsDto {\n        Tile?: any | null;\n        Coords?: L.Point | null;\n    }\n\n    // Matches C# LeafletTooltipEventArgs: Tooltip\n    export interface LeafletTooltipEventArgsDto extends LeafletEventArgsDto {\n        Tooltip?: L.Tooltip | null;\n    }\n\n    // Matches C# LeafletZoomAnimEventArgs: Center, Zoom, NoUpdate\n    export interface LeafletZoomAnimEventArgsDto extends LeafletEventArgsDto {\n        Center?: L.LatLng | null;\n        Zoom?: number | null;\n        NoUpdate?: boolean | null;\n    }\n\n    // Matches C# LeafletFeatureMouseEventArgs\n    export interface LeafletFeatureMouseEventArgsDto extends LeafletMouseEventArgsDto {\n        LayerName?: string | null;\n        Feature?: any | null;\n    }\n\n    // Matches C# LeafletTileFetchErrorEventArgs\n    export interface LeafletTileFetchErrorEventArgsDto extends LeafletTileErrorEventArgsDto {\n        Url?: string | null;\n        z?: number | null;\n        x?: number | null;\n        y?: number | null;\n    }\n\n    export function minimalLayerInfo(obj: any): any {\n        if (!obj) return null;\n        const info: any = {};\n        if ('_leaflet_id' in obj) info.LeafletId = obj._leaflet_id;\n        if (obj && obj.constructor && obj.constructor.name) info.Type = obj.constructor.name;\n        return info;\n    }\n\n    export class LeafletEventArgs {\n        Type?: string | null;\n        Target?: any | null;\n        SourceTarget?: any | null;\n        PropagatedFrom?: any | null;\n\n        constructor(init?: Partial<LeafletEventArgsDto>) {\n            if (init) {\n                this.Type = init.Type ?? null;\n                this.Target = init.Target ?? null;\n                this.SourceTarget = init.SourceTarget ?? null;\n                this.PropagatedFrom = init.PropagatedFrom ?? null;\n            }\n        }\n\n        toDto(): LeafletEventArgsDto {\n            return {\n                Type: this.Type ?? null,\n                Target: this.Target ?? null,\n                SourceTarget: this.SourceTarget ?? null,\n                PropagatedFrom: this.PropagatedFrom ?? null\n            };\n        }\n\n        static fromLeaflet(ev: any): LeafletEventArgs {\n            const dto: LeafletEventArgsDto = {\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            };\n            return new LeafletEventArgs(dto);\n        }\n    }\n\n    export class LeafletMouseEventArgs extends LeafletEventArgs {\n        LatLng?: L.LatLng | null;\n        LayerPoint?: L.Point | null;\n        ContainerPoint?: L.Point | null;\n        OriginalEvent?: any | null;\n\n        constructor(init?: Partial<LeafletMouseEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.LatLng = init.LatLng ?? null;\n                this.LayerPoint = init.LayerPoint ?? null;\n                this.ContainerPoint = init.ContainerPoint ?? null;\n                this.OriginalEvent = init.OriginalEvent ?? null;\n            }\n        }\n\n        toDto(): LeafletMouseEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                LatLng: this.LatLng ?? null,\n                LayerPoint: this.LayerPoint ?? null,\n                ContainerPoint: this.ContainerPoint ?? null,\n                OriginalEvent: this.OriginalEvent ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletMouseEventArgs {\n            const dto: Partial<LeafletMouseEventArgsDto> = {\n                LatLng: ev?.latlng ?? null,\n                LayerPoint: ev?.layerPoint ?? null,\n                ContainerPoint: ev?.containerPoint ?? null,\n                OriginalEvent: ev?.originalEvent ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as Partial<LeafletMouseEventArgsDto & LeafletEventArgsDto>;\n\n            return new LeafletMouseEventArgs(dto);\n        }\n    }\n\n    export class LeafletResizeEventArgs extends LeafletEventArgs {\n        OldSize?: L.Point | null;\n        NewSize?: L.Point | null;\n\n        constructor(init?: Partial<LeafletResizeEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.OldSize = init.OldSize ?? null;\n                this.NewSize = init.NewSize ?? null;\n            }\n        }\n\n        toDto(): LeafletResizeEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                OldSize: this.OldSize ?? null,\n                NewSize: this.NewSize ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletResizeEventArgs {\n            const dto: Partial<LeafletResizeEventArgsDto> = {\n                OldSize: ev?.oldSize ?? null,\n                NewSize: ev?.newSize ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletResizeEventArgs(dto);\n        }\n    }\n\n    export class LeafletPopupEventArgs extends LeafletEventArgs {\n        Popup?: L.Popup | null;\n\n        constructor(init?: Partial<LeafletPopupEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Popup = init.Popup ?? null;\n            }\n        }\n\n        toDto(): LeafletPopupEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Popup: this.Popup ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletPopupEventArgs {\n            const dto: Partial<LeafletPopupEventArgsDto> = {\n                Popup: ev?.popup ?? ev?.layer ?? ev?.target ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletPopupEventArgs(dto);\n        }\n    }\n\n    export class LeafletDragEndEventArgs extends LeafletEventArgs {\n        Distance?: number | null;\n\n        constructor(init?: Partial<LeafletDragEndEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Distance = init.Distance ?? null;\n            }\n        }\n\n        toDto(): LeafletDragEndEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Distance: this.Distance ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletDragEndEventArgs {\n            const dto: Partial<LeafletDragEndEventArgsDto> = {\n                Distance: (typeof ev?.distance === 'number') ? ev.distance : null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletDragEndEventArgs(dto);\n        }\n    }\n\n    export class LeafletErrorEventArgs extends LeafletEventArgs {\n        Message?: string | null;\n        Code?: number | null;\n\n        constructor(init?: Partial<LeafletErrorEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Message = init.Message ?? null;\n                this.Code = init.Code ?? null;\n            }\n        }\n\n        toDto(): LeafletErrorEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Message: this.Message ?? null,\n                Code: this.Code ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletErrorEventArgs {\n            // try common locations for message/code\n            const msg = ev?.message ?? ev?.error?.message ?? null;\n            const code = (typeof ev?.code === 'number') ? ev.code : (typeof ev?.status === 'number' ? ev.status : null);\n\n            const dto: Partial<LeafletErrorEventArgsDto> = {\n                Message: msg,\n                Code: code,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletErrorEventArgs(dto);\n        }\n    }\n\n    export class LeafletGeoJsonEventArgs extends LeafletEventArgs {\n        Layer?: L.Layer | null;\n        Properties?: any | null;\n        GeometryType?: string | null;\n        Id?: string | null;\n\n        constructor(init?: Partial<LeafletGeoJsonEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Layer = init.Layer ?? null;\n                this.Properties = init.Properties ?? null;\n                this.GeometryType = init.GeometryType ?? null;\n                this.Id = init.Id ?? null;\n            }\n        }\n\n        toDto(): LeafletGeoJsonEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Layer: this.Layer ?? null,\n                Properties: this.Properties ?? null,\n                GeometryType: this.GeometryType ?? null,\n                Id: this.Id ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletGeoJsonEventArgs {\n            const dto: Partial<LeafletGeoJsonEventArgsDto> = {\n                Layer: minimalLayerInfo(ev?.layer) ?? minimalLayerInfo(ev?.target) ?? null,\n                Properties: ev?.properties ?? ev?.layer?.feature?.properties ?? null,\n                GeometryType: ev?.geometryType ?? ev?.layer?.feature?.geometry?.type ?? null,\n                Id: ev?.id ?? ev?.layer?.feature?.id ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n\n            return new LeafletGeoJsonEventArgs(dto);\n        }\n    }\n\n    export class LeafletKeyboardEventArgs extends LeafletEventArgs {\n        OriginalEvent?: any | null;\n\n        constructor(init?: Partial<LeafletKeyboardEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.OriginalEvent = init.OriginalEvent ?? null;\n            }\n        }\n\n        toDto(): LeafletKeyboardEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                OriginalEvent: this.OriginalEvent ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletKeyboardEventArgs {\n            const dto: Partial<LeafletKeyboardEventArgsDto> = {\n                OriginalEvent: ev?.originalEvent ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletKeyboardEventArgs(dto);\n        }\n    }\n\n    export class LeafletLayerEventArgs extends LeafletEventArgs {\n        Layer?: L.Layer | null;\n\n        constructor(init?: Partial<LeafletLayerEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Layer = init.Layer ?? null;\n            }\n        }\n\n        toDto(): LeafletLayerEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Layer: this.Layer ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletLayerEventArgs {\n            const dto: Partial<LeafletLayerEventArgsDto> = {\n                Layer: minimalLayerInfo(ev?.layer) ?? minimalLayerInfo(ev?.target) ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletLayerEventArgs(dto);\n        }\n    }\n\n    export class LeafletLayersControlEventArgs extends LeafletEventArgs {\n        Layer?: L.Layer | null;\n        Name?: string | null;\n\n        constructor(init?: Partial<LeafletLayersControlEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Layer = init.Layer ?? null;\n                this.Name = init.Name ?? null;\n            }\n        }\n\n        toDto(): LeafletLayersControlEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Layer: this.Layer ?? null,\n                Name: this.Name ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletLayersControlEventArgs {\n            const dto: Partial<LeafletLayersControlEventArgsDto> = {\n                Layer: minimalLayerInfo(ev?.layer) ?? minimalLayerInfo(ev?.target) ?? null,\n                Name: ev?.name ?? ev?.layer?.options?.name ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletLayersControlEventArgs(dto);\n        }\n    }\n\n    export class LeafletLocationEventArgs extends LeafletEventArgs {\n        LatLng?: L.LatLng;\n        Bounds?: LatLngBoundsDto | null;\n        Accuracy?: number | null;\n        Altitude?: number | null;\n        AltitudeAccuracy?: number | null;\n        Heading?: number | null;\n        Speed?: number | null;\n        Timestamp?: number | null;\n\n        constructor(init?: Partial<LeafletLocationEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.LatLng = init.LatLng ?? null;\n                this.Bounds = init.Bounds ?? null;\n                this.Accuracy = init.Accuracy ?? null;\n                this.Altitude = init.Altitude ?? null;\n                this.AltitudeAccuracy = init.AltitudeAccuracy ?? null;\n                this.Heading = init.Heading ?? null;\n                this.Speed = init.Speed ?? null;\n                this.Timestamp = init.Timestamp ?? null;\n            }\n        }\n\n        toDto(): LeafletLocationEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                LatLng: this.LatLng ?? null,\n                Bounds: this.Bounds ?? null,\n                Accuracy: this.Accuracy ?? null,\n                Altitude: this.Altitude ?? null,\n                AltitudeAccuracy: this.AltitudeAccuracy ?? null,\n                Heading: this.Heading ?? null,\n                Speed: this.Speed ?? null,\n                Timestamp: this.Timestamp ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletLocationEventArgs {\n            // LatLngBounds doesn't map directly, so create a simple DTO\n            let boundsDto = null;\n            if (ev?.bounds && typeof ev.bounds.getNorthEast === 'function') {\n                const ne = ev.bounds.getNorthEast();\n                const sw = ev.bounds.getSouthWest();\n                boundsDto = { NorthEast: ne, SouthWest: sw };\n            }\n\n            const dto: Partial<LeafletLocationEventArgsDto> = {\n                LatLng: ev.latlng ?? null,\n                Bounds: boundsDto ?? null,\n                Accuracy: ('accuracy' in (ev ?? {})) ? ev.accuracy : null,\n                Altitude: ('altitude' in (ev ?? {})) ? ev.altitude : null,\n                AltitudeAccuracy: ('altitudeAccuracy' in (ev ?? {})) ? ev.altitudeAccuracy : null,\n                Heading: ('heading' in (ev ?? {})) ? ev.heading : null,\n                Speed: ('speed' in (ev ?? {})) ? ev.speed : null,\n                Timestamp: ('timestamp' in (ev ?? {})) ? ev.timestamp : null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletLocationEventArgs(dto);\n        }\n    }\n\n    export class LeafletTileErrorEventArgs extends LeafletEventArgs {\n        Tile?: any | null;\n        Coords?: L.Point | null;\n        Error?: any | null;\n\n        constructor(init?: Partial<LeafletTileErrorEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Tile = init.Tile ?? null;\n                this.Coords = init.Coords ?? null;\n                this.Error = init.Error ?? null;\n            }\n        }\n\n        toDto(): LeafletTileErrorEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Tile: this.Tile ?? null,\n                Coords: this.Coords ?? null,\n                Error: this.Error ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletTileErrorEventArgs {\n            const dto: Partial<LeafletTileErrorEventArgsDto> = {\n                Tile: ev?.tile ?? ev?.tile ?? null,\n                Coords: ev?.coords ?? ev?.coord ?? null,\n                Error: ev?.error ?? ev?.message ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletTileErrorEventArgs(dto);\n        }\n    }\n\n    export class LeafletTileEventArgs extends LeafletEventArgs {\n        Tile?: any | null;\n        Coords?: L.Point | null;\n\n        constructor(init?: Partial<LeafletTileEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Tile = init.Tile ?? null;\n                this.Coords = init.Coords ?? null;\n            }\n        }\n\n        toDto(): LeafletTileEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Tile: this.Tile ?? null,\n                Coords: this.Coords ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletTileEventArgs {\n            const dto: Partial<LeafletTileEventArgsDto> = {\n                Tile: ev?.tile ?? ev?.tile ?? null,\n                Coords: ev?.coords ?? ev?.coord ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletTileEventArgs(dto);\n        }\n    }\n\n    export class LeafletTooltipEventArgs extends LeafletEventArgs {\n        Tooltip?: L.Tooltip | null;\n\n        constructor(init?: Partial<LeafletTooltipEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Tooltip = init.Tooltip ?? null;\n            }\n        }\n\n        toDto(): LeafletTooltipEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Tooltip: this.Tooltip ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletTooltipEventArgs {\n            const dto: Partial<LeafletTooltipEventArgsDto> = {\n                Tooltip: ev?.tooltip ?? ev?.layer ?? ev?.target ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n            return new LeafletTooltipEventArgs(dto);\n        }\n    }\n\n    export class LeafletZoomAnimEventArgs extends LeafletEventArgs {\n        Center?: L.LatLng | null;\n        Zoom?: number | null;\n        NoUpdate?: boolean | null;\n\n        constructor(init?: Partial<LeafletZoomAnimEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Center = init.Center ?? null;\n                this.Zoom = init.Zoom ?? null;\n                this.NoUpdate = init.NoUpdate ?? null;\n            }\n        }\n\n        toDto(): LeafletZoomAnimEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Center: this.Center ?? null,\n                Zoom: this.Zoom ?? null,\n                NoUpdate: this.NoUpdate ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletZoomAnimEventArgs {\n            const center = ev?.center ?? (ev?.target && typeof ev.target.getCenter === 'function' ? ev.target.getCenter() : null);\n            const zoom = (typeof ev?.zoom === 'number') ? ev.zoom : (typeof ev?.newZoom === 'number' ? ev.newZoom : null);\n            const noUpdate = ('noUpdate' in (ev ?? {})) ? !!ev.noUpdate : null;\n\n            const dto: Partial<LeafletZoomAnimEventArgsDto> = {\n                Center: center,\n                Zoom: zoom,\n                NoUpdate: noUpdate,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n\n            return new LeafletZoomAnimEventArgs(dto);\n        }\n    }\n\n    export class LeafletFeatureMouseEventArgs extends LeafletMouseEventArgs {\n        LayerName?: string | null;\n        Feature?: any | null;\n\n        constructor(init?: Partial<LeafletFeatureMouseEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.LayerName = init.LayerName ?? null;\n                this.Feature = init.Feature ?? null;\n            }\n        }\n\n        toDto(): LeafletFeatureMouseEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                LayerName: this.LayerName ?? null,\n                Feature: this.Feature ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletFeatureMouseEventArgs {\n            const layerName = ev?.layerName ?? null;\n            const feature = ev?.feature ?? null;\n\n            const dto: Partial<LeafletFeatureMouseEventArgsDto> = {\n                LayerName: layerName,\n                Feature: feature,\n                LatLng: ev?.latlng ?? null,\n                LayerPoint: ev?.layerPoint ?? null,\n                ContainerPoint: ev?.containerPoint ?? null,\n                OriginalEvent: ev?.originalEvent ?? null,\n                Type: ev?.type ?? null,\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\n                Target: minimalLayerInfo(ev?.target) ?? null,\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\n            } as any;\n\n            return new LeafletFeatureMouseEventArgs(dto);\n        }\n    }\n\n    export class LeafletTileFetchErrorEventArgs extends LeafletTileErrorEventArgs {\n        Url?: string | null;\n        z?: number | null\n        x?: number | null;\n        y?: number | null;\n\n        constructor(init?: Partial<LeafletTileFetchErrorEventArgsDto>) {\n            super(init);\n            if (init) {\n                this.Url = init.Url ?? null;\n                this.z = init.z ?? null;\n                this.x = init.x ?? null;\n                this.y = init.y ?? null;\n            }\n        }\n\n        toDto(): LeafletTileFetchErrorEventArgsDto {\n            const base = super.toDto();\n            return Object.assign({}, base, {\n                Url: this.Url ?? null,\n                z: this.z ?? null,\n                x: this.x ?? null,\n                y: this.y ?? null\n            });\n        }\n\n        static fromLeaflet(ev: any): LeafletTileFetchErrorEventArgs {\n            const dto: Partial<LeafletTileFetchErrorEventArgsDto> = {\n                Url: ev?.url ?? null,\n                z: (typeof ev?.z === 'number') ? ev.z : null,\n                x: (typeof ev?.x === 'number') ? ev.x : null,\n                y: (typeof ev?.y === 'number') ? ev.y : null,\n                Tile: ev?.tile ?? ev?.tile ?? null,\n                Coords: (typeof ev?.coords === 'object') ? ev.coords : null,\n                Error: ev?.error ?? null\n            };\n            return new LeafletTileFetchErrorEventArgs(dto);\n        }\n    }\n}\n\nexport default LeafletEvents;\n","import { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\ndeclare const L: typeof import('leaflet');\n\nexport const Map = {\n    createMap(\n        elementId: string,\n        options: L.MapOptions | undefined,\n        handlerMappings?: EventHandlerMapping\n    ): any {\n        const map = L.map(elementId, options);\n\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n            if (keys.indexOf('resize') > -1) {\n                map.on('resize', function (ev: L.ResizeEvent) {\n                    var methodName = handlerMappings.events['resize'];\n                    let payload = LeafletEvents.LeafletResizeEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('viewreset') > -1) {\n                map.on('viewreset', function (ev: any) {\n                    var methodName = handlerMappings.events['viewreset'];\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('zoomlevelschange') > -1) {\n                map.on('zoomlevelschange', function (ev: any) {\n                    var methodName = handlerMappings.events['zoomlevelschange'];\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('zoomend') > -1) {\n                map.on('zoomend', function (ev: any) {\n                    var methodName = handlerMappings.events['zoomend'];\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('moveend') > -1) {\n                map.on('moveend', function (ev: any) {\n                    var methodName = handlerMappings.events['moveend'];\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('click') > -1) {\n                map.on('click', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events['click'];\n                    let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                map.on('dblclick', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1)\n            {\n                map.on('contextmenu', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                map.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                map.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('locationerror') > -1) {\n                map.on('locationerror', function (ev: L.ErrorEvent) {\n                    var methodName = handlerMappings.events['locationerror'];\n                    let payload = LeafletEvents.LeafletErrorEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n            if (keys.indexOf('locationfound') > -1) {\n                map.on('locationfound', function (ev: L.LocationEvent) {\n                    var methodName = handlerMappings.events['locationfound'];\n                    let payload = LeafletEvents.LeafletLocationEventArgs.fromLeaflet(ev).toDto();\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                });\n            }\n        }\n\n        // Create a wrapper object that properly serializes getBounds()\n        const mapWrapper = Object.create(map);\n        \n        // Override getBounds to return a properly formatted object for C# serialization\n        mapWrapper.getBounds = function() {\n            const bounds = map.getBounds();\n            const sw = bounds.getSouthWest();\n            const ne = bounds.getNorthEast();\n            \n            return {\n                SouthWest: {\n                    Lat: sw.lat,\n                    Lng: sw.lng\n                },\n                NorthEast: {\n                    Lat: ne.lat,\n                    Lng: ne.lng\n                }\n            };\n        };\n\n        return mapWrapper;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const Layer = {\n    addTo(layer: L.Layer, map: L.Map, handlerMappings?: EventHandlerMapping): void {\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n            if (keys.indexOf('add') > -1) {\n                layer.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                layer.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                layer.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                layer.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                layer.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                layer.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        layer.addTo(map);\n    },\n\n    remove(layer: L.Layer): void {\n        layer.remove();\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const GridLayer = {\n    createGridLayer(\n        options?: L.GridLayerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.GridLayer {\n        const gridLayer = L.gridLayer();\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            if (keys.indexOf('loading') > -1) {\n                gridLayer.on('loading', function (ev: any) {\n                    var methodName = handlerMappings.events['loading'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking loading handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileunload') > -1) {\n                gridLayer.on('tileunload', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileunload'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileunload handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileloadstart') > -1) {\n                gridLayer.on('tileloadstart', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileloadstart'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileloadstart handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileerror') > -1) {\n                gridLayer.on('tileerror', function (ev: L.TileErrorEvent) {\n                    var methodName = handlerMappings.events['tileerror'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileErrorEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileerror handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileload') > -1) {\n                gridLayer.on('tileload', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileload'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileload handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('load') > -1) {\n                gridLayer.on('load', function (ev: any) {\n                    var methodName = handlerMappings.events['load'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking load handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('add') > -1) {\n                gridLayer.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                gridLayer.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                gridLayer.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                gridLayer.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                gridLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                gridLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        return gridLayer;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const TileLayer = {\n    createTileLayer(\n        urlTemplate: string,\n        options?: L.TileLayerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.TileLayer {\n        const tileLayer = L.tileLayer(urlTemplate, options);\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            if (keys.indexOf('tileabort') > -1) {\n                tileLayer.on('tileabort', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileabort'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileabort handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('loading') > -1) {\n                tileLayer.on('loading', function (ev: any) {\n                    var methodName = handlerMappings.events['loading'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking loading handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileunload') > -1) {\n                tileLayer.on('tileunload', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileunload'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileunload handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileloadstart') > -1) {\n                tileLayer.on('tileloadstart', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileloadstart'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileloadstart handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileerror') > -1) {\n                tileLayer.on('tileerror', function (ev: L.TileErrorEvent) {\n                    var methodName = handlerMappings.events['tileerror'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileErrorEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileerror handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileload') > -1) {\n                tileLayer.on('tileload', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileload'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileload handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('load') > -1) {\n                tileLayer.on('load', function (ev: any) {\n                    var methodName = handlerMappings.events['load'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking load handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('add') > -1) {\n                tileLayer.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                tileLayer.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                tileLayer.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                tileLayer.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                tileLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                tileLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        return tileLayer;\n    }\n}\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const WmsTileLayer = {\n    createWmsTileLayer(\n        baseUrl: string,\n        options?: L.WMSOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.TileLayer.WMS {\n        const wmsTileLayer = L.tileLayer.wms(baseUrl, options);\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n            if (keys.indexOf('tileabort') > -1) {\n                wmsTileLayer.on('tileabort', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileabort'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileabort handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('loading') > -1) {\n                wmsTileLayer.on('loading', function (ev: any) {\n                    var methodName = handlerMappings.events['loading'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking loading handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileunload') > -1) {\n                wmsTileLayer.on('tileunload', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileunload'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileunload handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileloadstart') > -1) {\n                wmsTileLayer.on('tileloadstart', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileloadstart'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileloadstart handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileerror') > -1) {\n                wmsTileLayer.on('tileerror', function (ev: L.TileErrorEvent) {\n                    var methodName = handlerMappings.events['tileerror'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileErrorEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileerror handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tileload') > -1) {\n                wmsTileLayer.on('tileload', function (ev: L.TileEvent) {\n                    var methodName = handlerMappings.events['tileload'];\n                    try {\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tileload handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('load') > -1) {\n                wmsTileLayer.on('load', function (ev: any) {\n                    var methodName = handlerMappings.events['load'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking load handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('add') > -1) {\n                wmsTileLayer.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                wmsTileLayer.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                wmsTileLayer.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                wmsTileLayer.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                wmsTileLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                wmsTileLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        return wmsTileLayer;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\n// Common helper functions for vector tile layers\nconst VectorTileHelpers = {\n    getRendererFactory(rendererType?: string): any {\n        if (!rendererType) {\n            return undefined;\n        }\n\n        const type = rendererType.toLowerCase();\n        if (type === 'canvas') {\n            const LCanvas = (L as any).Canvas;\n            if (LCanvas && typeof LCanvas.tile === 'function') {\n                return LCanvas.tile;\n            }\n            console.warn('L.Canvas.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\n        } else if (type === 'svg') {\n            const LSVG = (L as any).SVG;\n            if (LSVG && typeof LSVG.tile === 'function') {\n                return LSVG.tile;\n            }\n            console.warn('L.SVG.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\n        }\n        return undefined;\n    },\n\n    setupFeatureSelection(\n        vectorTileLayer: any,\n        options: any,\n        handlerMappings?: EventHandlerMapping\n    ): void {\n        // Default styles (DRY - single source of truth)\n        const DEFAULT_SELECTION_STYLE = {\n            color: '#368ce1',\n            weight: 3,\n            fillColor: '#368ce1',\n            fillOpacity: 0.3,\n            opacity: 1\n        };\n\n        const DEFAULT_HOVER_STYLE = {\n            color: 'red',\n            weight: 2,\n            opacity: 1.0\n        };\n\n        // Selection state management\n        const selectedFeatures: Map<any, any> = new Map();\n        const selectedLayers: Map<any, any[]> = new Map();\n        \n        // Hover state management\n        const hoveredLayers: Map<any, any> = new Map(); // Map of layer -> original style (for hover)\n        \n        // Track all layers by feature ID as they're added\n        const layersByFeatureId: Map<string, any[]> = new Map();\n\n        const selectedFeatureStyle = options?.selectedFeatureStyle ?? DEFAULT_SELECTION_STYLE;\n\n        // Helper to apply selected style\n        const applySelectedStyle = (layer: any) => {\n            if (layer && layer.setStyle) {\n                const leafletStyle: any = {};\n                \n                if (selectedFeatureStyle.color) leafletStyle.color = selectedFeatureStyle.color;\n                if (selectedFeatureStyle.weight !== undefined) leafletStyle.weight = selectedFeatureStyle.weight;\n                if (selectedFeatureStyle.opacity !== undefined) leafletStyle.opacity = selectedFeatureStyle.opacity;\n                if (selectedFeatureStyle.fillColor) leafletStyle.fillColor = selectedFeatureStyle.fillColor;\n                if (selectedFeatureStyle.fillOpacity !== undefined) leafletStyle.fillOpacity = selectedFeatureStyle.fillOpacity;\n                if (selectedFeatureStyle.fill !== undefined) leafletStyle.fill = selectedFeatureStyle.fill;\n                if (selectedFeatureStyle.stroke !== undefined) leafletStyle.stroke = selectedFeatureStyle.stroke;\n                if (selectedFeatureStyle.dashArray) leafletStyle.dashArray = selectedFeatureStyle.dashArray;\n                if (selectedFeatureStyle.lineCap) leafletStyle.lineCap = selectedFeatureStyle.lineCap;\n                if (selectedFeatureStyle.lineJoin) leafletStyle.lineJoin = selectedFeatureStyle.lineJoin;\n                \n                layer.setStyle(leafletStyle);\n            }\n        };\n\n        // Helper to reset style to original\n        const resetStyle = (layer: any) => {\n            if (layer && layer.setStyle && layer.options?.originalStyle) {\n                layer.setStyle(layer.options.originalStyle);\n            }\n        };\n\n        // Helper to get feature identifier\n        const getFeatureIdentifier = (properties: any): string => {\n            return properties?.id ?? properties?.ID ?? properties?.fid ?? properties?.FID ??\n                properties?.objectid ?? properties?.OBJECTID ?? JSON.stringify(properties);\n        };\n\n        // Track layers as they're created by VectorGrid\n        vectorTileLayer.on('click', function(e: any) {\n            if (e.layer && e.layer.properties) {\n                const featureId = getFeatureIdentifier(e.layer.properties);\n                \n                // Add this layer to our tracking map\n                if (!layersByFeatureId.has(featureId)) {\n                    layersByFeatureId.set(featureId, []);\n                }\n                const layers = layersByFeatureId.get(featureId)!;\n                if (!layers.includes(e.layer)) {\n                    layers.push(e.layer);\n                }\n            }\n        });\n\n        // Helper to find and style all layers with the same feature ID\n        const selectAllSegments = (featureId: string) => {\n            const layers = layersByFeatureId.get(featureId) || [];\n            \n            layers.forEach(layer => {\n                // Store original style if not already stored\n                if (!layer.options.originalStyle) {\n                    layer.options.originalStyle = {\n                        fillColor: layer.options.fillColor,\n                        color: layer.options.color,\n                        weight: layer.options.weight,\n                        fillOpacity: layer.options.fillOpacity,\n                        fill: layer.options.fill\n                    };\n                }\n                \n                applySelectedStyle(layer);\n            });\n            \n            return layers;\n        };\n\n        // Helper to reset all segments of a feature\n        const unselectAllSegments = (featureId: string) => {\n            const layers = selectedLayers.get(featureId);\n            if (layers) {\n                layers.forEach(layer => resetStyle(layer));\n            }\n        };\n\n        // Add click handler for feature selection\n        if (options?.enableFeatureSelection !== false) {\n            vectorTileLayer.on('click', function (e: any) {\n                if (e.layer && e.layer.properties) {\n                    // Check current enableFeatureSelection state\n                    const currentOptions = vectorTileLayer._pyroOptions || options;\n                    if (currentOptions?.enableFeatureSelection === false) {\n                        return; // Selection disabled\n                    }\n                    \n                    const featureId = getFeatureIdentifier(e.layer.properties);\n                    const feature = {\n                        id: featureId,\n                        type: e.layer.feature?.type ?? 'Feature',\n                        geometry: e.layer.feature?.geometry,\n                        properties: e.layer.properties\n                    };\n\n                    const isSelected = selectedFeatures.has(featureId);\n\n                    if (isSelected) {\n                        // Unselect all segments of this feature\n                        const layers = selectedLayers.get(featureId);\n                        \n                        unselectAllSegments(featureId);\n                        selectedFeatures.delete(featureId);\n                        selectedLayers.delete(featureId);\n                        \n                        // Check if any segment is currently being hovered\n                        // If so, reapply hover style instead of original\n                        if (layers) {\n                            const isCurrentlyHovered = layers.some(layer => hoveredLayers.has(layer));\n                            \n                            if (isCurrentlyHovered) {\n                                // Reapply hover style to all segments\n                                const hoverStyle = currentOptions?.hoverStyle || DEFAULT_HOVER_STYLE;\n                                layers.forEach(layer => {\n                                    if (layer.setStyle) {\n                                        const currentStyle = {\n                                            color: layer.options.originalStyle?.color || layer.options.color,\n                                            weight: layer.options.originalStyle?.weight || layer.options.weight,\n                                            opacity: layer.options.originalStyle?.opacity || layer.options.opacity,\n                                            fillColor: layer.options.originalStyle?.fillColor || layer.options.fillColor,\n                                            fillOpacity: layer.options.originalStyle?.fillOpacity || layer.options.fillOpacity\n                                        };\n                                        const mergedStyle = { ...currentStyle, ...hoverStyle };\n                                        layer.setStyle(mergedStyle);\n                                    }\n                                });\n                            }\n                        }\n\n                        // Notify C# of unselection\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureunselected']) {\n                            handlerMappings.dotNetRef.invokeMethodAsync(\n                                handlerMappings.events['featureunselected'],\n                                {\n                                    feature: feature,\n                                    latlng: e.latlng,\n                                    layerPoint: e.layerPoint,\n                                    containerPoint: e.containerPoint\n                                }\n                            );\n                        }\n                    } else {\n                        // Handle multiple selection based on current state\n                        const allowMultiple = currentOptions?.multipleFeatureSelection === true;\n                        \n                        if (!allowMultiple) {\n                            // Unselect all previously selected features\n                            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\n                            selectedFeatures.clear();\n                            selectedLayers.clear();\n                        }\n\n                        // Select all segments of this feature across all tiles\n                        const layers = selectAllSegments(featureId);\n                        \n                        // Bring all selected segments to front\n                        layers.forEach(layer => {\n                            if (layer.bringToFront) {\n                                layer.bringToFront();\n                            }\n                            // Note: Don't clear hover state - keep it for proper restoration\n                            // The selection style will override the hover style visually\n                        });\n                        \n                        selectedFeatures.set(featureId, feature);\n                        selectedLayers.set(featureId, layers);\n\n                        // Notify C# of selection\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureselected']) {\n                            handlerMappings.dotNetRef.invokeMethodAsync(\n                                handlerMappings.events['featureselected'],\n                                {\n                                    feature: feature,\n                                    latlng: e.latlng,\n                                    layerPoint: e.layerPoint,\n                                    containerPoint: e.containerPoint\n                                }\n                            );\n                        }\n                    }\n\n                    // Always fire clicked event\n                    if (handlerMappings?.dotNetRef && handlerMappings.events['featureclicked']) {\n                        handlerMappings.dotNetRef.invokeMethodAsync(\n                            handlerMappings.events['featureclicked'],\n                            {\n                                feature: feature,\n                                latlng: e.latlng,\n                                layerPoint: e.layerPoint,\n                                containerPoint: e.containerPoint\n                            }\n                        );\n                    }\n                }\n            });\n        }\n\n        // Add clearSelection method\n        (vectorTileLayer as any).clearSelection = function () {\n            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\n            selectedFeatures.clear();\n            selectedLayers.clear();\n            \n            // Clear any hover states\n            hoveredLayers.forEach((originalStyle, layer) => {\n                if (layer && layer.setStyle && originalStyle) {\n                    layer.setStyle(originalStyle);\n                }\n            });\n            hoveredLayers.clear();\n        };\n\n        // Hover styling (controlled by enableHoverStyle flag and interactive mode)\n        if (options?.interactive === true && options?.enableHoverStyle !== false) {\n            const hoverStyle = options?.hoverStyle || DEFAULT_HOVER_STYLE;\n            \n            vectorTileLayer.on('mouseover', function (e: any) {\n                if (e.layer && e.layer.properties) {\n                    const featureId = getFeatureIdentifier(e.layer.properties);\n                    \n                    // Track this layer for selection (even if just hovering)\n                    if (!layersByFeatureId.has(featureId)) {\n                        layersByFeatureId.set(featureId, []);\n                    }\n                    const layers = layersByFeatureId.get(featureId)!;\n                    if (!layers.includes(e.layer)) {\n                        layers.push(e.layer);\n                    }\n                    \n                    // Don't apply hover if feature is selected\n                    if (!selectedFeatures.has(featureId)) {\n                        // Get all segments of this feature\n                        const allSegments = layersByFeatureId.get(featureId) || [];\n                        \n                        // Apply hover to ALL segments\n                        allSegments.forEach(layer => {\n                            // Bring to front if possible\n                            if (layer.bringToFront) {\n                                layer.bringToFront();\n                            }\n                            \n                            // Store original style if not already hovering\n                            if (!hoveredLayers.has(layer)) {\n                                hoveredLayers.set(layer, {\n                                    color: layer.options.color,\n                                    weight: layer.options.weight,\n                                    opacity: layer.options.opacity,\n                                    fillColor: layer.options.fillColor,\n                                    fillOpacity: layer.options.fillOpacity\n                                });\n                                \n                                // Apply hover style (merge with current to preserve fill)\n                                const currentStyle = {\n                                    color: layer.options.color,\n                                    weight: layer.options.weight,\n                                    opacity: layer.options.opacity,\n                                    fillColor: layer.options.fillColor,\n                                    fillOpacity: layer.options.fillOpacity\n                                };\n                                \n                                const mergedStyle = { ...currentStyle, ...hoverStyle };\n                                if (layer.setStyle) {\n                                    layer.setStyle(mergedStyle);\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n\n            vectorTileLayer.on('mouseout', function (e: any) {\n                if (e.layer && e.layer.properties) {\n                    const featureId = getFeatureIdentifier(e.layer.properties);\n                    \n                    // Get all segments that were hovered\n                    const allSegments = layersByFeatureId.get(featureId) || [];\n                    \n                    // Restore ALL segments\n                    allSegments.forEach(layer => {\n                        if (hoveredLayers.has(layer)) {\n                            const originalStyle = hoveredLayers.get(layer);\n                            \n                            // Check if feature is selected\n                            const isSelected = selectedFeatures.has(featureId);\n                            \n                            if (isSelected) {\n                                // Don't restore - reapply selection style instead\n                                applySelectedStyle(layer);\n                            } else if (originalStyle && layer.setStyle) {\n                                // Restore original style\n                                layer.setStyle(originalStyle);\n                            }\n                            \n                            hoveredLayers.delete(layer);\n                        }\n                    });\n                }\n            });\n        }\n    },\n\n    attachGridLayerEvents(vectorTileLayer: any, handlerMappings?: EventHandlerMapping): void {\n        if (!handlerMappings?.dotNetRef || !handlerMappings.events) {\n            return;\n        }\n\n        const keys = Object.keys(handlerMappings.events);\n\n        const eventMappings: { [key: string]: { eventName: string, argType: string } } = {\n            'loading': { eventName: 'loading', argType: 'LeafletEventArgs' },\n            'tileunload': { eventName: 'tileunload', argType: 'LeafletTileEventArgs' },\n            'tileloadstart': { eventName: 'tileloadstart', argType: 'LeafletTileEventArgs' },\n            'tileerror': { eventName: 'tileerror', argType: 'LeafletTileErrorEventArgs' },\n            'tileload': { eventName: 'tileload', argType: 'LeafletTileEventArgs' },\n            'load': { eventName: 'load', argType: 'LeafletEventArgs' },\n            'add': { eventName: 'add', argType: 'LeafletEventArgs' },\n            'remove': { eventName: 'remove', argType: 'LeafletEventArgs' }\n        };\n\n        for (const key of keys) {\n            const mapping = eventMappings[key];\n            if (mapping) {\n                vectorTileLayer.on(mapping.eventName, function (ev: any) {\n                    const methodName = handlerMappings.events[key];\n                    try {\n                        const EventClass = (LeafletEvents as any)[mapping.argType];\n                        const payload = EventClass.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking ${mapping.eventName} handler:`, e);\n                    }\n                });\n            }\n        }\n    },\n\n    attachInteractiveEvents(vectorTileLayer: any, options: any, handlerMappings?: EventHandlerMapping): void {\n        // Only attach interactive events if the layer is set to interactive\n        if (!options?.interactive || !handlerMappings?.dotNetRef || !handlerMappings.events) {\n            return;\n        }\n\n        const keys = Object.keys(handlerMappings.events);\n\n        // Mouse events on features\n        const interactiveEventMappings: { [key: string]: string } = {\n            'mouseover': 'mouseover',\n            'mouseout': 'mouseout',\n            'mousemove': 'mousemove',\n            'dblclick': 'dblclick',\n            'contextmenu': 'contextmenu'\n        };\n\n        for (const [eventKey, leafletEvent] of Object.entries(interactiveEventMappings)) {\n            if (keys.indexOf(eventKey) > -1) {\n                vectorTileLayer.on(leafletEvent, function (e: any) {\n                    const methodName = handlerMappings.events[eventKey];\n                    try {\n                        const payload = {\n                            latlng: e.latlng ? { lat: e.latlng.lat, lng: e.latlng.lng } : null,\n                            layerPoint: e.layerPoint ? { x: e.layerPoint.x, y: e.layerPoint.y } : null,\n                            containerPoint: e.containerPoint ? { x: e.containerPoint.x, y: e.containerPoint.y } : null,\n                            feature: e.layer && e.layer.properties ? {\n                                id: e.layer.properties.id ?? e.layer.properties.ID ?? e.layer.properties.fid ?? e.layer.properties.FID,\n                                type: e.layer.feature?.type ?? 'Feature',\n                                geometry: e.layer.feature?.geometry,\n                                properties: e.layer.properties\n                            } : null\n                        };\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (err) {\n                        console.error(`Error invoking ${eventKey} handler:`, err);\n                    }\n                });\n            }\n        }\n    },\n\n    setInteractive(vectorTileLayer: any, interactive: boolean): void {\n        // Update the interactive option\n        if (vectorTileLayer.options) {\n            vectorTileLayer.options.interactive = interactive;\n        }\n        \n        // VectorGrid stores interactivity at the layer level\n        // We need to update the actual layer's interactive state\n        if ((vectorTileLayer as any)._vectorTiles) {\n            // Iterate through all loaded tiles and update their interactive state\n            Object.values((vectorTileLayer as any)._vectorTiles).forEach((tile: any) => {\n                if (tile && tile._features) {\n                    Object.values(tile._features).forEach((feature: any) => {\n                        if (feature) {\n                            feature.options.interactive = interactive;\n                        }\n                    });\n                }\n            });\n        }\n        \n        // Redraw the layer to apply changes\n        if (vectorTileLayer.redraw) {\n            vectorTileLayer.redraw();\n        }\n    },\n\n    setEnableFeatureSelection(vectorTileLayer: any, enableFeatureSelection: boolean): void {\n        // Update the enableFeatureSelection option\n        if (vectorTileLayer._pyroOptions) {\n            vectorTileLayer._pyroOptions.enableFeatureSelection = enableFeatureSelection;\n        }\n        \n        // If disabling selection, clear any current selections\n        if (!enableFeatureSelection && vectorTileLayer.clearSelection) {\n            vectorTileLayer.clearSelection();\n        }\n    },\n\n    setMultipleFeatureSelection(vectorTileLayer: any, multipleFeatureSelection: boolean): void {\n        // Update the multipleFeatureSelection option\n        if (vectorTileLayer._pyroOptions) {\n            vectorTileLayer._pyroOptions.multipleFeatureSelection = multipleFeatureSelection;\n        }\n        \n        // If switching from multiple to single selection and multiple features are selected,\n        // keep only the most recently selected feature\n        if (!multipleFeatureSelection && vectorTileLayer.clearSelection) {\n            // Note: We don't clear here - the next selection will handle it\n            // The selection logic checks the multipleFeatureSelection flag\n        }\n    }\n};\n\nexport const ProtobufVectorTileLayer = {\n    createProtobufVectorTileLayer(\n        urlTemplate: string,\n        options?: any,\n        handlerMappings?: EventHandlerMapping\n    ): L.Layer {\n        // Check if Leaflet.VectorGrid is available\n        if (!(L as any).vectorGrid || typeof (L as any).vectorGrid.protobuf !== 'function') {\n            console.error('Leaflet.VectorGrid plugin is not loaded. Please include Leaflet.VectorGrid.bundled.js');\n            throw new Error('Leaflet.VectorGrid plugin is required but not loaded');\n        }\n\n        // Replace {LayerName} placeholder if layerName is provided in options\n        if (options?.layerName) {\n            urlTemplate = urlTemplate.replace('{LayerName}', options.layerName);\n        }\n\n        // Build VectorGrid options with default fill style\n        let vectorTileLayerStyles = options?.vectorTileLayerStyles;\n        \n        // VectorGrid expects vectorTileLayerStyles to be an object where:\n        // - Keys are layer names (must match exactly what's in the MVT)\n        // - Values can be objects OR functions that return style objects\n        \n        if (vectorTileLayerStyles && typeof vectorTileLayerStyles === 'object' && Object.keys(vectorTileLayerStyles).length > 0) {\n            // Log each style and create a default catchall\n            const enhancedStyles: any = {};\n            \n            for (const [layerName, style] of Object.entries(vectorTileLayerStyles)) {\n                // Wrap each style in a function that VectorGrid will call per-feature\n                enhancedStyles[layerName] = function(properties: any) {\n                    return style;\n                };\n            }\n            \n            // Add a catchall for any layer name variations\n            const firstStyle = Object.values(vectorTileLayerStyles)[0];\n            const layerKeys = Object.keys(vectorTileLayerStyles);\n            \n            // Try common variations of the layer names\n            for (const key of layerKeys) {\n                // Add version without workspace prefix (e.g., \"PlannerSpatial:Township\" -> \"Township\")\n                const simpleName = key.split(':').pop();\n                if (simpleName && !enhancedStyles[simpleName]) {\n                    enhancedStyles[simpleName] = function(properties: any) {\n                        return firstStyle;\n                    };\n                }\n            }\n            \n            vectorTileLayerStyles = enhancedStyles;\n            \n        } else if (!vectorTileLayerStyles || Object.keys(vectorTileLayerStyles).length === 0) {\n            // Create a default style function for unspecified layers\n            vectorTileLayerStyles = {\n                '': function() {\n                    return {\n                        fill: true,\n                        fillColor: '#3388ff',\n                        fillOpacity: 0.2,\n                        stroke: true,\n                        color: '#3388ff',\n                        weight: 1,\n                        opacity: 1\n                    };\n                }\n            };\n        }\n\n        const vectorGridOptions: any = {\n            interactive: options?.interactive ?? false,\n            getFeatureId: options?.getFeatureId,\n            vectorTileLayerStyles: vectorTileLayerStyles,\n            minZoom: options?.minZoom ?? 0,\n            maxZoom: options?.maxZoom,\n            maxNativeZoom: options?.maxNativeZoom,\n            minNativeZoom: options?.minNativeZoom,\n            tileSize: options?.tileSize ?? 256,\n            opacity: options?.opacity ?? 1.0,\n            updateWhenIdle: options?.updateWhenIdle,\n            updateWhenZooming: options?.updateWhenZooming ?? true,\n            updateInterval: options?.updateInterval ?? 200,\n            zIndex: options?.zIndex ?? 1,\n            bounds: options?.bounds,\n            noWrap: options?.noWrap ?? false,\n            pane: options?.pane ?? 'tilePane',\n            className: options?.className ?? '',\n            keepBuffer: options?.keepBuffer ?? 2,\n            attribution: options?.attribution ?? ''\n        };\n\n        // Only add subdomains if provided, otherwise VectorGrid uses its default\n        if (options?.subdomains !== undefined && options.subdomains !== null) {\n            vectorGridOptions.subdomains = options.subdomains;\n        }\n\n        // Add renderer factory if specified\n        const rendererFactory = VectorTileHelpers.getRendererFactory(options?.rendererFactory);\n        if (rendererFactory !== undefined) {\n            vectorGridOptions.rendererFactory = rendererFactory;\n        }\n\n        // Create the VectorGrid Protobuf layer\n        const vectorTileLayer = (L as any).vectorGrid.protobuf(urlTemplate, vectorGridOptions);\n\n        // Store options for dynamic updates\n        (vectorTileLayer as any)._pyroOptions = {\n            interactive: options?.interactive ?? false,\n            enableFeatureSelection: options?.enableFeatureSelection !== false,\n            multipleFeatureSelection: options?.multipleFeatureSelection === true,\n            enableHoverStyle: options?.enableHoverStyle !== false,\n            selectedFeatureStyle: options?.selectedFeatureStyle,\n            hoverStyle: options?.hoverStyle\n        };\n\n        // Setup feature selection\n        VectorTileHelpers.setupFeatureSelection(vectorTileLayer, options, handlerMappings);\n\n        // Attach interactive event handlers (mouseover, mouseout, etc.)\n        VectorTileHelpers.attachInteractiveEvents(vectorTileLayer, options, handlerMappings);\n\n        // Attach standard event handlers\n        VectorTileHelpers.attachGridLayerEvents(vectorTileLayer, handlerMappings);\n\n        // Expose setInteractive method\n        (vectorTileLayer as any).setInteractive = function (interactive: boolean) {\n            VectorTileHelpers.setInteractive(vectorTileLayer, interactive);\n        };\n\n        // Expose setEnableFeatureSelection method\n        (vectorTileLayer as any).setEnableFeatureSelection = function (enableFeatureSelection: boolean) {\n            VectorTileHelpers.setEnableFeatureSelection(vectorTileLayer, enableFeatureSelection);\n        };\n\n        // Expose setMultipleFeatureSelection method\n        (vectorTileLayer as any).setMultipleFeatureSelection = function (multipleFeatureSelection: boolean) {\n            VectorTileHelpers.setMultipleFeatureSelection(vectorTileLayer, multipleFeatureSelection);\n        };\n\n        return vectorTileLayer;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\n// Import helpers from protobuf implementation\n// Note: In a real implementation, you'd extract these to a shared module\n// For now, we'll duplicate the minimal needed code\n\nconst getRendererFactory = (rendererType?: string): any => {\n    if (!rendererType) {\n        return undefined;\n    }\n\n    const type = rendererType.toLowerCase();\n    if (type === 'canvas') {\n        const LCanvas = (L as any).Canvas;\n        if (LCanvas && typeof LCanvas.tile === 'function') {\n            return LCanvas.tile;\n        }\n        console.warn('L.Canvas.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\n    } else if (type === 'svg') {\n        const LSVG = (L as any).SVG;\n        if (LSVG && typeof LSVG.tile === 'function') {\n            return LSVG.tile;\n        }\n        console.warn('L.SVG.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\n    }\n    return undefined;\n};\n\nexport const SlicerVectorTileLayer = {\n    createSlicerVectorTileLayer(\n        geoJsonData: any,\n        options?: any,\n        handlerMappings?: EventHandlerMapping\n    ): L.Layer {\n        // Check if Leaflet.VectorGrid is available\n        if (!(L as any).vectorGrid || typeof (L as any).vectorGrid.slicer !== 'function') {\n            console.error('Leaflet.VectorGrid plugin is not loaded. Please include Leaflet.VectorGrid.bundled.js');\n            throw new Error('Leaflet.VectorGrid plugin is required but not loaded');\n        }\n\n        // Build VectorGrid options with default fill style\n        let vectorTileLayerStyles = options?.vectorTileLayerStyles;\n        \n        // If no custom styles provided, use a default style with fill\n        if (!vectorTileLayerStyles || Object.keys(vectorTileLayerStyles).length === 0) {\n            vectorTileLayerStyles = function () {\n                return {\n                    fill: true,\n                    fillColor: '#3388ff',\n                    fillOpacity: 0.2,\n                    stroke: true,\n                    color: '#3388ff',\n                    weight: 1,\n                    opacity: 1\n                };\n            };\n        }\n\n        const vectorGridOptions: any = {\n            interactive: options?.interactive ?? false,\n            getFeatureId: options?.getFeatureId,\n            vectorTileLayerStyles: vectorTileLayerStyles,\n            minZoom: options?.minZoom ?? 0,\n            maxZoom: options?.maxZoom,\n            maxNativeZoom: options?.maxNativeZoom,\n            minNativeZoom: options?.minNativeZoom,\n            tileSize: options?.tileSize ?? 256,\n            opacity: options?.opacity ?? 1.0,\n            updateWhenIdle: options?.updateWhenIdle,\n            updateWhenZooming: options?.updateWhenZooming ?? true,\n            updateInterval: options?.updateInterval ?? 200,\n            zIndex: options?.zIndex ?? 1,\n            bounds: options?.bounds,\n            noWrap: options?.noWrap ?? false,\n            pane: options?.pane ?? 'tilePane',\n            className: options?.className ?? '',\n            keepBuffer: options?.keepBuffer ?? 2,\n            attribution: options?.attribution ?? ''\n        };\n\n        // Add renderer factory if specified\n        const rendererFactory = getRendererFactory(options?.rendererFactory);\n        if (rendererFactory !== undefined) {\n            vectorGridOptions.rendererFactory = rendererFactory;\n        }\n\n        // Create the VectorGrid Slicer layer\n        const vectorTileLayer = (L as any).vectorGrid.slicer(geoJsonData, vectorGridOptions);\n\n        // Store options for dynamic updates\n        (vectorTileLayer as any)._pyroOptions = {\n            interactive: options?.interactive ?? false,\n            enableFeatureSelection: options?.enableFeatureSelection !== false,\n            multipleFeatureSelection: options?.multipleFeatureSelection === true,\n            enableHoverStyle: options?.enableHoverStyle !== false,\n            selectedFeatureStyle: options?.selectedFeatureStyle,\n            hoverStyle: options?.hoverStyle\n        };\n\n        // Default styles (DRY - single source of truth)\n        const DEFAULT_SELECTION_STYLE = {\n            color: '#368ce1',\n            weight: 3,\n            fillColor: '#368ce1',\n            fillOpacity: 0.3,\n            opacity: 1\n        };\n\n        const DEFAULT_HOVER_STYLE = {\n            color: 'red',\n            weight: 2,\n            opacity: 1.0\n        };\n\n        // Setup feature selection with multi-segment support\n        const selectedFeatures: Map<any, any> = new Map();\n        const selectedLayers: Map<any, any[]> = new Map();\n        \n        // Hover state management\n        const hoveredLayers: Map<any, any> = new Map(); // Map of layer -> original style (for hover)\n        \n        // Track all layers by feature ID as they're added\n        const layersByFeatureId: Map<string, any[]> = new Map();\n\n        const selectedFeatureStyle = options?.selectedFeatureStyle ?? DEFAULT_SELECTION_STYLE;\n\n        const applySelectedStyle = (layer: any) => {\n            if (layer && layer.setStyle) {\n                const leafletStyle: any = {};\n                \n                if (selectedFeatureStyle.color) leafletStyle.color = selectedFeatureStyle.color;\n                if (selectedFeatureStyle.weight !== undefined) leafletStyle.weight = selectedFeatureStyle.weight;\n                if (selectedFeatureStyle.opacity !== undefined) leafletStyle.opacity = selectedFeatureStyle.opacity;\n                if (selectedFeatureStyle.fillColor) leafletStyle.fillColor = selectedFeatureStyle.fillColor;\n                if (selectedFeatureStyle.fillOpacity !== undefined) leafletStyle.fillOpacity = selectedFeatureStyle.fillOpacity;\n                if (selectedFeatureStyle.fill !== undefined) leafletStyle.fill = selectedFeatureStyle.fill;\n                if (selectedFeatureStyle.stroke !== undefined) leafletStyle.stroke = selectedFeatureStyle.stroke;\n                if (selectedFeatureStyle.dashArray) leafletStyle.dashArray = selectedFeatureStyle.dashArray;\n                if (selectedFeatureStyle.lineCap) leafletStyle.lineCap = selectedFeatureStyle.lineCap;\n                if (selectedFeatureStyle.lineJoin) leafletStyle.lineJoin = selectedFeatureStyle.lineJoin;\n                \n                layer.setStyle(leafletStyle);\n            }\n        };\n\n        const resetStyle = (layer: any) => {\n            if (layer && layer.setStyle && layer.options?.originalStyle) {\n                layer.setStyle(layer.options.originalStyle);\n            }\n        };\n\n        const getFeatureIdentifier = (properties: any): string => {\n            return properties?.id ?? properties?.ID ?? properties?.fid ?? properties?.FID ??\n                properties?.objectid ?? properties?.OBJECTID ?? JSON.stringify(properties);\n        };\n\n        // Track layers as they're interacted with\n        const trackLayer = (layer: any) => {\n            if (layer && layer.properties) {\n                const featureId = getFeatureIdentifier(layer.properties);\n                if (!layersByFeatureId.has(featureId)) {\n                    layersByFeatureId.set(featureId, []);\n                }\n                const layers = layersByFeatureId.get(featureId)!;\n                if (!layers.includes(layer)) {\n                    layers.push(layer);\n                }\n            }\n        };\n\n        // Helper to find and style all segments with the same feature ID\n        const selectAllSegments = (featureId: string) => {\n            const layers = layersByFeatureId.get(featureId) || [];\n            \n            layers.forEach(layer => {\n                if (!layer.options.originalStyle) {\n                    layer.options.originalStyle = {\n                        fillColor: layer.options.fillColor,\n                        color: layer.options.color,\n                        weight: layer.options.weight,\n                        fillOpacity: layer.options.fillOpacity,\n                        fill: layer.options.fill\n                    };\n                }\n                \n                applySelectedStyle(layer);\n            });\n            \n            return layers;\n        };\n\n        const unselectAllSegments = (featureId: string) => {\n            const layers = selectedLayers.get(featureId);\n            if (layers) {\n                layers.forEach(layer => resetStyle(layer));\n            }\n        };\n\n        if (options?.enableFeatureSelection !== false) {\n            vectorTileLayer.on('click', function (e: any) {\n                if (e.layer && e.layer.properties) {\n                    // Check current enableFeatureSelection state\n                    const currentOptions = vectorTileLayer._pyroOptions || options;\n                    if (currentOptions?.enableFeatureSelection === false) {\n                        return; // Selection disabled\n                    }\n                    \n                    // Track this layer\n                    trackLayer(e.layer);\n                    \n                    const featureId = getFeatureIdentifier(e.layer.properties);\n                    const feature = {\n                        id: featureId,\n                        type: e.layer.feature?.type ?? 'Feature',\n                        geometry: e.layer.feature?.geometry,\n                        properties: e.layer.properties\n                    };\n\n                    const isSelected = selectedFeatures.has(featureId);\n\n                    if (isSelected) {\n                        // Unselect all segments of this feature\n                        const layers = selectedLayers.get(featureId);\n                        \n                        unselectAllSegments(featureId);\n                        selectedFeatures.delete(featureId);\n                        selectedLayers.delete(featureId);\n                        \n                        // Check if any segment is currently being hovered\n                        // If so, reapply hover style instead of original\n                        if (layers) {\n                            const isCurrentlyHovered = layers.some(layer => hoveredLayers.has(layer));\n                            \n                            if (isCurrentlyHovered) {\n                                // Reapply hover style to all segments\n                                const hoverStyle = currentOptions?.hoverStyle || DEFAULT_HOVER_STYLE;\n                                layers.forEach(layer => {\n                                    if (layer.setStyle) {\n                                        const currentStyle = {\n                                            color: layer.options.originalStyle?.color || layer.options.color,\n                                            weight: layer.options.originalStyle?.weight || layer.options.weight,\n                                            opacity: layer.options.originalStyle?.opacity || layer.options.opacity,\n                                            fillColor: layer.options.originalStyle?.fillColor || layer.options.fillColor,\n                                            fillOpacity: layer.options.originalStyle?.fillOpacity || layer.options.fillOpacity\n                                        };\n                                        const mergedStyle = { ...currentStyle, ...hoverStyle };\n                                        layer.setStyle(mergedStyle);\n                                    }\n                                });\n                            }\n                        }\n\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureunselected']) {\n                            handlerMappings.dotNetRef.invokeMethodAsync(\n                                handlerMappings.events['featureunselected'],\n                                {\n                                    feature: feature,\n                                    latlng: e.latlng,\n                                    layerPoint: e.layerPoint,\n                                    containerPoint: e.containerPoint\n                                }\n                            );\n                        }\n                    } else {\n                        // Handle multiple selection based on current state\n                        const allowMultiple = currentOptions?.multipleFeatureSelection === true;\n                        \n                        if (!allowMultiple) {\n                            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\n                            selectedFeatures.clear();\n                            selectedLayers.clear();\n                        }\n\n                        const layers = selectAllSegments(featureId);\n                        \n                        // Bring all selected segments to front\n                        layers.forEach(layer => {\n                            if (layer.bringToFront) {\n                                layer.bringToFront();\n                            }\n                            // Note: Don't clear hover state - keep it for proper restoration\n                            // The selection style will override the hover style visually\n                        });\n                        \n                        selectedFeatures.set(featureId, feature);\n                        selectedLayers.set(featureId, layers);\n\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureselected']) {\n                            handlerMappings.dotNetRef.invokeMethodAsync(\n                                handlerMappings.events['featureselected'],\n                                {\n                                    feature: feature,\n                                    latlng: e.latlng,\n                                    layerPoint: e.layerPoint,\n                                    containerPoint: e.containerPoint\n                                }\n                            );\n                        }\n                    }\n\n                    if (handlerMappings?.dotNetRef && handlerMappings.events['featureclicked']) {\n                        handlerMappings.dotNetRef.invokeMethodAsync(\n                            handlerMappings.events['featureclicked'],\n                            {\n                                feature: feature,\n                                latlng: e.latlng,\n                                layerPoint: e.layerPoint,\n                                containerPoint: e.containerPoint\n                            }\n                        );\n                    }\n                }\n            });\n        }\n\n        (vectorTileLayer as any).clearSelection = function () {\n            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\n            selectedFeatures.clear();\n            selectedLayers.clear();\n            \n            // Clear any hover states\n            hoveredLayers.forEach((originalStyle, layer) => {\n                if (layer && layer.setStyle && originalStyle) {\n                    layer.setStyle(originalStyle);\n                }\n            });\n            hoveredLayers.clear();\n        };\n\n        // Hover styling (controlled by enableHoverStyle flag and interactive mode)\n        if (options?.interactive === true && options?.enableHoverStyle !== false) {\n            const hoverStyle = options?.hoverStyle || DEFAULT_HOVER_STYLE;\n            \n            vectorTileLayer.on('mouseover', function (e: any) {\n                if (e.layer && e.layer.properties) {\n                    // Track this layer\n                    trackLayer(e.layer);\n                    \n                    const featureId = getFeatureIdentifier(e.layer.properties);\n                    \n                    // Don't apply hover if feature is selected\n                    if (!selectedFeatures.has(featureId)) {\n                        // Get all segments of this feature\n                        const allSegments = layersByFeatureId.get(featureId) || [];\n                        \n                        // Apply hover to ALL segments\n                        allSegments.forEach(layer => {\n                            // Bring to front if possible\n                            if (layer.bringToFront) {\n                                layer.bringToFront();\n                            }\n                            \n                            // Store original style if not already hovering\n                            if (!hoveredLayers.has(layer)) {\n                                hoveredLayers.set(layer, {\n                                    color: layer.options.color,\n                                    weight: layer.options.weight,\n                                    opacity: layer.options.opacity,\n                                    fillColor: layer.options.fillColor,\n                                    fillOpacity: layer.options.fillOpacity\n                                });\n                                \n                                // Apply hover style (merge with current to preserve fill)\n                                const currentStyle = {\n                                    color: layer.options.color,\n                                    weight: layer.options.weight,\n                                    opacity: layer.options.opacity,\n                                    fillColor: layer.options.fillColor,\n                                    fillOpacity: layer.options.fillOpacity\n                                };\n                                \n                                const mergedStyle = { ...currentStyle, ...hoverStyle };\n                                if (layer.setStyle) {\n                                    layer.setStyle(mergedStyle);\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n\n            vectorTileLayer.on('mouseout', function (e: any) {\n                if (e.layer && e.layer.properties) {\n                    const featureId = getFeatureIdentifier(e.layer.properties);\n                    \n                    // Get all segments that were hovered\n                    const allSegments = layersByFeatureId.get(featureId) || [];\n                    \n                    // Restore ALL segments\n                    allSegments.forEach(layer => {\n                        if (hoveredLayers.has(layer)) {\n                            const originalStyle = hoveredLayers.get(layer);\n                            \n                            // Check if feature is selected\n                            const isSelected = selectedFeatures.has(featureId);\n                            \n                            if (isSelected) {\n                                // Don't restore - reapply selection style instead\n                                applySelectedStyle(layer);\n                            } else if (originalStyle && layer.setStyle) {\n                                // Restore original style\n                                layer.setStyle(originalStyle);\n                            }\n                            \n                            hoveredLayers.delete(layer);\n                        }\n                    });\n                }\n            });\n        }\n\n        // Attach standard GridLayer event handlers\n        if (handlerMappings?.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n            const eventMappings: { [key: string]: { eventName: string, argType: string } } = {\n                'loading': { eventName: 'loading', argType: 'LeafletEventArgs' },\n                'tileunload': { eventName: 'tileunload', argType: 'LeafletTileEventArgs' },\n                'tileloadstart': { eventName: 'tileloadstart', argType: 'LeafletTileEventArgs' },\n                'tileerror': { eventName: 'tileerror', argType: 'LeafletTileErrorEventArgs' },\n                'tileload': { eventName: 'tileload', argType: 'LeafletTileEventArgs' },\n                'load': { eventName: 'load', argType: 'LeafletEventArgs' },\n                'add': { eventName: 'add', argType: 'LeafletEventArgs' },\n                'remove': { eventName: 'remove', argType: 'LeafletEventArgs' }\n            };\n\n            for (const key of keys) {\n                const mapping = eventMappings[key];\n                if (mapping) {\n                    vectorTileLayer.on(mapping.eventName, function (ev: any) {\n                        const methodName = handlerMappings.events[key];\n                        try {\n                            const EventClass = (LeafletEvents as any)[mapping.argType];\n                            const payload = EventClass.fromLeaflet(ev).toDto();\n                            handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                        } catch (e) {\n                            console.error(`Error invoking ${mapping.eventName} handler:`, e);\n                        }\n                    });\n                }\n            }\n\n            // Attach interactive event handlers when interactive is enabled\n            if (options?.interactive) {\n                const interactiveEventMappings: { [key: string]: string } = {\n                    'mouseover': 'mouseover',\n                    'mouseout': 'mouseout',\n                    'mousemove': 'mousemove',\n                    'dblclick': 'dblclick',\n                    'contextmenu': 'contextmenu'\n                };\n\n                for (const [eventKey, leafletEvent] of Object.entries(interactiveEventMappings)) {\n                    if (keys.indexOf(eventKey) > -1) {\n                        vectorTileLayer.on(leafletEvent, function (e: any) {\n                            const methodName = handlerMappings.events[eventKey];\n                            try {\n                                const payload = {\n                                    latlng: e.latlng ? { lat: e.latlng.lat, lng: e.latlng.lng } : null,\n                                    layerPoint: e.layerPoint ? { x: e.layerPoint.x, y: e.layerPoint.y } : null,\n                                    containerPoint: e.containerPoint ? { x: e.containerPoint.x, y: e.containerPoint.y } : null,\n                                    feature: e.layer && e.layer.properties ? {\n                                        id: e.layer.properties.id ?? e.layer.properties.ID ?? e.layer.properties.fid ?? e.layer.properties.FID,\n                                        type: e.layer.feature?.type ?? 'Feature',\n                                        geometry: e.layer.feature?.geometry,\n                                        properties: e.layer.properties\n                                    } : null\n                                };\n                                handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                            } catch (err) {\n                                console.error(`Error invoking ${eventKey} handler:`, err);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        // Expose setInteractive method\n        (vectorTileLayer as any).setInteractive = function (interactive: boolean) {\n            // Update the interactive option\n            if (vectorTileLayer.options) {\n                vectorTileLayer.options.interactive = interactive;\n            }\n            \n            // VectorGrid stores interactivity at the layer level\n            // We need to update the actual layer's interactive state\n            if ((vectorTileLayer as any)._vectorTiles) {\n                // Iterate through all loaded tiles and update their interactive state\n                Object.values((vectorTileLayer as any)._vectorTiles).forEach((tile: any) => {\n                    if (tile && tile._features) {\n                        Object.values(tile._features).forEach((feature: any) => {\n                            if (feature) {\n                                feature.options.interactive = interactive;\n                            }\n                        });\n                    }\n                });\n            }\n            \n            // Redraw the layer to apply changes\n            if (vectorTileLayer.redraw) {\n                vectorTileLayer.redraw();\n            }\n        };\n\n        // Expose setEnableFeatureSelection method\n        (vectorTileLayer as any).setEnableFeatureSelection = function (enableFeatureSelection: boolean) {\n            // Update the enableFeatureSelection option\n            if (vectorTileLayer._pyroOptions) {\n                vectorTileLayer._pyroOptions.enableFeatureSelection = enableFeatureSelection;\n            }\n            \n            // If disabling selection, clear any current selections\n            if (!enableFeatureSelection && vectorTileLayer.clearSelection) {\n                vectorTileLayer.clearSelection();\n            }\n        };\n\n        // Expose setMultipleFeatureSelection method\n        (vectorTileLayer as any).setMultipleFeatureSelection = function (multipleFeatureSelection: boolean) {\n            // Update the multipleFeatureSelection option\n            if (vectorTileLayer._pyroOptions) {\n                vectorTileLayer._pyroOptions.multipleFeatureSelection = multipleFeatureSelection;\n            }\n        };\n\n        return vectorTileLayer;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const LayerGroup = {\n    createLayerGroup(\n        layers: L.Layer[] = [],\n        options?: L.LayerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.LayerGroup {\n        const layerGroup = L.layerGroup(layers, options);\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            // Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                layerGroup.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                layerGroup.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                layerGroup.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                layerGroup.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                layerGroup.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                layerGroup.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                layerGroup.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                layerGroup.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                layerGroup.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                layerGroup.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                layerGroup.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                layerGroup.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                layerGroup.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n        return layerGroup;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const FeatureGroup = {\n    createFeatureGroup(\n        layers: L.Layer[] = [],\n        options?: L.LayerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.FeatureGroup {\n        const featureGroup = L.featureGroup(layers, options);\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            // Layer Events specific to FeatureGroup\n            if (keys.indexOf('layeradd') > -1) {\n                featureGroup.on('layeradd', function (ev: L.LayerEvent) {\n                    var methodName = handlerMappings.events['layeradd'];\n                    try {\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking layeradd handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('layerremove') > -1) {\n                featureGroup.on('layerremove', function (ev: L.LayerEvent) {\n                    var methodName = handlerMappings.events['layerremove'];\n                    try {\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking layerremove handler:', e);\n                    }\n                });\n            }\n\n            // Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                featureGroup.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                featureGroup.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                featureGroup.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                featureGroup.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                featureGroup.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                featureGroup.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                featureGroup.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                featureGroup.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                featureGroup.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                featureGroup.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                featureGroup.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                featureGroup.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                featureGroup.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }// Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                featureGroup.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                featureGroup.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                featureGroup.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                featureGroup.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                featureGroup.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                featureGroup.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                featureGroup.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                featureGroup.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                featureGroup.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                featureGroup.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                featureGroup.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                featureGroup.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                featureGroup.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        return featureGroup;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const GeoJsonLayer = {\n    createGeoJsonLayer(\n        geoJsonData: any,\n        options?: any,\n        handlerMappings?: EventHandlerMapping\n    ): L.GeoJSON {\n        // Build Leaflet GeoJSON options\n        const leafletOptions: L.GeoJSONOptions = {\n            markersInheritOptions: options?.markersInheritOptions ?? false\n        };\n\n        // Map onEachFeature callback (no return value)\n        if (options?.interop && options.onEachFeatureEnabled) {\n            leafletOptions.onEachFeature = function (feature, layer) {\n                const layerInfo = LeafletEvents.minimalLayerInfo(layer);\n                options.interop.invokeMethodAsync('OnEachFeature', feature, layerInfo);\n            };\n        }\n\n        // Map pointToLayer callback (returns Layer/Marker)\n        if (options?.interop && options.pointToLayerEnabled) {\n            leafletOptions.pointToLayer = function (feature, latlng) {\n                // TODO: Make this properly async and await the result\n                // For now, return default marker and invoke callback\n                options.interop.invokeMethodAsync('PointToLayer', feature, latlng)\n                    .then((result: any) => {\n                        // Result contains marker options from C#\n                        // We could potentially update the marker here\n                        console.log('PointToLayer result:', result);\n                    });\n                return L.marker(latlng);\n            };\n        }\n\n        // Map style callback (returns PathOptions/Style)\n        if (options?.interop && options.styleEnabled) {\n            // Create a Map to store precomputed styles keyed by feature\n            const styleCache = new Map<any, any>();\n            \n            leafletOptions.style = function (feature) {\n                // Return precomputed style from cache if available\n                if (styleCache.has(feature)) {\n                    return styleCache.get(feature);\n                }\n                // Fallback to empty style if not in cache (shouldn't happen if precomputeStylesAsync ran)\n                return {};\n            };\n            \n            // Store the cache reference so precomputeStylesAsync can access it\n            (leafletOptions as any).styleCache = styleCache;\n        }\n\n        // Map filter callback (returns boolean)\n        // Note: Filter is handled in addData wrapper to support async callbacks\n        // Leaflet's filter must be synchronous, so we pre-filter the data before passing to Leaflet\n        // This is also more efficient as it avoids adding unwanted features to the layer\n\n        // Map coordsToLatLng callback (returns LatLng)\n        if (options?.interop && options.coordsToLatLngEnabled) {\n            leafletOptions.coordsToLatLng = function (coords) {\n                // Leaflet expects synchronous return\n                // Return default and invoke async callback\n                let latlng = L.latLng(coords[1], coords[0], coords[2]);\n                options.interop.invokeMethodAsync('CoordsToLatLng', coords)\n                    .then((result: any) => {\n                        if (result) {\n                            latlng = L.latLng(result.lat, result.lng, result.alt);\n                        }\n                    });\n                return latlng;\n            };\n        }\n\n        const geoJsonLayer = L.geoJSON(null, leafletOptions); // Always start with null data\n\n        // Default styles (DRY - single source of truth)\n        const DEFAULT_SELECTION_STYLE = {\n            color: '#3388ff',\n            weight: 3,\n            opacity: 1,\n            fillOpacity: 0.5,\n            fillColor: '#3388ff'\n        };\n\n        const DEFAULT_HOVER_STYLE = {\n            color: 'red',\n            weight: 2,\n            opacity: 1.0\n        };\n\n        // Store selection state\n        // For single selection mode\n        let selectedLayer: any = null;\n        let originalStyle: any = null;\n        \n        // For multiple selection mode\n        const selectedLayers: Map<any, any> = new Map(); // Map of layer -> original style\n\n        // Store hover state\n        const hoveredLayers: Map<any, any> = new Map(); // Map of layer -> original style (for hover)\n\n        // Helper function to create a lightweight version of a feature for C# callbacks\n        // This strips geometry coordinates from large features to avoid serialization issues\n        // while preserving properties and metadata needed for filtering/styling\n        function createCallbackFeature(feature: any, sizeThreshold: number = 50000, debug: boolean = false): any {\n            if (!feature) {\n                return feature;\n            }\n            \n            try {\n                const featureJson = JSON.stringify(feature);\n                \n                if (debug) {\n                    console.log(`Feature size: ${featureJson.length} characters`);\n                }\n                \n                // If feature is small enough, return as-is\n                if (featureJson.length <= sizeThreshold) {\n                    return feature;\n                }\n                \n                // Feature is large, create lightweight version\n                if (debug) {\n                    console.warn(`Feature is large (${featureJson.length} chars), creating lightweight version`);\n                }\n                \n                const lightweightFeature = {\n                    type: feature.type,\n                    id: feature.id,\n                    properties: feature.properties,\n                    geometry: feature.geometry ? {\n                        type: feature.geometry.type\n                        // Coordinates omitted to reduce size\n                    } : undefined\n                };\n                \n                if (debug) {\n                    const lightweightSize = JSON.stringify(lightweightFeature).length;\n                    console.log(`Lightweight feature size: ${lightweightSize} characters (reduced by ${featureJson.length - lightweightSize})`);\n                }\n                \n                return lightweightFeature;\n            } catch (error) {\n                console.error('Error creating callback feature:', error);\n                // On error, return original feature and let caller handle any issues\n                return feature;\n            }\n        }\n        \n        // Expose the helper function on the layer instance for future use\n        // This allows it to be called from outside (e.g., in setStyle, custom methods)\n        (geoJsonLayer as any).createCallbackFeature = createCallbackFeature;\n\n        // Wrap the addData method to handle async callbacks and filtering\n        const originalAddData = geoJsonLayer.addData.bind(geoJsonLayer);\n        (geoJsonLayer as any).addData = async function(data: any) {\n            let processedData = data;\n            \n            // Handle async filtering before adding data\n            if (options?.interop && options.filterEnabled) {\n                try {\n                    if (options.debugLogging) {\n                        console.log('Starting async filtering...');\n                    }\n                    processedData = await filterGeoJsonAsync(data, options.interop, options.debugLogging);\n                    if (options.debugLogging) {\n                        console.log('Filtering complete, processed data:', processedData);\n                    }\n                } catch (error) {\n                    console.error('Error during filtering:', error);\n                    throw error;\n                }\n            }\n            \n            // Handle async styling before adding data\n            if (options?.interop && options.styleEnabled) {\n                try {\n                    if (options.debugLogging) {\n                        console.log('Starting async styling...');\n                    }\n                    await precomputeStylesAsync(processedData, options.interop, options.debugLogging);\n                    if (options.debugLogging) {\n                        console.log('Styling complete');\n                    }\n                } catch (error) {\n                    console.error('Error during styling:', error);\n                    throw error;\n                }\n            }\n            \n            const promises: Promise<any>[] = [];\n            \n            // Wrap onEachFeature (only this one collects promises as it's void)\n            const originalOnEachFeature = (geoJsonLayer as any).options.onEachFeature;\n            if (originalOnEachFeature && options?.interop && options.onEachFeatureEnabled) {\n                (geoJsonLayer as any).options.onEachFeature = function(feature: any, layer: any) {\n                    const layerInfo = LeafletEvents.minimalLayerInfo(layer);\n                    const promise = options.interop.invokeMethodAsync('OnEachFeature', feature, layerInfo);\n                    promises.push(promise);\n                };\n            }\n            \n            // Call the original addData with potentially filtered data\n            if (options?.debugLogging) {\n                console.log('Calling Leaflet addData with:', processedData);\n            }\n            originalAddData(processedData);\n            \n            // Restore original onEachFeature\n            if (originalOnEachFeature) {\n                (geoJsonLayer as any).options.onEachFeature = originalOnEachFeature;\n            }\n            \n            // Wait for all onEachFeature callbacks to complete\n            if (promises.length > 0) {\n                await Promise.all(promises);\n            }\n            \n            return geoJsonLayer;\n        };\n        \n        // Helper function to filter GeoJSON asynchronously\n        async function filterGeoJsonAsync(data: any, interop: any, debug: boolean = false): Promise<any> {\n            try {\n                if (!data) {\n                    if (debug) {\n                        console.log('Filter: data is null or undefined, returning as-is');\n                    }\n                    return data;\n                }\n                \n                if (debug) {\n                    console.log('Filtering GeoJSON data, type:', data.type, 'data:', JSON.stringify(data).substring(0, 200));\n                }\n                \n                // Handle single Feature\n                if (data.type === 'Feature') {\n                    if (debug) {\n                        console.log('Filtering single feature:', data.id || 'no-id');\n                    }\n                    \n                    // Create lightweight version for callback if needed\n                    const featureToFilter = createCallbackFeature(data, 50000, debug);\n                    \n                    const shouldInclude = await interop.invokeMethodAsync('Filter', featureToFilter, null);\n                    if (debug) {\n                        console.log('Filter result for feature:', shouldInclude);\n                    }\n                    \n                    if (!shouldInclude) {\n                        // Return an empty FeatureCollection instead of null\n                        return { type: 'FeatureCollection', features: [] };\n                    }\n                    return data;\n                }\n                \n                // Handle FeatureCollection\n                if (data.type === 'FeatureCollection') {\n                    if (!data.features) {\n                        if (debug) {\n                            console.log('FeatureCollection has no features property, returning empty collection');\n                        }\n                        return { type: 'FeatureCollection', features: [] };\n                    }\n                    \n                    if (!Array.isArray(data.features)) {\n                        console.error('FeatureCollection.features is not an array:', typeof data.features);\n                        return { type: 'FeatureCollection', features: [] };\n                    }\n                    \n                    if (debug) {\n                        console.log(`Filtering FeatureCollection with ${data.features.length} features`);\n                    }\n                    \n                    if (data.features.length === 0) {\n                        if (debug) {\n                            console.log('FeatureCollection is empty, returning as-is');\n                        }\n                        return data;\n                    }\n                    \n                    // Call filter for each feature and collect results\n                    const filterResults: boolean[] = [];\n                    for (let idx = 0; idx < data.features.length; idx++) {\n                        const feature = data.features[idx];\n                        try {\n                            if (debug) {\n                                console.log(`Calling filter for feature ${idx}:`, feature?.id || feature?.properties?.id || 'no-id', 'type:', feature?.geometry?.type);\n                            }\n                            \n\n                            // Create lightweight version for callback if needed\n                            const featureToFilter = createCallbackFeature(feature, 50000, debug);\n                            \n\n                            const result = await interop.invokeMethodAsync('Filter', featureToFilter, null);\n                            if (debug) {\n                                console.log(`Filter result for feature ${idx}:`, result);\n                            }\n                            filterResults.push(result === true); // Ensure boolean\n                        } catch (error) {\n                            console.error(`Error filtering feature ${idx}:`, error);\n                            console.error(`Feature ${idx} type:`, feature?.geometry?.type);\n                            console.error(`Feature ${idx} id:`, feature?.id);\n                            // Try to show first part of the feature\n                            try {\n                                const featureStr = JSON.stringify(feature);\n                                console.error(`Feature ${idx} size:`, featureStr.length, 'chars');\n                                console.error(`Feature ${idx} preview:`, featureStr.substring(0, 500));\n                            } catch (e) {\n                                console.error('Could not stringify feature');\n                            }\n                            // Default to true (include) if filter fails - safer than excluding\n                            filterResults.push(true);\n                        }\n                    }\n                    \n                    if (debug) {\n                        console.log('All filter results:', filterResults);\n                    }\n                    \n                    const filteredFeatures = data.features.filter((_: any, index: number) => filterResults[index]);\n                    if (debug) {\n                        console.log(`Filtered from ${data.features.length} to ${filteredFeatures.length} features`);\n                    }\n                    \n                    return {\n                        ...data,\n                        features: filteredFeatures\n                    };\n                }\n                \n                // Handle GeometryCollection or other types - return as is\n                if (debug) {\n                    console.log('Unknown or unsupported GeoJSON type:', data.type, 'returning as-is');\n                }\n                return data;\n                \n            } catch (error) {\n                console.error('Exception in filterGeoJsonAsync:', error);\n                console.error('Data that caused error:', data);\n                throw error;\n            }\n        }\n        \n        // Helper function to precompute styles for all features asynchronously\n        async function precomputeStylesAsync(data: any, interop: any, debug: boolean = false): Promise<void> {\n            try {\n                if (!data) {\n                    return;\n                }\n                \n                const styleCache = (leafletOptions as any).styleCache;\n                if (!styleCache) {\n                    if (debug) {\n                        console.log('No style cache found, skipping style precomputation');\n                    }\n                    return;\n                }\n                \n                if (debug) {\n                    console.log('Precomputing styles for GeoJSON data, type:', data.type);\n                }\n                \n                // Handle single Feature\n                if (data.type === 'Feature') {\n                    if (debug) {\n                        console.log('Computing style for single feature:', data.id || 'no-id');\n                    }\n                    \n                    // Create lightweight version for callback if needed\n                    const featureToStyle = createCallbackFeature(data, 50000, debug);\n                    \n                    const style = await interop.invokeMethodAsync('Style', featureToStyle);\n                    styleCache.set(data, style || {});\n                    if (debug) {\n                        console.log('Style computed:', style);\n                    }\n                    return;\n                }\n                \n                // Handle FeatureCollection\n                if (data.type === 'FeatureCollection' && Array.isArray(data.features)) {\n                    if (debug) {\n                        console.log(`Computing styles for ${data.features.length} features`);\n                    }\n                    \n                    for (let idx = 0; idx < data.features.length; idx++) {\n                        const feature = data.features[idx];\n                        try {\n                            if (debug) {\n                                console.log(`Computing style for feature ${idx}:`, feature?.id || feature?.properties?.id || 'no-id');\n                            }\n                            \n                            // Create lightweight version for callback if needed\n                            const featureToStyle = createCallbackFeature(feature, 50000, debug);\n                            \n                            const style = await interop.invokeMethodAsync('Style', featureToStyle);\n                            styleCache.set(feature, style || {});\n                            \n                            if (debug) {\n                                console.log(`Style for feature ${idx}:`, style);\n                            }\n                        } catch (error) {\n                            console.error(`Error computing style for feature ${idx}:`, error);\n                            console.error(`Feature ${idx} type:`, feature?.geometry?.type);\n                            console.error(`Feature ${idx} id:`, feature?.id);\n                            // Try to show first part of the feature\n                            try {\n                                const featureStr = JSON.stringify(feature);\n                                console.error(`Feature ${idx} size:`, featureStr.length, 'chars');\n                                console.error(`Feature ${idx} preview:`, featureStr.substring(0, 500));\n                            } catch (e) {\n                                console.error('Could not stringify feature');\n                            }\n                            // Use default/empty style on error\n                            styleCache.set(feature, {});\n                        }\n                    }\n                    \n                    if (debug) {\n                        console.log(`Precomputed styles for ${styleCache.size} features`);\n                    }\n                }\n            } catch (error) {\n                console.error('Exception in precomputeStylesAsync:', error);\n                throw error;\n            }\n        }\n\n        // Attach event handlers if provided\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            // Layer Events specific to geoJsonLayer\n            if (keys.indexOf('layeradd') > -1) {\n                geoJsonLayer.on('layeradd', function (ev: L.LayerEvent) {\n                    var methodName = handlerMappings.events['layeradd'];\n                    try {\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking layeradd handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('layerremove') > -1) {\n                geoJsonLayer.on('layerremove', function (ev: L.LayerEvent) {\n                    var methodName = handlerMappings.events['layerremove'];\n                    try {\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking layerremove handler:', e);\n                    }\n                });\n            }\n\n            // Feature-specific click event\n            if (keys.indexOf('featureclicked') > -1) {\n                geoJsonLayer.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['featureclicked'];\n                    try {\n                        // Extract feature and layer info from the event\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\n                        const layer = ev.layer || ev.propagatedFrom;\n                        \n                        if (feature && layer) {\n                            // Create lightweight feature for callback if needed\n                            const featureToSend = (geoJsonLayer as any).createCallbackFeature(feature, 50000, false);\n                            \n\n                            const payload = {\n                                ...LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto(),\n                                layer: LeafletEvents.minimalLayerInfo(layer),\n                                feature: featureToSend\n                            };\n                            handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                        }\n                    } catch (e) {\n                        console.error('Error invoking featureclicked handler:', e);\n                    }\n                });\n            }\n\n            // Feature selection handling (enabled by default)\n            if (options?.enableFeatureSelection !== false) {\n                geoJsonLayer.on('click', function (ev: any) {\n                    try {\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\n                        const layer = ev.layer || ev.propagatedFrom;\n                        \n                        if (!feature || !layer) {\n                            return;\n                        }\n\n                        // Don't allow selection/unselection if the layer is currently being edited\n                        if ((layer as any)._editingEnabled) {\n                            return;\n                        }\n\n                        // Create lightweight feature for callback\n                        const featureToSend = (geoJsonLayer as any).createCallbackFeature(feature, 50000, false);\n                        \n                        const payload = {\n                            ...LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto(),\n                            layer: LeafletEvents.minimalLayerInfo(layer),\n                            feature: featureToSend\n                        };\n\n                        const multipleSelection = options?.multipleFeatureSelection === true;\n\n                        if (multipleSelection) {\n                            // Multiple selection mode\n                            if (selectedLayers.has(layer)) {\n                                // Unselect this feature\n                                const originalStyle = selectedLayers.get(layer);\n                                if (originalStyle && layer.setStyle) {\n                                    // Clear any hover state first\n                                    if (hoveredLayers.has(layer)) {\n                                        hoveredLayers.delete(layer);\n                                    }\n                                    layer.setStyle(originalStyle);\n                                }\n                                selectedLayers.delete(layer);\n                                \n                                // Notify C# of unselection\n                                if (handlerMappings?.events['featureunselected']) {\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(\n                                        handlerMappings.events['featureunselected'],\n                                        payload\n                                    );\n                                }\n                            } else {\n                                // Select this feature\n                                // Store original style (get from hover cache if currently hovering, otherwise from layer)\n                                let styleToStore;\n                                if (hoveredLayers.has(layer)) {\n                                    // Use the original style from before hover\n                                    styleToStore = hoveredLayers.get(layer);\n                                    hoveredLayers.delete(layer);\n                                } else if (layer.options) {\n                                    // Capture current style\n                                    styleToStore = {\n                                        color: layer.options.color,\n                                        weight: layer.options.weight,\n                                        opacity: layer.options.opacity,\n                                        fillColor: layer.options.fillColor,\n                                        fillOpacity: layer.options.fillOpacity,\n                                        dashArray: layer.options.dashArray\n                                    };\n                                }\n                                \n                                if (styleToStore) {\n                                    selectedLayers.set(layer, styleToStore);\n                                }\n                                \n                                // Bring layer to front so selection is clearly visible\n                                if (layer.bringToFront) {\n                                    layer.bringToFront();\n                                }\n                                \n                                // Apply selected style (use provided or default)\n                                if (layer.setStyle) {\n                                    const selectionStyle = options?.selectedFeatureStyle || DEFAULT_SELECTION_STYLE;\n                                    layer.setStyle(selectionStyle);\n                                }\n                                \n                                // Notify C# of selection\n                                if (handlerMappings?.events['featureselected']) {\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(\n                                        handlerMappings.events['featureselected'],\n                                        payload\n                                    );\n                                }\n                            }\n                        } else {\n                            // Single selection mode\n                            // Check if this is the currently selected layer\n                            if (selectedLayer === layer) {\n                                // Unselect\n                                if (originalStyle && layer.setStyle) {\n                                    // Clear any hover state first\n                                    if (hoveredLayers.has(layer)) {\n                                        hoveredLayers.delete(layer);\n                                    }\n                                    layer.setStyle(originalStyle);\n                                }\n                                selectedLayer = null;\n                                originalStyle = null;\n                                \n                                // Notify C# of unselection\n                                if (handlerMappings?.events['featureunselected']) {\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(\n                                        handlerMappings.events['featureunselected'],\n                                        payload\n                                    );\n                                }\n                            } else {\n                                // Unselect previous selection if any\n                                if (selectedLayer && originalStyle && selectedLayer.setStyle) {\n                                    selectedLayer.setStyle(originalStyle);\n                                }\n                                \n                                // Select new feature\n                                selectedLayer = layer;\n                                \n                                // Store original style (get from hover cache if currently hovering, otherwise from layer)\n                                if (hoveredLayers.has(layer)) {\n                                    // Use the original style from before hover\n                                    originalStyle = hoveredLayers.get(layer);\n                                    hoveredLayers.delete(layer);\n                                } else if (layer.options) {\n                                    // Capture current style\n                                    originalStyle = {\n                                        color: layer.options.color,\n                                        weight: layer.options.weight,\n                                        opacity: layer.options.opacity,\n                                        fillColor: layer.options.fillColor,\n                                        fillOpacity: layer.options.fillOpacity,\n                                        dashArray: layer.options.dashArray\n                                    };\n                                }\n                                \n                                // Bring layer to front so selection is clearly visible\n                                if (layer.bringToFront) {\n                                    layer.bringToFront();\n                                }\n                                \n                                // Apply selected style (use provided or default)\n                                if (layer.setStyle) {\n                                    const selectionStyle = options?.selectedFeatureStyle || DEFAULT_SELECTION_STYLE;\n                                    layer.setStyle(selectionStyle);\n                                }\n                                \n                                // Notify C# of selection\n                                if (handlerMappings?.events['featureselected']) {\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(\n                                        handlerMappings.events['featureselected'],\n                                        payload\n                                    );\n                                }\n                            }\n                        }\n                    } catch (e) {\n                        console.error('Error handling feature selection:', e);\n                    }\n                });\n            }\n\n            // Hover styling (controlled by enableHoverStyle flag)\n            // Default to true if not specified\n            if (options?.enableHoverStyle !== false) {\n                console.log('Hover enabled, enableHoverStyle value:', options?.enableHoverStyle);\n                // Use provided hoverStyle or default to red stroke\n                const hoverStyle = options?.hoverStyle || DEFAULT_HOVER_STYLE;\n                \n                geoJsonLayer.on('mouseover', function (ev: any) {\n                    try {\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\n                        const layer = ev.layer || ev.propagatedFrom;\n                        \n                        if (!feature || !layer || !layer.setStyle) {\n                            return;\n                        }\n\n                        // Bring layer to front so hover stroke is visible\n                        if (layer.bringToFront) {\n                            layer.bringToFront();\n                        }\n\n                        // Store original style if not already hovering\n                        if (!hoveredLayers.has(layer)) {\n                            if (layer.options) {\n                                const originalHoverStyle = {\n                                    color: layer.options.color,\n                                    weight: layer.options.weight,\n                                    opacity: layer.options.opacity,\n                                    fillColor: layer.options.fillColor,\n                                    fillOpacity: layer.options.fillOpacity,\n                                    dashArray: layer.options.dashArray\n                                };\n                                hoveredLayers.set(layer, originalHoverStyle);\n                            }\n                            \n                            // Apply hover style (merge with current style to only override specified properties)\n                            const currentStyle = {\n                                color: layer.options.color,\n                                weight: layer.options.weight,\n                                opacity: layer.options.opacity,\n                                fillColor: layer.options.fillColor,\n                                fillOpacity: layer.options.fillOpacity,\n                                dashArray: layer.options.dashArray\n                            };\n                            \n                            // Merge hover style properties with current style\n                            const mergedStyle = { ...currentStyle, ...hoverStyle };\n                            layer.setStyle(mergedStyle);\n                        }\n                    } catch (e) {\n                        console.error('Error applying hover style:', e);\n                    }\n                });\n\n                geoJsonLayer.on('mouseout', function (ev: any) {\n                    try {\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\n                        const layer = ev.layer || ev.propagatedFrom;\n                        \n                        if (!feature || !layer || !layer.setStyle) {\n                            return;\n                        }\n\n                        // Restore original style if we were hovering\n                        if (hoveredLayers.has(layer)) {\n                            const originalHoverStyle = hoveredLayers.get(layer);\n                            \n                            // Check if this layer is currently selected\n                            const multipleSelection = options?.multipleFeatureSelection === true;\n                            const isSelected = multipleSelection \n                                ? selectedLayers.has(layer) \n                                : selectedLayer === layer;\n                            \n                            if (isSelected) {\n                                // Don't restore original style - reapply selection style instead\n                                const selectionStyle = options?.selectedFeatureStyle || DEFAULT_SELECTION_STYLE;\n                                layer.setStyle(selectionStyle);\n                            } else if (originalHoverStyle) {\n                                // Not selected - restore original style\n                                layer.setStyle(originalHoverStyle);\n                            }\n                            \n                            hoveredLayers.delete(layer);\n                        }\n                    } catch (e) {\n                        console.error('Error restoring hover style:', e);\n                    }\n                });\n            }\n\n            // Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                geoJsonLayer.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                geoJsonLayer.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                geoJsonLayer.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                geoJsonLayer.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                geoJsonLayer.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                geoJsonLayer.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                geoJsonLayer.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                geoJsonLayer.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                geoJsonLayer.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                geoJsonLayer.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                geoJsonLayer.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                geoJsonLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                geoJsonLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        // Add clearSelection method\n        (geoJsonLayer as any).clearSelection = function() {\n            // Clear single selection\n            if (selectedLayer && originalStyle && selectedLayer.setStyle) {\n                selectedLayer.setStyle(originalStyle);\n            }\n            selectedLayer = null;\n            originalStyle = null;\n            \n            // Clear multiple selections\n            selectedLayers.forEach((originalStyle, layer) => {\n                if (originalStyle && layer.setStyle) {\n                    layer.setStyle(originalStyle);\n                }\n            });\n            selectedLayers.clear();\n\n            // Clear any hover states\n            hoveredLayers.forEach((originalStyle, layer) => {\n                if (originalStyle && layer.setStyle) {\n                    layer.setStyle(originalStyle);\n                }\n            });\n            hoveredLayers.clear();\n        };\n\n        // Expose selected features for editableGeoJsonLayer to access\n        Object.defineProperty(geoJsonLayer, 'SelectedFeatures', {\n            get: function() {\n                const multipleSelection = options?.multipleFeatureSelection === true;\n                if (multipleSelection) {\n                    // Return array of features from selectedLayers Map\n                    return Array.from(selectedLayers.keys()).map(layer => layer.feature).filter(f => f != null);\n                } else {\n                    // Return single selected feature or empty array\n                    return selectedLayer && selectedLayer.feature ? [selectedLayer.feature] : [];\n                }\n            }\n        });\n\n        // If initial data was provided, add it through our custom addData method\n        if (geoJsonData) {\n            // Use setTimeout to ensure this happens after the layer is returned and ready\n            setTimeout(() => {\n                (geoJsonLayer as any).addData(geoJsonData);\n            }, 0);\n        }\n\n        return geoJsonLayer;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { GeoJsonLayer } from './geoJsonLayer';\n\nexport const EditableGeoJsonLayer = {\n    createEditableGeoJsonLayer(\n        geoJsonData: any,\n        options?: any,\n        handlerMappings?: EventHandlerMapping\n    ): any {\n        // Create the base GeoJSON layer\n        const geoJsonLayer = GeoJsonLayer.createGeoJsonLayer(geoJsonData, options, handlerMappings) as any;\n\n        // Drawing state\n        let isEditing = false;\n        let drawingPoints: L.LatLng[] = [];\n        let drawingType: 'polygon' | 'polyline' | null = null;\n        let tempMarkers: L.CircleMarker[] = [];\n        let tempPolyline: L.Polyline | null = null;\n        let editableLayers: Map<any, any> = new Map();\n        \n        // Store original geometries for cancel operation\n        let originalGeometries: Map<any, any> = new Map();\n\n        // Default styles\n        const DEFAULT_DRAWING_STYLE = {\n            color: '#ff7800',\n            weight: 3,\n            opacity: 0.8,\n            fillOpacity: 0.3,\n            dashArray: '5, 5'\n        };\n\n        const DEFAULT_EDITING_STYLE = {\n            color: '#ff0000',\n            weight: 3,\n            opacity: 1.0,\n            fillOpacity: 0.4\n        };\n\n        const drawingStyle = options?.drawingStyle || DEFAULT_DRAWING_STYLE;\n        const editingStyle = options?.editingStyle || DEFAULT_EDITING_STYLE;\n        const enableSnapping = options?.enableSnapping !== false;\n        const snapDistance = options?.snapDistance || 15;\n        const showDrawingGuides = options?.showDrawingGuides !== false;\n        const allowDoubleClickFinish = options?.allowDoubleClickFinish !== false;\n        const minPolygonPoints = options?.minPolygonPoints || 3;\n        const minLinePoints = options?.minLinePoints || 2;\n\n        // Get the map from the layer\n        const getMap = (): L.Map | null => {\n            return (geoJsonLayer as any)._map || null;\n        };\n\n        // Helper to set cursor on map container\n        const setMapCursor = (cursor: string | null) => {\n            const map = getMap();\n            if (!map) return;\n            try {\n                const container = map.getContainer() as HTMLElement;\n                if (cursor === null || cursor === '') {\n                    // Reset to default cursor\n                    container.style.cursor = '';\n                } else {\n                    container.style.cursor = cursor;\n                }\n            } catch (e) {\n                console.error('Error setting cursor:', e);\n            }\n        };\n\n        // Helper to create data URL from SVG string\n        const svgToDataUrl = (svg: string) => {\n            return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);\n        };\n\n        // Get cursor SVGs from options\n        const addCursorSvg = options?.addCursor || '';\n        const removeCursorSvg = options?.removeCursor || '';\n        \n        const addCursorUrl = addCursorSvg ? svgToDataUrl(addCursorSvg) : null;\n        const removeCursorUrl = removeCursorSvg ? svgToDataUrl(removeCursorSvg) : null;\n        \n        // Helper to create vertex markers\n        const createVertexMarker = (latlng: L.LatLng): L.CircleMarker => {\n            const map = getMap();\n            if (!map) {\n                throw new Error('Layer is not added to a map');\n            }\n\n            const marker = L.circleMarker(latlng, {\n                radius: 6,\n                fillColor: '#ff7800',\n                color: '#fff',\n                weight: 2,\n                opacity: 1,\n                fillOpacity: 0.8\n            });\n            marker.addTo(map);\n            return marker;\n        };\n\n        // Helper to clear temporary drawing elements\n        const clearDrawingElements = () => {\n            tempMarkers.forEach(marker => {\n                const map = getMap();\n                if (map) {\n                    map.removeLayer(marker);\n                }\n            });\n            tempMarkers = [];\n\n            if (tempPolyline) {\n                const map = getMap();\n                if (map) {\n                    map.removeLayer(tempPolyline);\n                }\n                tempPolyline = null;\n            }\n        };\n\n        // Helper to update drawing polyline\n        const updateDrawingPolyline = () => {\n            const map = getMap();\n            if (!map) return;\n\n            if (tempPolyline) {\n                map.removeLayer(tempPolyline);\n            }\n\n            if (drawingPoints.length > 0) {\n                tempPolyline = L.polyline(drawingPoints, drawingStyle);\n                tempPolyline.addTo(map);\n            }\n        };\n\n        // Helper to find nearby vertex for snapping\n        const findSnapPoint = (latlng: L.LatLng, map: L.Map): L.LatLng | null => {\n            if (!enableSnapping) return null;\n\n            const point = map.latLngToContainerPoint(latlng);\n            let closestPoint: L.LatLng | null = null;\n            let closestDistance = snapDistance;\n\n            geoJsonLayer.eachLayer((layer: any) => {\n                if (layer.getLatLngs) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatLngs = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;\n\n                    flatLatLngs.forEach((ll: L.LatLng) => {\n                        const llPoint = map.latLngToContainerPoint(ll);\n                        const distance = point.distanceTo(llPoint);\n                        if (distance < closestDistance) {\n                            closestDistance = distance;\n                            closestPoint = ll;\n                        }\n                    });\n                }\n            });\n\n            drawingPoints.forEach(dp => {\n                const dpPoint = map.latLngToContainerPoint(dp);\n                const distance = point.distanceTo(dpPoint);\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestPoint = dp;\n                }\n            });\n\n            return closestPoint;\n        };\n\n        // Start editing mode\n        (geoJsonLayer as any).startEditing = function() {\n            isEditing = true;\n            const map = getMap();\n            if (!map) {\n                console.error('Cannot start editing: layer not added to map');\n                return;\n            }\n\n            map.doubleClickZoom.disable();\n            // Don't set cursor here - let the drawing/editing mode set it\n        };\n\n        // Stop editing mode\n        (geoJsonLayer as any).stopEditing = function() {\n            isEditing = false;\n            clearDrawingElements();\n            drawingPoints = [];\n            drawingType = null;\n            \n            const map = getMap();\n            if (map) {\n                map.doubleClickZoom.enable();\n            }\n\n            // Reset to default cursor when completely stopping editing\n            setMapCursor('default');\n        };\n\n        // Start drawing a polygon\n        (geoJsonLayer as any).addPolygon = function() {\n            if (!isEditing) {\n                console.error('Cannot start drawing: editing mode not enabled');\n                return;\n            }\n\n            clearDrawingElements();\n            drawingPoints = [];\n            drawingType = 'polygon';\n\n            const map = getMap();\n            if (!map) return;\n\n            // Set cursor to crosshair for drawing\n            setMapCursor('crosshair');\n\n            const onMapClick = (e: L.LeafletMouseEvent) => {\n                if (drawingType !== 'polygon') return;\n\n                let latlng = e.latlng;\n                const snapPoint = findSnapPoint(latlng, map);\n                if (snapPoint) {\n                    latlng = snapPoint;\n                }\n\n                drawingPoints.push(latlng);\n                const marker = createVertexMarker(latlng);\n                tempMarkers.push(marker);\n                updateDrawingPolyline();\n\n                // Show guide\n                if (showDrawingGuides && drawingPoints.length === 1) {\n                    console.log('Click to add points. Double-click or press Enter to finish.');\n                }\n            };\n\n            const onMapDblClick = (e: L.LeafletMouseEvent) => {\n                if (drawingType !== 'polygon') return;\n                if (allowDoubleClickFinish && drawingPoints.length >= minPolygonPoints) {\n                    e.originalEvent.preventDefault();\n                    (geoJsonLayer as any).confirmDrawing();\n                }\n            };\n\n            map.on('click', onMapClick);\n            map.on('dblclick', onMapDblClick);\n\n            // Store handlers for cleanup\n            (geoJsonLayer as any)._drawingHandlers = { onMapClick, onMapDblClick };\n        };\n\n        // Start drawing a line\n        (geoJsonLayer as any).addLine = function() {\n            if (!isEditing) {\n                console.error('Cannot start drawing: editing mode not enabled');\n                return;\n            }\n\n            clearDrawingElements();\n            drawingPoints = [];\n            drawingType = 'polyline';\n\n            const map = getMap();\n            if (!map) return;\n\n            // Set cursor to crosshair for drawing\n            setMapCursor('crosshair');\n\n            const onMapClick = (e: L.LeafletMouseEvent) => {\n                if (drawingType !== 'polyline') return;\n\n                let latlng = e.latlng;\n                const snapPoint = findSnapPoint(latlng, map);\n                if (snapPoint) {\n                    latlng = snapPoint;\n                }\n\n                drawingPoints.push(latlng);\n                const marker = createVertexMarker(latlng);\n                tempMarkers.push(marker);\n                updateDrawingPolyline();\n\n                if (showDrawingGuides && drawingPoints.length === 1) {\n                    console.log('Click to add points. Double-click or press Enter to finish.');\n                }\n            };\n\n            const onMapDblClick = (e: L.LeafletMouseEvent) => {\n                if (drawingType !== 'polyline') return;\n                if (allowDoubleClickFinish && drawingPoints.length >= minLinePoints) {\n                    e.originalEvent.preventDefault();\n                    (geoJsonLayer as any).confirmDrawing();\n                }\n            };\n\n            map.on('click', onMapClick);\n            map.on('dblclick', onMapDblClick);\n\n            (geoJsonLayer as any)._drawingHandlers = { onMapClick, onMapDblClick };\n        };\n\n        // Confirm drawing and add to layer\n        (geoJsonLayer as any).confirmDrawing = function() {\n            if (!drawingType || drawingPoints.length === 0) {\n                console.warn('No drawing to confirm');\n                return;\n            }\n\n            const minPoints = drawingType === 'polygon' ? minPolygonPoints : minLinePoints;\n            if (drawingPoints.length < minPoints) {\n                console.warn(`Need at least ${minPoints} points to complete a ${drawingType}`);\n                return;\n            }\n\n            const coordinates = drawingPoints.map(p => [p.lng, p.lat]);\n            if (drawingType === 'polygon') {\n                coordinates.push(coordinates[0]); // Close the polygon\n            }\n\n            const feature: any = {\n                type: 'Feature',\n                geometry: {\n                    type: drawingType === 'polygon' ? 'Polygon' : 'LineString',\n                    coordinates: drawingType === 'polygon' ? [coordinates] : coordinates\n                },\n                properties: {\n                    created: new Date().toISOString()\n                }\n            };\n\n            geoJsonLayer.addData(feature);\n\n            if (handlerMappings?.dotNetRef && handlerMappings.events['featurecreated']) {\n                handlerMappings.dotNetRef.invokeMethodAsync(\n                    handlerMappings.events['featurecreated'],\n                    { feature, layer: null }\n                );\n            }\n\n            const map = getMap();\n            if (map && (geoJsonLayer as any)._drawingHandlers) {\n                const handlers = (geoJsonLayer as any)._drawingHandlers;\n                map.off('click', handlers.onMapClick);\n                map.off('dblclick', handlers.onMapDblClick);\n                delete (geoJsonLayer as any)._drawingHandlers;\n            }\n\n            clearDrawingElements();\n            drawingPoints = [];\n            drawingType = null;\n\n            // Reset to default cursor after confirming drawing\n            setMapCursor('default');\n        };\n\n        // Cancel drawing\n        (geoJsonLayer as any).cancelDrawing = function() {\n            const map = getMap();\n            if (map && (geoJsonLayer as any)._drawingHandlers) {\n                const handlers = (geoJsonLayer as any)._drawingHandlers;\n                map.off('click', handlers.onMapClick);\n                map.off('dblclick', handlers.onMapDblClick);\n                delete (geoJsonLayer as any)._drawingHandlers;\n            }\n\n            clearDrawingElements();\n            drawingPoints = [];\n            drawingType = null;\n\n            // Reset to default cursor after cancelling\n            setMapCursor('default');\n\n            if (handlerMappings?.dotNetRef && handlerMappings.events['drawingcancelled']) {\n                handlerMappings.dotNetRef.invokeMethodAsync(\n                    handlerMappings.events['drawingcancelled']\n                );\n            }\n        };\n\n        // Edit selected features\n        (geoJsonLayer as any).editSelectedFeatures = function() {\n            const selectedFeatures = (geoJsonLayer as any).SelectedFeatures || [];\n            \n            if (selectedFeatures.length === 0) {\n                console.warn('No features selected for editing');\n                return;\n            }\n\n            const map = getMap();\n            if (!map) {\n                console.error('Cannot edit features: layer not added to map');\n                return;\n            }\n\n            originalGeometries.clear();\n\n            selectedFeatures.forEach((feature: any) => {\n                geoJsonLayer.eachLayer((layer: any) => {\n                    if (layer.feature === feature && (layer instanceof L.Polygon || layer instanceof L.Polyline)) {\n                        const isPolygon = layer instanceof L.Polygon;\n                        const currentLatLngs = layer.getLatLngs();\n                        const coords = isPolygon ? currentLatLngs[0] : currentLatLngs;\n                        \n                        const originalCoords = coords.map((latlng: L.LatLng) => ({ lat: latlng.lat, lng: latlng.lng }));\n                        originalGeometries.set(feature, { coords: originalCoords, isPolygon });\n                        \n                        // Initialize with move cursor\n                        (layer as any)._currentCursor = 'move';\n                        \n                        if (!layer.editing) {\n                            enableVertexEditing(layer, feature);\n                        } else {\n                            layer.editing.enable();\n                        }\n                        \n                        // Set cursor on the feature layer itself\n                        const featureElem = layer.getElement ? layer.getElement() : null;\n                        if (featureElem) {\n                            featureElem.style.cursor = 'move';\n                        }\n                        \n                        editableLayers.set(feature, layer);\n                    }\n                });\n            });\n            \n            // Set move cursor when entering edit mode (default edit cursor)\n            setMapCursor('move');\n        };\n\n        // Disable editing on features\n        (geoJsonLayer as any).disableEditingFeatures = function() {\n            editableLayers.forEach((layer: any, feature: any) => {\n                if (layer.editing && layer.editing.enabled()) {\n                    layer.editing.disable();\n                } else {\n                    disableVertexEditing(layer);\n                }\n            });\n            editableLayers.clear();\n        };\n\n        // Confirm editing\n        (geoJsonLayer as any).confirmEditing = function() {\n            editableLayers.forEach((layer: any, feature: any) => {\n                if (layer.editing && layer.editing.enabled()) {\n                    layer.editing.disable();\n                } else {\n                    disableVertexEditing(layer);\n                }\n                \n                const isPolygon = layer instanceof L.Polygon;\n                const currentLatLngs = layer.getLatLngs();\n                const coords = isPolygon ? currentLatLngs[0] : currentLatLngs;\n                \n                const newCoords = coords.map((ll: L.LatLng) => [ll.lng, ll.lat]);\n                if (isPolygon) {\n                    newCoords.push(newCoords[0]);\n                    feature.geometry.coordinates = [newCoords];\n                } else {\n                    feature.geometry.coordinates = newCoords;\n                }\n                \n                // Reset cursor on the feature layer\n                const featureElem = layer.getElement ? layer.getElement() : null;\n                if (featureElem) {\n                    featureElem.style.cursor = '';\n                }\n                \n                if (handlerMappings?.dotNetRef && handlerMappings.events['featuremodified']) {\n                    handlerMappings.dotNetRef.invokeMethodAsync(\n                        handlerMappings.events['featuremodified'],\n                        { feature, layer: null }\n                    );\n                }\n            });\n            \n            editableLayers.clear();\n            originalGeometries.clear();\n            \n            // Reset to default cursor after confirming edit\n            setMapCursor('default');\n        };\n\n        // Cancel editing\n        (geoJsonLayer as any).cancelEditing = function() {\n            editableLayers.forEach((layer: any, feature: any) => {\n                if (layer.editing && layer.editing.enabled()) {\n                    layer.editing.disable();\n                } else {\n                    disableVertexEditing(layer);\n                }\n                \n                const originalGeometry = originalGeometries.get(feature);\n                if (originalGeometry) {\n                    const { coords, isPolygon } = originalGeometry;\n                    const restoredLatLngs = coords.map((c: any) => L.latLng(c.lat, c.lng));\n                    \n                    if (isPolygon) {\n                        layer.setLatLngs([restoredLatLngs]);\n                    } else {\n                        layer.setLatLngs(restoredLatLngs);\n                    }\n                    \n                    const originalCoords = coords.map((c: any) => [c.lng, c.lat]);\n                    if (isPolygon) {\n                        originalCoords.push(originalCoords[0]);\n                        feature.geometry.coordinates = [originalCoords];\n                    } else {\n                        feature.geometry.coordinates = originalCoords;\n                    }\n                }\n                \n                // Reset cursor on the feature layer\n                const featureElem = layer.getElement ? layer.getElement() : null;\n                if (featureElem) {\n                    featureElem.style.cursor = '';\n                }\n            });\n            \n            editableLayers.clear();\n            originalGeometries.clear();\n            \n            // Reset to default cursor after cancelling edit\n            setMapCursor('default');\n        };\n\n        // Delete selected features\n        (geoJsonLayer as any).deleteSelectedFeatures = async function() {\n            const selectedFeatures = (geoJsonLayer as any).SelectedFeatures || [];\n            \n            if (selectedFeatures.length === 0) return;\n\n            const map = getMap();\n            if (!map) return;\n\n            // Raise the deleting event with cancellation support\n            if (handlerMappings?.dotNetRef && handlerMappings.events['featuredeleting']) {\n                try {\n                    const result = await handlerMappings.dotNetRef.invokeMethodAsync(\n                        handlerMappings.events['featuredeleting'],\n                        { \n                            features: selectedFeatures,\n                            cancel: false\n                        }\n                    );\n                    \n                    // Check if the operation was cancelled\n                    // Check both camelCase and PascalCase since C# might return PascalCase\n                    if (result && (result.cancel === true || result.Cancel === true)) {\n                        return;\n                    }\n                } catch (error) {\n                    console.error('Error calling featuredeleting event:', error);\n                    return;\n                }\n            }\n\n            (geoJsonLayer as any).disableEditingFeatures();\n\n            selectedFeatures.forEach((feature: any) => {\n                geoJsonLayer.eachLayer((layer: any) => {\n                    if (layer.feature === feature) {\n                        geoJsonLayer.removeLayer(layer);\n                        \n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featuredeleted']) {\n                            handlerMappings.dotNetRef.invokeMethodAsync(\n                                handlerMappings.events['featuredeleted'],\n                                { feature, layer: null }\n                            );\n                        }\n                    }\n                });\n            });\n\n            const selectedFeaturesArray = (geoJsonLayer as any).SelectedFeatures;\n            if (selectedFeaturesArray && Array.isArray(selectedFeaturesArray)) {\n                selectedFeaturesArray.splice(0, selectedFeaturesArray.length);\n            }\n            (geoJsonLayer as any).SelectedFeature = null;\n            \n            if (handlerMappings?.dotNetRef && handlerMappings.events['featureunselected']) {\n                handlerMappings.dotNetRef.invokeMethodAsync(\n                    handlerMappings.events['featureunselected'],\n                    { feature: null, layer: null }\n                );\n            }\n        };\n\n        // Manual vertex editing implementation\n        const enableVertexEditing = (layer: any, feature: any) => {\n            if ((layer as any)._editingEnabled) return;\n\n            const map = getMap();\n            if (!map) return;\n\n            const originalLatLngs = layer.getLatLngs();\n            const isPolygon = layer instanceof L.Polygon;\n            const coords = isPolygon ? originalLatLngs[0] : originalLatLngs;\n            const minVertices = isPolygon ? 3 : 2;\n            const vertexMarkers: L.CircleMarker[] = [];\n            \n            const updateVertexMarkers = () => {\n                vertexMarkers.forEach(marker => {\n                    const map = getMap();\n                    if (map) {\n                        map.removeLayer(marker);\n                    }\n                });\n                vertexMarkers.length = 0;\n                \n                coords.forEach((latlng: L.LatLng, index: number) => {\n                    const marker = createEditableVertexMarker(latlng, index);\n                    vertexMarkers.push(marker);\n                });\n                \n                (layer as any)._vertexMarkers = vertexMarkers;\n            };\n            \n            const createEditableVertexMarker = (latlng: L.LatLng, index: number) => {\n                const marker = L.circleMarker(latlng, {\n                    radius: 8,\n                    fillColor: '#ffffff',\n                    color: '#ff0000',\n                    weight: 2,\n                    opacity: 1,\n                    fillOpacity: 1,\n                    interactive: true,\n                    bubblingMouseEvents: false,\n                    pane: 'markerPane'\n                } as any);\n                \n                marker.addTo(map);\n                if (marker.bringToFront) marker.bringToFront();\n                \n                // Set cursor on the marker element after it's added to the map\n                const elem = marker.getElement();\n                if (elem) {\n                    elem.style.cursor = (layer as any)._currentCursor || 'move';\n                }\n\n                const deleteVertexHandler = (e: any) => {\n                    L.DomEvent.stopPropagation(e);\n                    L.DomEvent.preventDefault(e);\n                    \n                    if (coords.length <= minVertices) return;\n                    \n                    coords.splice(index, 1);\n                    \n                    if (isPolygon) {\n                        layer.setLatLngs([coords]);\n                    } else {\n                        layer.setLatLngs(coords);\n                    }\n                    \n                    updateVertexMarkers();\n                };\n                \n                (marker as any)._deleteHandler = deleteVertexHandler;\n                \n                marker.on('mousedown', (e: any) => {\n                    L.DomEvent.stopPropagation(e);\n                    \n                    if (map.dragging) map.dragging.disable();\n                    \n                    const onMouseMove = (e: L.LeafletMouseEvent) => {\n                        const newLatLng = e.latlng;\n                        marker.setLatLng(newLatLng);\n                        coords[index] = newLatLng;\n                        \n                        if (isPolygon) {\n                            layer.setLatLngs([coords]);\n                        } else {\n                            layer.setLatLngs(coords);\n                        }\n                    };\n                    \n                    const onMouseUp = () => {\n                        map.off('mousemove', onMouseMove);\n                        map.off('mouseup', onMouseUp);\n                        \n                        if (map.dragging) map.dragging.enable();\n                    };\n                    \n                    map.on('mousemove', onMouseMove);\n                    map.on('mouseup', onMouseUp);\n                });\n                \n                return marker;\n            };\n            \n            updateVertexMarkers();\n            \n            (layer as any)._vertexMarkers = vertexMarkers;\n            (layer as any)._editingEnabled = true;\n            (layer as any)._updateVertexMarkers = updateVertexMarkers;\n            (layer as any)._coords = coords;\n            (layer as any)._isPolygon = isPolygon;\n            (layer as any)._minVertices = minVertices;\n            \n            layer.setStyle(editingStyle);\n        };\n\n        const disableVertexEditing = (layer: any) => {\n            if (!(layer as any)._editingEnabled) return;\n            \n            const map = getMap();\n            \n            if (map && (layer as any)._vertexMarkers) {\n                (layer as any)._vertexMarkers.forEach((marker: L.CircleMarker) => {\n                    map.removeLayer(marker);\n                });\n            }\n            \n            if ((layer as any)._addVertexClickHandler) {\n                layer.off('click', (layer as any)._addVertexClickHandler);\n                delete (layer as any)._addVertexClickHandler;\n            }\n            \n            delete (layer as any)._vertexMarkers;\n            delete (layer as any)._editingEnabled;\n            delete (layer as any)._updateVertexMarkers;\n            delete (layer as any)._coords;\n            delete (layer as any)._isPolygon;\n            delete (layer as any)._minVertices;\n            \n            if ((layer as any).feature) {\n                const selectedFeatures = (geoJsonLayer as any).SelectedFeatures || [];\n                if (selectedFeatures.includes((layer as any).feature) && options?.selectedFeatureStyle) {\n                    layer.setStyle(options.selectedFeatureStyle);\n                } else {\n                    const style = options?.style || {};\n                    layer.setStyle(style);\n                }\n            }\n        };\n        \n        // Set add vertex mode\n        (geoJsonLayer as any).setAddVertexMode = function(enabled: boolean) {\n            let cursorStyle = 'move';\n            if (enabled) {\n                if (addCursorUrl) {\n                    cursorStyle = `url('${addCursorUrl}') 0 0, crosshair`;\n                    setMapCursor(cursorStyle);\n                } else {\n                    cursorStyle = 'crosshair';\n                    setMapCursor(cursorStyle);\n                }\n            } else {\n                cursorStyle = 'move';\n                setMapCursor(cursorStyle);\n            }\n            \n            editableLayers.forEach((layer: any) => {\n                if (!layer._editingEnabled) return;\n                \n                // Store current cursor on layer for vertex markers\n                layer._currentCursor = cursorStyle;\n                \n                // Set cursor on the feature layer itself\n                const featureElem = layer.getElement ? layer.getElement() : null;\n                if (featureElem) {\n                    featureElem.style.cursor = cursorStyle;\n                }\n                \n                // Update cursor on all existing vertex markers\n                if (layer._vertexMarkers) {\n                    layer._vertexMarkers.forEach((marker: any) => {\n                        const elem = marker.getElement();\n                        if (elem) {\n                            elem.style.cursor = cursorStyle;\n                        }\n                    });\n                }\n                \n                if (enabled) {\n                    const addVertexClickHandler = (e: L.LeafletMouseEvent) => {\n                        L.DomEvent.stopPropagation(e);\n                        \n                        const coords = layer._coords;\n                        const isPolygon = layer._isPolygon;\n                        \n                        if (!coords) return;\n                        \n                        const clickPoint = e.latlng;\n                        let minDist = Infinity;\n                        let insertIndex = 0;\n                        \n                        for (let i = 0; i < coords.length; i++) {\n                            const nextIndex = (i + 1) % coords.length;\n                            \n                            if (!isPolygon && nextIndex === 0) continue;\n                            \n                            const p1 = coords[i];\n                            const p2 = coords[nextIndex];\n                            \n                            const dist = getDistanceToSegment(clickPoint, p1, p2);\n                            \n                            if (dist < minDist) {\n                                minDist = dist;\n                                insertIndex = nextIndex;\n                            }\n                        }\n                        \n                        coords.splice(insertIndex, 0, clickPoint);\n                        \n                        if (isPolygon) {\n                            layer.setLatLngs([coords]);\n                        } else {\n                            layer.setLatLngs(coords);\n                        }\n                        \n                        if (layer._updateVertexMarkers) {\n                            layer._updateVertexMarkers();\n                        }\n                    };\n                    \n                    layer.on('click', addVertexClickHandler);\n                    layer._addVertexClickHandler = addVertexClickHandler;\n                } else {\n                    if (layer._addVertexClickHandler) {\n                        layer.off('click', layer._addVertexClickHandler);\n                        delete layer._addVertexClickHandler;\n                    }\n                }\n            });\n        };\n        \n        // Set remove vertex mode\n        (geoJsonLayer as any).setRemoveVertexMode = function(enabled: boolean) {\n            let cursorStyle = 'move';\n            if (enabled) {\n                if (removeCursorUrl) {\n                    cursorStyle = `url('${removeCursorUrl}') 0 0, crosshair`;\n                    setMapCursor(cursorStyle);\n                } else {\n                    cursorStyle = 'crosshair';\n                    setMapCursor(cursorStyle);\n                }\n            } else {\n                cursorStyle = 'move';\n                setMapCursor(cursorStyle);\n            }\n            \n            editableLayers.forEach((layer: any) => {\n                if (!layer._editingEnabled || !layer._vertexMarkers) return;\n                \n                // Store current cursor on layer for vertex markers\n                layer._currentCursor = cursorStyle;\n                \n                // Set cursor on the feature layer itself\n                const featureElem = layer.getElement ? layer.getElement() : null;\n                if (featureElem) {\n                    featureElem.style.cursor = cursorStyle;\n                }\n                \n                // Update cursor on all existing vertex markers\n                layer._vertexMarkers.forEach((marker: any) => {\n                    const elem = marker.getElement();\n                    if (elem) {\n                        elem.style.cursor = cursorStyle;\n                    }\n                    \n                    if (enabled) {\n                        if (marker._deleteHandler) {\n                            marker.on('click', marker._deleteHandler);\n                        }\n                    } else {\n                        if (marker._deleteHandler) {\n                            marker.off('click', marker._deleteHandler);\n                        }\n                    }\n                });\n            });\n        };\n        \n        // Set move vertex mode\n        (geoJsonLayer as any).setMoveVertexMode = function(enabled: boolean) {\n            if (enabled) {\n                (geoJsonLayer as any).setAddVertexMode(false);\n                (geoJsonLayer as any).setRemoveVertexMode(false);\n                \n                const cursorStyle = 'move';\n                setMapCursor(cursorStyle);\n                \n                // Update cursor on all vertex markers and feature layers\n                editableLayers.forEach((layer: any) => {\n                    if (!layer._editingEnabled) return;\n                    \n                    layer._currentCursor = cursorStyle;\n                    \n                    // Set cursor on the feature layer itself\n                    const featureElem = layer.getElement ? layer.getElement() : null;\n                    if (featureElem) {\n                        featureElem.style.cursor = cursorStyle;\n                    }\n                    \n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach((marker: any) => {\n                            const elem = marker.getElement();\n                            if (elem) {\n                                elem.style.cursor = cursorStyle;\n                            }\n                        });\n                    }\n                });\n            } else {\n                // When disabling move mode, don't change cursor - let next mode set it\n                // or confirm/cancel will set it to default\n            }\n        };\n        \n        // Helper function to calculate distance from point to line segment\n        function getDistanceToSegment(point: L.LatLng, p1: L.LatLng, p2: L.LatLng): number {\n            const map = getMap();\n            if (!map) return Infinity;\n            \n            const pt = map.latLngToContainerPoint(point);\n            const pt1 = map.latLngToContainerPoint(p1);\n            const pt2 = map.latLngToContainerPoint(p2);\n            \n            const x = pt.x, y = pt.y;\n            const x1 = pt1.x, y1 = pt1.y;\n            const x2 = pt2.x, y2 = pt2.y;\n            \n            const A = x - x1;\n            const B = y - y1;\n            const C = x2 - x1;\n            const D = y2 - y1;\n            \n            const dot = A * C + B * D;\n            const lenSq = C * C + D * D;\n            let param = -1;\n            \n            if (lenSq !== 0) {\n                param = dot / lenSq;\n            }\n            \n            let xx: number, yy: number;\n            \n            if (param < 0) {\n                xx = x1;\n                yy = y1;\n            } else if (param > 1) {\n                xx = x2;\n                yy = y2;\n            } else {\n                xx = x1 + param * C;\n                yy = y1 + param * D;\n            }\n            \n            const dx = x - xx;\n            const dy = y - yy;\n            \n            return Math.sqrt(dx * dx + dy * dy);\n        }\n        \n        return geoJsonLayer;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nexport const Polyline = {\n    addLatLng(polyline: L.Polyline, latlng: L.LatLng, latlngs?: L.LatLng[]): void {\n polyline.addLatLng(latlng, latlngs);\n    },\n    setLatLngs(polyline: L.Polyline, latlngs: L.LatLng[]): void {\n        polyline.setLatLngs(latlngs);\n    },\n    closestLayerPoint(polyline: L.Polyline, point: L.Point): L.Point {\n        return polyline.closestLayerPoint(point);\n }\n};\n","declare const L: typeof import('leaflet');\n\nexport const Polygon = {\n // placeholder for polygon helper methods\n};\n","declare const L: typeof import('leaflet');\n\nexport const Rectangle = {\n    setBounds(rectangle: L.Rectangle, bounds: L.LatLngBounds): void {\n        rectangle.setBounds(bounds);\n    }\n};\n","import { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\ndeclare const L: typeof import('leaflet');\n\nexport const Marker = {\n    createMarker(\n        latLng: L.LatLng,\n        options?: L.MarkerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.Marker {\n        const marker = L.marker(latLng, options);\n        // Attach event handlers if provided\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            if (keys.indexOf('move') > -1) {\n                marker.on('move', function (ev: any) {\n                    var methodName = handlerMappings.events['move'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for marker move event`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('dragstart') > -1) {\n                marker.on('dragstart', function (ev: any) {\n                    var methodName = handlerMappings.events['dragstart'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        //console.log('payload', payload);\n                        //console.log('json', JSON.stringify(payload));\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for marker dragstart event`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('movestart') > -1) {\n                marker.on('movestart', function (ev: any) {\n                    var methodName = handlerMappings.events['movestart'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for marker movestart event`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('drag') > -1) {\n                marker.on('drag', function (ev: any) {\n                    var methodName = handlerMappings.events['drag'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for marker drag event`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('dragend') > -1) {\n                marker.on('dragend', function (ev: L.DragEndEvent) {\n                    var methodName = handlerMappings.events['dragend'];\n                    try {\n                        let payload = LeafletEvents.LeafletDragEndEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for marker dragend event`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('moveend') > -1) {\n                marker.on('moveend', function (ev: any) {\n                    var methodName = handlerMappings.events['moveend'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for marker moveend event`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('click') > -1) {\n                marker.on('click', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['click'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event click`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                marker.on('dblclick', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['dblclick'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event dblclick`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                marker.on('mousedown', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mousedown'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mousedown`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                marker.on('mouseup', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mouseup'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mouseup`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                marker.on('mouseover', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mouseover'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mouseover`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                marker.on('mouseout', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mouseout'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mouseout`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                marker.on('contextmenu', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['contextmenu'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event contextmenu`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('add') > -1) {\n                marker.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events!['add'];\n                    try {\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event add`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                marker.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events!['remove'];\n                    try {\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event remove`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                marker.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events!['popupopen'];\n                    try {\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event popupopen`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                marker.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events!['popupclose'];\n                    try {\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event popupclose`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                marker.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events!['tooltipopen'];\n                    try {\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event tooltipopen`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                marker.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events!['tooltipclose'];\n                    try {\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event tooltipclose`, e);\n                    }\n                });\n            }\n        }\n\n        return marker;\n    }\n}\n","declare const L: typeof import('leaflet');\n\nexport const CircleMarker = {\n    setLatLng(marker: L.CircleMarker, latLng: L.LatLng): void {\n        marker.setLatLng(latLng);\n    },\n    setRadius(marker: L.CircleMarker, radius: number): void {\n        marker.setRadius(radius);\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const Popup = {\n    createPopup(\n        latLng: L.LatLng,\n        options?: L.PopupOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.Popup {\n        const popup = L.popup(latLng, options);\n\n        // Attach event handlers if provided\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            if (keys.indexOf('click') > -1) {\n                var methodName = handlerMappings.events['click'];\n                popup.on('click', function (ev: L.LeafletMouseEvent) {\n                    try {\n                        let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for popup click event`, e);\n                    }\n                });\n            }\n        }\n\n        return popup;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const Tooltip = {\n    createTooltip(\n        latLng: L.LatLng,\n        options?: L.TooltipOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.Tooltip {\n        const tooltip = L.tooltip(latLng, options);\n        // Attach event handlers if provided\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            if (keys.indexOf('contentupdate') > -1) {\n                tooltip.on('contentupdate', function (ev: any) {\n                    var methodName = handlerMappings.events!['contentupdate'];\n                    try {\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event contentupdate`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('click') > -1) {\n                tooltip.on('click', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['click'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event click`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                tooltip.on('dblclick', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['dblclick'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event dblclick`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                tooltip.on('mousedown', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mousedown'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mousedown`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                tooltip.on('mouseup', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mouseup'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mouseup`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                tooltip.on('mouseover', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mouseover'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mouseover`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                tooltip.on('mouseout', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['mouseout'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event mouseout`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                tooltip.on('contextmenu', function (ev: L.LeafletMouseEvent) {\n                    var methodName = handlerMappings.events!['contextmenu'];\n                    try {\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event contextmenu`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('add') > -1) {\n                tooltip.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events!['add'];\n                    try {\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event add`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                tooltip.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events!['remove'];\n                    try {\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event remove`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupopen') > -1) {\n                tooltip.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events!['popupopen'];\n                    try {\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event popupopen`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                tooltip.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events!['popupclose'];\n                    try {\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event popupclose`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                tooltip.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events!['tooltipopen'];\n                    try {\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event tooltipopen`, e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                tooltip.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events!['tooltipclose'];\n                    try {\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error(`Error invoking dotnet handler for event tooltipclose`, e);\n                    }\n                });\n            }\n        }\n\n        return tooltip;\n    }\n}\n","declare const L: typeof import('leaflet');\n\n/** Get an existing CRS instance by name, e.g., \"EPSG3857\", \"EPSG4326\", \"Simple\". */\nexport function getCrs(name: string): L.CRS {\n    const crs = L.CRS?.[name];\n    if (!crs) {\n        const keys = Object.keys(L.CRS || {});\n        throw new Error(\n            `Unknown CRS '${name}'. Available CRS keys: ${keys.join(\", \")}`\n        );\n    }\n    // Return the *existing* object; Blazor will receive an object reference.\n    return crs;\n}\n\n// The next parts are not currently used.\n// Overrides to build a custom CRS as a plain object (no `new`).\nexport interface CrsOverrides {\n    code?: string;\n    wrapLng?: [number, number];\n    wrapLat?: [number, number];\n    infinite?: boolean;\n    // Function overrides\n    scale?(zoom: number): number;\n    zoom?(scale: number): number;\n    project?(latlng: any): any;\n    unproject?(point: any): any;\n    // You can extend this with additional members if you need them.\n}\n\n// Minimal shape for a CRS-like object. We keep it permissive because CRS are plain objects.\nexport type CrsLike = {\n    scale(zoom: number): number;\n    zoom(scale: number): number;\n    latLngToPoint(latLng: any, zoom: number): any;\n    pointToLatLng(point: any, zoom: number): any;\n    // Optionally other members exist (project/unproject, transformation, etc.)\n};\n","declare const L: typeof import('leaflet');\n\nexport interface EditingControlOptions {\n    position?: 'topleft' | 'topright' | 'bottomleft' | 'bottomright';\n    dotNetRef?: any;\n    polygonIcon?: string;\n    lineIcon?: string;\n    editIcon?: string;\n    deleteIcon?: string;\n    confirmIcon?: string;\n    cancelIcon?: string;\n    addVertexIcon?: string;\n    removeVertexIcon?: string;\n    moveVertexIcon?: string;\n    polygonTooltip?: string;\n    lineTooltip?: string;\n    editTooltip?: string;\n    deleteTooltip?: string;\n    confirmTooltip?: string;\n    cancelTooltip?: string;\n    addVertexTooltip?: string;\n    removeVertexTooltip?: string;\n    moveVertexTooltip?: string;\n    buttonSize?: number;\n    iconSize?: number;\n}\n\nexport class EditingControl extends L.Control {\n    private container: HTMLDivElement | null = null;\n    private dotNetRef: any;\n    private isDrawing: boolean = false;\n    private isEditing: boolean = false;\n    private selectedCount: number = 0;\n    private isAddingVertices: boolean = false;\n    private isRemovingVertices: boolean = false;\n    private isMovingVertices: boolean = false;\n    private controlOptions: EditingControlOptions;\n\n    constructor(options?: EditingControlOptions) {\n        super(options);\n        this.dotNetRef = options?.dotNetRef;\n        this.controlOptions = options || {};\n    }\n\n    onAdd(map: L.Map): HTMLElement {\n        // Create the control container\n        this.container = L.DomUtil.create('div', 'leaflet-editing-control leaflet-bar');\n        \n        // Add inline styles to ensure visibility\n        this.container.style.cssText = `\n            background: white !important;\n            padding: 10px !important;\n            border-radius: 4px !important;\n            box-shadow: 0 1px 5px rgba(0,0,0,0.4) !important;\n            display: flex !important;\n            gap: 8px !important;\n            visibility: visible !important;\n            opacity: 1 !important;\n        `;\n        \n        // Prevent map interactions when clicking on the control\n        L.DomEvent.disableClickPropagation(this.container);\n        L.DomEvent.disableScrollPropagation(this.container);\n\n        // Initial render\n        this.render();\n\n        return this.container;\n    }\n\n    onRemove(map: L.Map): void {\n        // Cleanup if needed\n        if (this.container) {\n            L.DomEvent.off(this.container);\n        }\n    }\n\n    private render(): void {\n        if (!this.container) return;\n\n        // Clear existing content\n        this.container.innerHTML = '';\n\n        // Button visibility logic:\n        // - Normal mode: show polygon/line, hide others\n        // - Feature selected: show polygon/line/edit/delete, hide vertex buttons\n        // - Editing mode: show vertex buttons and confirm/cancel, hide others\n        // - Drawing mode: show only confirm/cancel\n        \n        const isInActiveSession = this.isDrawing || this.isEditing;\n        \n        // Basic drawing buttons (always show unless in active session)\n        this.addButton('btn-polygon', () => this.handlePolygonClick(), isInActiveSession);\n        this.addButton('btn-line', () => this.handleLineClick(), isInActiveSession);\n        \n        // Edit and delete buttons (show when feature selected, hide during sessions)\n        this.addButton('btn-edit', () => this.handleEditClick(), this.selectedCount === 0 || isInActiveSession);\n        this.addButton('btn-delete', () => this.handleDeleteClick(), this.selectedCount === 0 || isInActiveSession);\n        \n        // Vertex edit buttons (only show during editing session)\n        if (this.isEditing) {\n            this.addButton('btn-move-vertex', () => this.handleMoveVertexClick(), false, this.isMovingVertices);\n            this.addButton('btn-add-vertex', () => this.handleAddVertexClick(), false, this.isAddingVertices);\n            this.addButton('btn-remove-vertex', () => this.handleRemoveVertexClick(), false, this.isRemovingVertices);\n        }\n        \n        // Confirm and cancel (show during any active session)\n        this.addButton('btn-confirm', () => this.handleConfirmClick(), !isInActiveSession);\n        this.addButton('btn-cancel', () => this.handleCancelClick(), !isInActiveSession);\n    }\n\n    private addButton(id: string, onClick: () => void, disabled: boolean = false, isActive: boolean = false): void {\n        const button = L.DomUtil.create('button', 'leaflet-editing-button', this.container!);\n        button.id = id;\n        button.type = 'button';\n        button.disabled = disabled;\n        \n        const buttonSize = this.controlOptions.buttonSize || 40;\n        const iconSize = this.controlOptions.iconSize || 24;\n        \n        // Highlight button if it's active\n        const shouldHighlight = isActive;\n        \n        // Add inline styles to ensure visibility\n        button.style.cssText = `\n            background: ${shouldHighlight ? '#4CAF50' : 'white'};\n            border: 2px solid ${shouldHighlight ? '#4CAF50' : 'rgba(0,0,0,0.2)'};\n            border-radius: 4px;\n            padding: 8px;\n            font-size: 14px;\n            font-weight: 600;\n            cursor: pointer;\n            white-space: nowrap;\n            margin: 0 4px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            min-width: ${buttonSize}px;\n            min-height: ${buttonSize}px;\n            color: ${shouldHighlight ? 'white' : 'currentColor'};\n            box-shadow: ${shouldHighlight ? '0 2px 8px rgba(76, 175, 80, 0.4)' : 'none'};\n        `;\n        \n        if (disabled) {\n            button.style.opacity = '0.4';\n            button.style.cursor = 'not-allowed';\n        }\n\n        // Get SVG icon and tooltip from options (guaranteed to be present from C#)\n        let svgContent = '';\n        let ariaLabel = '';\n        \n        if (id === 'btn-polygon') {\n            ariaLabel = this.controlOptions.polygonTooltip || 'Draw new polygon';\n            svgContent = this.controlOptions.polygonIcon || '';\n        } else if (id === 'btn-line') {\n            ariaLabel = this.controlOptions.lineTooltip || 'Draw new line';\n            svgContent = this.controlOptions.lineIcon || '';\n        } else if (id === 'btn-edit') {\n            ariaLabel = this.controlOptions.editTooltip || 'Edit selected features';\n            svgContent = this.controlOptions.editIcon || '';\n        } else if (id === 'btn-delete') {\n            ariaLabel = this.controlOptions.deleteTooltip || 'Delete selected features';\n            svgContent = this.controlOptions.deleteIcon || '';\n        } else if (id === 'btn-confirm') {\n            ariaLabel = this.controlOptions.confirmTooltip || 'Confirm drawing';\n            svgContent = this.controlOptions.confirmIcon || '';\n        } else if (id === 'btn-cancel') {\n            ariaLabel = this.controlOptions.cancelTooltip || 'Cancel drawing';\n            svgContent = this.controlOptions.cancelIcon || '';\n        } else if (id === 'btn-add-vertex') {\n            ariaLabel = this.controlOptions.addVertexTooltip || 'Add vertex';\n            svgContent = this.controlOptions.addVertexIcon || '';\n        } else if (id === 'btn-remove-vertex') {\n            ariaLabel = this.controlOptions.removeVertexTooltip || 'Remove vertex';\n            svgContent = this.controlOptions.removeVertexIcon || '';\n        } else if (id === 'btn-move-vertex') {\n            ariaLabel = this.controlOptions.moveVertexTooltip || 'Move vertex';\n            svgContent = this.controlOptions.moveVertexIcon || '';\n        }\n\n        // Set button HTML with just the SVG (no text)\n        button.innerHTML = svgContent;\n        button.setAttribute('aria-label', ariaLabel);\n        button.setAttribute('title', ariaLabel);\n\n        // Use Leaflet's event system\n        L.DomEvent.on(button, 'click', (e: Event) => {\n            L.DomEvent.stopPropagation(e);\n            L.DomEvent.preventDefault(e);\n            onClick();\n        });\n    }\n\n    private async handlePolygonClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlPolygonClick');\n            } catch (error) {\n                console.error('Error calling OnControlPolygonClick:', error);\n            }\n        }\n    }\n\n    private async handleLineClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlLineClick');\n            } catch (error) {\n                console.error('Error calling OnControlLineClick:', error);\n            }\n        }\n    }\n\n    private async handleEditClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlEditClick');\n            } catch (error) {\n                console.error('Error calling OnControlEditClick:', error);\n            }\n        }\n    }\n\n    private async handleConfirmClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlConfirmClick');\n            } catch (error) {\n                console.error('Error calling OnControlConfirmClick:', error);\n            }\n        }\n    }\n\n    private async handleCancelClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlCancelClick');\n            } catch (error) {\n                console.error('Error calling OnControlCancelClick:', error);\n            }\n        }\n    }\n\n    private async handleDeleteClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlDeleteClick');\n            } catch (error) {\n                console.error('Error calling OnControlDeleteClick:', error);\n            }\n        }\n    }\n\n    private async handleAddVertexClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlAddVertexClick');\n            } catch (error) {\n                console.error('Error calling OnControlAddVertexClick:', error);\n            }\n        }\n    }\n\n    private async handleRemoveVertexClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlRemoveVertexClick');\n            } catch (error) {\n                console.error('Error calling OnControlRemoveVertexClick:', error);\n            }\n        }\n    }\n\n    private async handleMoveVertexClick(): Promise<void> {\n        if (this.dotNetRef) {\n            try {\n                await this.dotNetRef.invokeMethodAsync('OnControlMoveVertexClick');\n            } catch (error) {\n                console.error('Error calling OnControlMoveVertexClick:', error);\n            }\n        }\n    }\n\n    // Public methods to update state from C#\n    public setDrawing(isDrawing: boolean): void {\n        this.isDrawing = isDrawing;\n        this.render();\n    }\n\n    public setSelectedCount(count: number): void {\n        this.selectedCount = count;\n        this.render();\n    }\n\n    public setEditing(isEditing: boolean): void {\n        this.isEditing = isEditing;\n        this.render();\n    }\n\n    public setAddingVertices(isAdding: boolean): void {\n        this.isAddingVertices = isAdding;\n        this.render();\n    }\n\n    public setRemovingVertices(isRemoving: boolean): void {\n        this.isRemovingVertices = isRemoving;\n        this.render();\n    }\n\n    public setMovingVertices(isMoving: boolean): void {\n        this.isMovingVertices = isMoving;\n        this.render();\n    }\n}\n\n// Export for use in interop\nexport const LeafletEditingControl = {\n    create(mapElementId: string, options: EditingControlOptions): EditingControl {\n        const control = new EditingControl(options);\n        return control;\n    },\n\n    remove(control: EditingControl): void {\n        control.remove();\n    },\n\n    setDrawing(control: EditingControl, isDrawing: boolean): void {\n        control.setDrawing(isDrawing);\n    },\n\n    setSelectedCount(control: EditingControl, count: number): void {\n        control.setSelectedCount(count);\n    },\n\n    setEditing(control: EditingControl, isEditing: boolean): void {\n        control.setEditing(isEditing);\n    },\n\n    setAddingVertices(control: EditingControl, isAdding: boolean): void {\n        control.setAddingVertices(isAdding);\n    },\n\n    setRemovingVertices(control: EditingControl, isRemoving: boolean): void {\n        control.setRemovingVertices(isRemoving);\n    },\n\n    setMovingVertices(control: EditingControl, isMoving: boolean): void {\n        control.setMovingVertices(isMoving);\n    }\n};\n\n// Make it available globally\n(window as any).LeafletEditingControl = LeafletEditingControl;\n","import { Map } from './map';\nimport { Layer } from './layer';\nimport { GridLayer } from './gridLayer';\nimport { TileLayer } from './tileLayer';\nimport { WmsTileLayer } from './wmsTileLayer';\nimport { ProtobufVectorTileLayer } from './protobufVectorTileLayer';\nimport { SlicerVectorTileLayer } from './slicerVectorTileLayer';\nimport { LayerGroup } from './layerGroup';\nimport { FeatureGroup } from './featureGroup';\nimport { GeoJsonLayer } from './geoJsonLayer';\nimport { EditableGeoJsonLayer } from './editableGeoJsonLayer';\nimport { Polyline } from './polyline';\nimport { Polygon } from './polygon';\nimport { Rectangle } from './rectangle';\nimport { Marker } from './marker';\nimport { CircleMarker } from './circleMarker';\nimport { Popup } from './popup';\nimport { Tooltip } from './tooltip';\nimport { getCrs } from './crs';\nimport { LeafletEditingControl } from './editingControl';\n\nexport const LeafletMap = {\n    Map, Layer, GridLayer, TileLayer, WmsTileLayer, ProtobufVectorTileLayer, SlicerVectorTileLayer, LayerGroup, FeatureGroup, GeoJsonLayer, EditableGeoJsonLayer, Polyline, Polygon, Rectangle, Marker, CircleMarker, Popup, Tooltip, getCrs, LeafletEditingControl\n};\n\n// For consumers that expect a default export or a global on window\nexport default LeafletMap;\n\n// Attach to window for direct script usage in non-module contexts\nif (typeof window !== 'undefined') {\n    (window as any).LeafletMap = LeafletMap;\n}\n"],"names":["LeafletEvents","minimalLayerInfo","obj","info","LeafletEventArgs","init","ev","dto","LeafletMouseEventArgs","base","LeafletResizeEventArgs","LeafletPopupEventArgs","LeafletDragEndEventArgs","LeafletErrorEventArgs","_a","msg","code","LeafletGeoJsonEventArgs","_b","_c","_d","_e","_f","_g","LeafletKeyboardEventArgs","LeafletLayerEventArgs","LeafletLayersControlEventArgs","LeafletLocationEventArgs","boundsDto","ne","sw","LeafletTileErrorEventArgs","LeafletTileEventArgs","LeafletTooltipEventArgs","LeafletZoomAnimEventArgs","center","zoom","noUpdate","LeafletFeatureMouseEventArgs","layerName","feature","LeafletTileFetchErrorEventArgs","Map","elementId","options","handlerMappings","map","keys","methodName","payload","mapWrapper","bounds","Layer","layer","e","GridLayer","gridLayer","TileLayer","urlTemplate","tileLayer","WmsTileLayer","baseUrl","wmsTileLayer","VectorTileHelpers","rendererType","type","LCanvas","LSVG","vectorTileLayer","DEFAULT_SELECTION_STYLE","DEFAULT_HOVER_STYLE","selectedFeatures","selectedLayers","hoveredLayers","layersByFeatureId","selectedFeatureStyle","applySelectedStyle","leafletStyle","resetStyle","getFeatureIdentifier","properties","featureId","layers","selectAllSegments","unselectAllSegments","currentOptions","hoverStyle","mergedStyle","_","id","originalStyle","eventMappings","key","mapping","interactiveEventMappings","eventKey","leafletEvent","err","interactive","tile","enableFeatureSelection","multipleFeatureSelection","ProtobufVectorTileLayer","vectorTileLayerStyles","enhancedStyles","style","firstStyle","layerKeys","simpleName","vectorGridOptions","rendererFactory","getRendererFactory","SlicerVectorTileLayer","geoJsonData","trackLayer","LayerGroup","layerGroup","FeatureGroup","featureGroup","GeoJsonLayer","leafletOptions","layerInfo","latlng","result","styleCache","coords","geoJsonLayer","selectedLayer","createCallbackFeature","sizeThreshold","debug","featureJson","lightweightFeature","lightweightSize","error","originalAddData","data","processedData","filterGeoJsonAsync","precomputeStylesAsync","promises","originalOnEachFeature","promise","interop","featureToFilter","shouldInclude","filterResults","idx","featureStr","filteredFeatures","index","featureToStyle","featureToSend","styleToStore","selectionStyle","originalHoverStyle","f","EditableGeoJsonLayer","isEditing","drawingPoints","drawingType","tempMarkers","tempPolyline","editableLayers","originalGeometries","DEFAULT_DRAWING_STYLE","DEFAULT_EDITING_STYLE","drawingStyle","editingStyle","enableSnapping","snapDistance","showDrawingGuides","allowDoubleClickFinish","minPolygonPoints","minLinePoints","getMap","setMapCursor","cursor","container","svgToDataUrl","svg","addCursorSvg","removeCursorSvg","addCursorUrl","removeCursorUrl","createVertexMarker","marker","clearDrawingElements","updateDrawingPolyline","findSnapPoint","point","closestPoint","closestDistance","latlngs","ll","llPoint","distance","dp","dpPoint","onMapClick","snapPoint","onMapDblClick","minPoints","coordinates","p","handlers","isPolygon","currentLatLngs","originalCoords","enableVertexEditing","featureElem","disableVertexEditing","newCoords","originalGeometry","restoredLatLngs","c","selectedFeaturesArray","originalLatLngs","minVertices","vertexMarkers","updateVertexMarkers","createEditableVertexMarker","elem","deleteVertexHandler","onMouseMove","newLatLng","onMouseUp","enabled","cursorStyle","addVertexClickHandler","clickPoint","minDist","insertIndex","i","nextIndex","p1","p2","dist","getDistanceToSegment","pt","pt1","pt2","x","y","x1","y1","x2","y2","A","B","C","D","dot","lenSq","param","xx","yy","dx","dy","Polyline","polyline","Polygon","Rectangle","rectangle","Marker","latLng","CircleMarker","radius","Popup","popup","Tooltip","tooltip","getCrs","name","crs","EditingControl","isInActiveSession","onClick","disabled","isActive","button","buttonSize","shouldHighlight","svgContent","ariaLabel","isDrawing","count","isAdding","isRemoving","isMoving","LeafletEditingControl","mapElementId","control","LeafletMap"],"mappings":"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"}