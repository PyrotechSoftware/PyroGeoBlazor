@namespace PyroGeoBlazor.DeckGL.Components
@using PyroGeoBlazor.DeckGL.Models
@using System.Text.Json

@if (SelectedFeature != null)
{
    <div style="padding: 8px;">
        <MudText Typo="Typo.subtitle2" Class="mb-2">
            <strong>Feature Attributes</strong>
        </MudText>
        
        @if (GetFeatureProperties().Any())
        {
            <MudSimpleTable Dense="true" Hover="true" Style="font-size: 0.875rem;">
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Value</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var prop in GetFeatureProperties())
                    {
                        <tr>
                            <td style="font-weight: 500;">@prop.Key</td>
                            <td>@prop.Value</td>
                        </tr>
                    }
                </tbody>
            </MudSimpleTable>
        }
        else
        {
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="pa-2">
                No properties available
            </MudText>
        }
    </div>
}
else
{
    <div style="padding: 8px;">
        <MudText Typo="Typo.body2" Color="Color.Secondary">
            Click a feature to view its attributes
        </MudText>
    </div>
}

@code {
    /// <summary>
    /// The selected feature to display attributes for
    /// </summary>
    [Parameter]
    public SelectedFeature? SelectedFeature { get; set; }

    /// <summary>
    /// Optional list of property names to exclude from the display
    /// </summary>
    [Parameter]
    public string[]? ExcludedProperties { get; set; }

    private List<KeyValuePair<string, string>> GetFeatureProperties()
    {
        if (SelectedFeature == null)
            return [];

        var properties = new List<KeyValuePair<string, string>>();
        var feature = SelectedFeature.Feature;
        var excludedProps = new HashSet<string>(ExcludedProperties ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);

        try
        {
            // Try to get properties from the standard GeoJSON properties object
            if (feature.TryGetProperty("properties", out var propertiesElement))
            {
                foreach (var property in propertiesElement.EnumerateObject())
                {
                    if (!excludedProps.Contains(property.Name))
                    {
                        properties.Add(new KeyValuePair<string, string>(
                            property.Name,
                            FormatPropertyValue(property.Value)
                        ));
                    }
                }
            }

            // Also check for properties at the root level (in case they're not in a properties object)
            foreach (var property in feature.EnumerateObject())
            {
                // Skip well-known GeoJSON structure properties
                if (property.Name == "type" || 
                    property.Name == "geometry" || 
                    property.Name == "properties" || 
                    property.Name == "id")
                {
                    continue;
                }

                // Skip if already added or excluded
                if (properties.Any(p => p.Key.Equals(property.Name, StringComparison.OrdinalIgnoreCase)) ||
                    excludedProps.Contains(property.Name))
                {
                    continue;
                }

                properties.Add(new KeyValuePair<string, string>(
                    property.Name,
                    FormatPropertyValue(property.Value)
                ));
            }

            // Add feature ID if available
            if (feature.TryGetProperty("id", out var idElement))
            {
                properties.Insert(0, new KeyValuePair<string, string>("id", FormatPropertyValue(idElement)));
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error extracting feature properties: {ex.Message}");
        }

        return properties;
    }

    private string FormatPropertyValue(JsonElement value)
    {
        try
        {
            return value.ValueKind switch
            {
                JsonValueKind.String => value.GetString() ?? string.Empty,
                JsonValueKind.Number => value.GetRawText(),
                JsonValueKind.True => "true",
                JsonValueKind.False => "false",
                JsonValueKind.Null => "null",
                JsonValueKind.Array => $"[{value.GetArrayLength()} items]",
                JsonValueKind.Object => "[object]",
                _ => value.GetRawText()
            };
        }
        catch
        {
            return value.GetRawText();
        }
    }
}
