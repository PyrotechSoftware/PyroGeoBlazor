{"version":3,"file":"leafletMap.js","sources":["../Scripts/events.ts","../Scripts/map.ts","../Scripts/layer.ts","../Scripts/gridLayer.ts","../Scripts/tileLayer.ts","../Scripts/wmsTileLayer.ts","../Scripts/protobufVectorTileLayer.ts","../Scripts/slicerVectorTileLayer.ts","../Scripts/layerGroup.ts","../Scripts/featureGroup.ts","../Scripts/geoJsonLayer.ts","../Scripts/editableGeoJsonLayer.ts","../Scripts/polyline.ts","../Scripts/polygon.ts","../Scripts/rectangle.ts","../Scripts/marker.ts","../Scripts/circleMarker.ts","../Scripts/popup.ts","../Scripts/tooltip.ts","../Scripts/crs.ts","../Scripts/editingControl.ts","../Scripts/index.ts"],"sourcesContent":["declare const L: typeof import('leaflet');\r\ndeclare const Mvt: typeof import('leaflet-vectortile-mapbox');\r\n\r\nexport namespace LeafletEvents {\r\n    // DTO shapes sent to .NET using Leaflet classes directly, matching C# EventArgs properties\r\n    export interface LeafletEventArgsDto {\r\n        Type?: string | null;\r\n        Target?: any | null;\r\n        SourceTarget?: any | null;\r\n        PropagatedFrom?: any | null;\r\n    }\r\n\r\n    // Matches C# LeafletMouseEventArgs: LatLng, LayerPoint, ContainerPoint, OriginalEvent\r\n    export interface LeafletMouseEventArgsDto extends LeafletEventArgsDto {\r\n        LatLng?: L.LatLng | null;\r\n        LayerPoint?: L.Point | null;\r\n        ContainerPoint?: L.Point | null;\r\n        OriginalEvent?: any | null;\r\n    }\r\n\r\n    // Matches C# LeafletResizeEventArgs: OldSize, NewSize\r\n    export interface LeafletResizeEventArgsDto extends LeafletEventArgsDto {\r\n        OldSize?: L.Point | null;\r\n        NewSize?: L.Point | null;\r\n    }\r\n\r\n    // Matches C# LeafletPopupEventArgs: Popup\r\n    export interface LeafletPopupEventArgsDto extends LeafletEventArgsDto {\r\n        Popup?: L.Popup | null;\r\n    }\r\n\r\n    // Matches C# LeafletDragEndEventArgs: Distance\r\n    export interface LeafletDragEndEventArgsDto extends LeafletEventArgsDto {\r\n        Distance?: number | null;\r\n    }\r\n\r\n    // Matches C# LeafletErrorEventArgs: Message, Code\r\n    export interface LeafletErrorEventArgsDto extends LeafletEventArgsDto {\r\n        Message?: string | null;\r\n        Code?: number | null;\r\n    }\r\n\r\n    // Matches C# LeafletGeoJsonEventArgs: Layer, Properties, GeometryType, Id\r\n    export interface LeafletGeoJsonEventArgsDto extends LeafletEventArgsDto {\r\n        Layer?: L.Layer | null;\r\n        Properties?: any | null;\r\n        GeometryType?: string | null;\r\n        Id?: string | null;\r\n    }\r\n\r\n    // Matches C# LeafletKeyboardEventArgs: OriginalEvent\r\n    export interface LeafletKeyboardEventArgsDto extends LeafletEventArgsDto {\r\n        OriginalEvent?: any | null;\r\n    }\r\n\r\n    // Matches C# LeafletLayerEventArgs: Layer\r\n    export interface LeafletLayerEventArgsDto extends LeafletEventArgsDto {\r\n        Layer?: L.Layer | null;\r\n    }\r\n\r\n    // Matches C# LeafletLayersControlEventArgs: Layer, Name\r\n    export interface LeafletLayersControlEventArgsDto extends LeafletEventArgsDto {\r\n        Layer?: L.Layer | null;\r\n        Name?: string | null;\r\n    }\r\n\r\n    export interface LatLngBoundsDto {\r\n        NorthEast: L.LatLng;\r\n        SouthWest: L.LatLng;\r\n    }\r\n\r\n    // Matches C# LeafletLocationEventArgs: use plain serializable shapes to avoid circular refs\r\n    export interface LeafletLocationEventArgsDto extends LeafletEventArgsDto {\r\n        LatLng?: L.LatLng | null;\r\n        Bounds?: LatLngBoundsDto | null;\r\n        Accuracy?: number | null;\r\n        Altitude?: number | null;\r\n        AltitudeAccuracy?: number | null;\r\n        Heading?: number | null;\r\n        Speed?: number | null;\r\n        Timestamp?: number | null;\r\n    }\r\n\r\n    // Matches C# LeafletTileErrorEventArgs: Tile, Coords, Error\r\n    export interface LeafletTileErrorEventArgsDto extends LeafletEventArgsDto {\r\n        Tile?: any | null;\r\n        Coords?: L.Point | null;\r\n        Error?: any | null;\r\n    }\r\n\r\n    // Matches C# LeafletTileEventArgs: Tile, Coords\r\n    export interface LeafletTileEventArgsDto extends LeafletEventArgsDto {\r\n        Tile?: any | null;\r\n        Coords?: L.Point | null;\r\n    }\r\n\r\n    // Matches C# LeafletTooltipEventArgs: Tooltip\r\n    export interface LeafletTooltipEventArgsDto extends LeafletEventArgsDto {\r\n        Tooltip?: L.Tooltip | null;\r\n    }\r\n\r\n    // Matches C# LeafletZoomAnimEventArgs: Center, Zoom, NoUpdate\r\n    export interface LeafletZoomAnimEventArgsDto extends LeafletEventArgsDto {\r\n        Center?: L.LatLng | null;\r\n        Zoom?: number | null;\r\n        NoUpdate?: boolean | null;\r\n    }\r\n\r\n    // Matches C# LeafletFeatureMouseEventArgs\r\n    export interface LeafletFeatureMouseEventArgsDto extends LeafletMouseEventArgsDto {\r\n        LayerName?: string | null;\r\n        Feature?: any | null;\r\n    }\r\n\r\n    // Matches C# LeafletTileFetchErrorEventArgs\r\n    export interface LeafletTileFetchErrorEventArgsDto extends LeafletTileErrorEventArgsDto {\r\n        Url?: string | null;\r\n        z?: number | null;\r\n        x?: number | null;\r\n        y?: number | null;\r\n    }\r\n\r\n    export function minimalLayerInfo(obj: any): any {\r\n        if (!obj) return null;\r\n        const info: any = {};\r\n        if ('_leaflet_id' in obj) info.LeafletId = obj._leaflet_id;\r\n        if (obj && obj.constructor && obj.constructor.name) info.Type = obj.constructor.name;\r\n        return info;\r\n    }\r\n\r\n    export class LeafletEventArgs {\r\n        Type?: string | null;\r\n        Target?: any | null;\r\n        SourceTarget?: any | null;\r\n        PropagatedFrom?: any | null;\r\n\r\n        constructor(init?: Partial<LeafletEventArgsDto>) {\r\n            if (init) {\r\n                this.Type = init.Type ?? null;\r\n                this.Target = init.Target ?? null;\r\n                this.SourceTarget = init.SourceTarget ?? null;\r\n                this.PropagatedFrom = init.PropagatedFrom ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletEventArgsDto {\r\n            return {\r\n                Type: this.Type ?? null,\r\n                Target: this.Target ?? null,\r\n                SourceTarget: this.SourceTarget ?? null,\r\n                PropagatedFrom: this.PropagatedFrom ?? null\r\n            };\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletEventArgs {\r\n            const dto: LeafletEventArgsDto = {\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            };\r\n            return new LeafletEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletMouseEventArgs extends LeafletEventArgs {\r\n        LatLng?: L.LatLng | null;\r\n        LayerPoint?: L.Point | null;\r\n        ContainerPoint?: L.Point | null;\r\n        OriginalEvent?: any | null;\r\n\r\n        constructor(init?: Partial<LeafletMouseEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.LatLng = init.LatLng ?? null;\r\n                this.LayerPoint = init.LayerPoint ?? null;\r\n                this.ContainerPoint = init.ContainerPoint ?? null;\r\n                this.OriginalEvent = init.OriginalEvent ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletMouseEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                LatLng: this.LatLng ?? null,\r\n                LayerPoint: this.LayerPoint ?? null,\r\n                ContainerPoint: this.ContainerPoint ?? null,\r\n                OriginalEvent: this.OriginalEvent ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletMouseEventArgs {\r\n            const dto: Partial<LeafletMouseEventArgsDto> = {\r\n                LatLng: ev?.latlng ?? null,\r\n                LayerPoint: ev?.layerPoint ?? null,\r\n                ContainerPoint: ev?.containerPoint ?? null,\r\n                OriginalEvent: ev?.originalEvent ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as Partial<LeafletMouseEventArgsDto & LeafletEventArgsDto>;\r\n\r\n            return new LeafletMouseEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletResizeEventArgs extends LeafletEventArgs {\r\n        OldSize?: L.Point | null;\r\n        NewSize?: L.Point | null;\r\n\r\n        constructor(init?: Partial<LeafletResizeEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.OldSize = init.OldSize ?? null;\r\n                this.NewSize = init.NewSize ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletResizeEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                OldSize: this.OldSize ?? null,\r\n                NewSize: this.NewSize ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletResizeEventArgs {\r\n            const dto: Partial<LeafletResizeEventArgsDto> = {\r\n                OldSize: ev?.oldSize ?? null,\r\n                NewSize: ev?.newSize ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletResizeEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletPopupEventArgs extends LeafletEventArgs {\r\n        Popup?: L.Popup | null;\r\n\r\n        constructor(init?: Partial<LeafletPopupEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Popup = init.Popup ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletPopupEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Popup: this.Popup ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletPopupEventArgs {\r\n            const dto: Partial<LeafletPopupEventArgsDto> = {\r\n                Popup: ev?.popup ?? ev?.layer ?? ev?.target ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletPopupEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletDragEndEventArgs extends LeafletEventArgs {\r\n        Distance?: number | null;\r\n\r\n        constructor(init?: Partial<LeafletDragEndEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Distance = init.Distance ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletDragEndEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Distance: this.Distance ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletDragEndEventArgs {\r\n            const dto: Partial<LeafletDragEndEventArgsDto> = {\r\n                Distance: (typeof ev?.distance === 'number') ? ev.distance : null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletDragEndEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletErrorEventArgs extends LeafletEventArgs {\r\n        Message?: string | null;\r\n        Code?: number | null;\r\n\r\n        constructor(init?: Partial<LeafletErrorEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Message = init.Message ?? null;\r\n                this.Code = init.Code ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletErrorEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Message: this.Message ?? null,\r\n                Code: this.Code ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletErrorEventArgs {\r\n            // try common locations for message/code\r\n            const msg = ev?.message ?? ev?.error?.message ?? null;\r\n            const code = (typeof ev?.code === 'number') ? ev.code : (typeof ev?.status === 'number' ? ev.status : null);\r\n\r\n            const dto: Partial<LeafletErrorEventArgsDto> = {\r\n                Message: msg,\r\n                Code: code,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletErrorEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletGeoJsonEventArgs extends LeafletEventArgs {\r\n        Layer?: L.Layer | null;\r\n        Properties?: any | null;\r\n        GeometryType?: string | null;\r\n        Id?: string | null;\r\n\r\n        constructor(init?: Partial<LeafletGeoJsonEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Layer = init.Layer ?? null;\r\n                this.Properties = init.Properties ?? null;\r\n                this.GeometryType = init.GeometryType ?? null;\r\n                this.Id = init.Id ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletGeoJsonEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Layer: this.Layer ?? null,\r\n                Properties: this.Properties ?? null,\r\n                GeometryType: this.GeometryType ?? null,\r\n                Id: this.Id ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletGeoJsonEventArgs {\r\n            const dto: Partial<LeafletGeoJsonEventArgsDto> = {\r\n                Layer: minimalLayerInfo(ev?.layer) ?? minimalLayerInfo(ev?.target) ?? null,\r\n                Properties: ev?.properties ?? ev?.layer?.feature?.properties ?? null,\r\n                GeometryType: ev?.geometryType ?? ev?.layer?.feature?.geometry?.type ?? null,\r\n                Id: ev?.id ?? ev?.layer?.feature?.id ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n\r\n            return new LeafletGeoJsonEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletKeyboardEventArgs extends LeafletEventArgs {\r\n        OriginalEvent?: any | null;\r\n\r\n        constructor(init?: Partial<LeafletKeyboardEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.OriginalEvent = init.OriginalEvent ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletKeyboardEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                OriginalEvent: this.OriginalEvent ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletKeyboardEventArgs {\r\n            const dto: Partial<LeafletKeyboardEventArgsDto> = {\r\n                OriginalEvent: ev?.originalEvent ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletKeyboardEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletLayerEventArgs extends LeafletEventArgs {\r\n        Layer?: L.Layer | null;\r\n\r\n        constructor(init?: Partial<LeafletLayerEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Layer = init.Layer ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletLayerEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Layer: this.Layer ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletLayerEventArgs {\r\n            const dto: Partial<LeafletLayerEventArgsDto> = {\r\n                Layer: minimalLayerInfo(ev?.layer) ?? minimalLayerInfo(ev?.target) ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletLayerEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletLayersControlEventArgs extends LeafletEventArgs {\r\n        Layer?: L.Layer | null;\r\n        Name?: string | null;\r\n\r\n        constructor(init?: Partial<LeafletLayersControlEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Layer = init.Layer ?? null;\r\n                this.Name = init.Name ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletLayersControlEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Layer: this.Layer ?? null,\r\n                Name: this.Name ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletLayersControlEventArgs {\r\n            const dto: Partial<LeafletLayersControlEventArgsDto> = {\r\n                Layer: minimalLayerInfo(ev?.layer) ?? minimalLayerInfo(ev?.target) ?? null,\r\n                Name: ev?.name ?? ev?.layer?.options?.name ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletLayersControlEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletLocationEventArgs extends LeafletEventArgs {\r\n        LatLng?: L.LatLng;\r\n        Bounds?: LatLngBoundsDto | null;\r\n        Accuracy?: number | null;\r\n        Altitude?: number | null;\r\n        AltitudeAccuracy?: number | null;\r\n        Heading?: number | null;\r\n        Speed?: number | null;\r\n        Timestamp?: number | null;\r\n\r\n        constructor(init?: Partial<LeafletLocationEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.LatLng = init.LatLng ?? null;\r\n                this.Bounds = init.Bounds ?? null;\r\n                this.Accuracy = init.Accuracy ?? null;\r\n                this.Altitude = init.Altitude ?? null;\r\n                this.AltitudeAccuracy = init.AltitudeAccuracy ?? null;\r\n                this.Heading = init.Heading ?? null;\r\n                this.Speed = init.Speed ?? null;\r\n                this.Timestamp = init.Timestamp ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletLocationEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                LatLng: this.LatLng ?? null,\r\n                Bounds: this.Bounds ?? null,\r\n                Accuracy: this.Accuracy ?? null,\r\n                Altitude: this.Altitude ?? null,\r\n                AltitudeAccuracy: this.AltitudeAccuracy ?? null,\r\n                Heading: this.Heading ?? null,\r\n                Speed: this.Speed ?? null,\r\n                Timestamp: this.Timestamp ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletLocationEventArgs {\r\n            // LatLngBounds doesn't map directly, so create a simple DTO\r\n            let boundsDto = null;\r\n            if (ev?.bounds && typeof ev.bounds.getNorthEast === 'function') {\r\n                const ne = ev.bounds.getNorthEast();\r\n                const sw = ev.bounds.getSouthWest();\r\n                boundsDto = { NorthEast: ne, SouthWest: sw };\r\n            }\r\n\r\n            const dto: Partial<LeafletLocationEventArgsDto> = {\r\n                LatLng: ev.latlng ?? null,\r\n                Bounds: boundsDto ?? null,\r\n                Accuracy: ('accuracy' in (ev ?? {})) ? ev.accuracy : null,\r\n                Altitude: ('altitude' in (ev ?? {})) ? ev.altitude : null,\r\n                AltitudeAccuracy: ('altitudeAccuracy' in (ev ?? {})) ? ev.altitudeAccuracy : null,\r\n                Heading: ('heading' in (ev ?? {})) ? ev.heading : null,\r\n                Speed: ('speed' in (ev ?? {})) ? ev.speed : null,\r\n                Timestamp: ('timestamp' in (ev ?? {})) ? ev.timestamp : null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletLocationEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletTileErrorEventArgs extends LeafletEventArgs {\r\n        Tile?: any | null;\r\n        Coords?: L.Point | null;\r\n        Error?: any | null;\r\n\r\n        constructor(init?: Partial<LeafletTileErrorEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Tile = init.Tile ?? null;\r\n                this.Coords = init.Coords ?? null;\r\n                this.Error = init.Error ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletTileErrorEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Tile: this.Tile ?? null,\r\n                Coords: this.Coords ?? null,\r\n                Error: this.Error ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletTileErrorEventArgs {\r\n            const dto: Partial<LeafletTileErrorEventArgsDto> = {\r\n                Tile: ev?.tile ?? ev?.tile ?? null,\r\n                Coords: ev?.coords ?? ev?.coord ?? null,\r\n                Error: ev?.error ?? ev?.message ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletTileErrorEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletTileEventArgs extends LeafletEventArgs {\r\n        Tile?: any | null;\r\n        Coords?: L.Point | null;\r\n\r\n        constructor(init?: Partial<LeafletTileEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Tile = init.Tile ?? null;\r\n                this.Coords = init.Coords ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletTileEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Tile: this.Tile ?? null,\r\n                Coords: this.Coords ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletTileEventArgs {\r\n            const dto: Partial<LeafletTileEventArgsDto> = {\r\n                Tile: ev?.tile ?? ev?.tile ?? null,\r\n                Coords: ev?.coords ?? ev?.coord ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletTileEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletTooltipEventArgs extends LeafletEventArgs {\r\n        Tooltip?: L.Tooltip | null;\r\n\r\n        constructor(init?: Partial<LeafletTooltipEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Tooltip = init.Tooltip ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletTooltipEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Tooltip: this.Tooltip ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletTooltipEventArgs {\r\n            const dto: Partial<LeafletTooltipEventArgsDto> = {\r\n                Tooltip: ev?.tooltip ?? ev?.layer ?? ev?.target ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n            return new LeafletTooltipEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletZoomAnimEventArgs extends LeafletEventArgs {\r\n        Center?: L.LatLng | null;\r\n        Zoom?: number | null;\r\n        NoUpdate?: boolean | null;\r\n\r\n        constructor(init?: Partial<LeafletZoomAnimEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Center = init.Center ?? null;\r\n                this.Zoom = init.Zoom ?? null;\r\n                this.NoUpdate = init.NoUpdate ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletZoomAnimEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Center: this.Center ?? null,\r\n                Zoom: this.Zoom ?? null,\r\n                NoUpdate: this.NoUpdate ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletZoomAnimEventArgs {\r\n            const center = ev?.center ?? (ev?.target && typeof ev.target.getCenter === 'function' ? ev.target.getCenter() : null);\r\n            const zoom = (typeof ev?.zoom === 'number') ? ev.zoom : (typeof ev?.newZoom === 'number' ? ev.newZoom : null);\r\n            const noUpdate = ('noUpdate' in (ev ?? {})) ? !!ev.noUpdate : null;\r\n\r\n            const dto: Partial<LeafletZoomAnimEventArgsDto> = {\r\n                Center: center,\r\n                Zoom: zoom,\r\n                NoUpdate: noUpdate,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n\r\n            return new LeafletZoomAnimEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletFeatureMouseEventArgs extends LeafletMouseEventArgs {\r\n        LayerName?: string | null;\r\n        Feature?: any | null;\r\n\r\n        constructor(init?: Partial<LeafletFeatureMouseEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.LayerName = init.LayerName ?? null;\r\n                this.Feature = init.Feature ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletFeatureMouseEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                LayerName: this.LayerName ?? null,\r\n                Feature: this.Feature ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletFeatureMouseEventArgs {\r\n            const layerName = ev?.layerName ?? null;\r\n            const feature = ev?.feature ?? null;\r\n\r\n            const dto: Partial<LeafletFeatureMouseEventArgsDto> = {\r\n                LayerName: layerName,\r\n                Feature: feature,\r\n                LatLng: ev?.latlng ?? null,\r\n                LayerPoint: ev?.layerPoint ?? null,\r\n                ContainerPoint: ev?.containerPoint ?? null,\r\n                OriginalEvent: ev?.originalEvent ?? null,\r\n                Type: ev?.type ?? null,\r\n                // Use minimalLayerInfo to avoid passing full Layer objects with circular refs\r\n                Target: minimalLayerInfo(ev?.target) ?? null,\r\n                SourceTarget: minimalLayerInfo(ev?.sourceTarget) ?? null,\r\n                PropagatedFrom: minimalLayerInfo(ev?.propagatedFrom) ?? null\r\n            } as any;\r\n\r\n            return new LeafletFeatureMouseEventArgs(dto);\r\n        }\r\n    }\r\n\r\n    export class LeafletTileFetchErrorEventArgs extends LeafletTileErrorEventArgs {\r\n        Url?: string | null;\r\n        z?: number | null\r\n        x?: number | null;\r\n        y?: number | null;\r\n\r\n        constructor(init?: Partial<LeafletTileFetchErrorEventArgsDto>) {\r\n            super(init);\r\n            if (init) {\r\n                this.Url = init.Url ?? null;\r\n                this.z = init.z ?? null;\r\n                this.x = init.x ?? null;\r\n                this.y = init.y ?? null;\r\n            }\r\n        }\r\n\r\n        toDto(): LeafletTileFetchErrorEventArgsDto {\r\n            const base = super.toDto();\r\n            return Object.assign({}, base, {\r\n                Url: this.Url ?? null,\r\n                z: this.z ?? null,\r\n                x: this.x ?? null,\r\n                y: this.y ?? null\r\n            });\r\n        }\r\n\r\n        static fromLeaflet(ev: any): LeafletTileFetchErrorEventArgs {\r\n            const dto: Partial<LeafletTileFetchErrorEventArgsDto> = {\r\n                Url: ev?.url ?? null,\r\n                z: (typeof ev?.z === 'number') ? ev.z : null,\r\n                x: (typeof ev?.x === 'number') ? ev.x : null,\r\n                y: (typeof ev?.y === 'number') ? ev.y : null,\r\n                Tile: ev?.tile ?? ev?.tile ?? null,\r\n                Coords: (typeof ev?.coords === 'object') ? ev.coords : null,\r\n                Error: ev?.error ?? null\r\n            };\r\n            return new LeafletTileFetchErrorEventArgs(dto);\r\n        }\r\n    }\r\n}\r\n\r\nexport default LeafletEvents;\r\n","import { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\ndeclare const L: typeof import('leaflet');\r\n\r\nexport const Map = {\r\n    createMap(\r\n        elementId: string,\r\n        options: L.MapOptions | undefined,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): any {\r\n        const map = L.map(elementId, options);\r\n\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n            if (keys.indexOf('resize') > -1) {\r\n                map.on('resize', function (ev: L.ResizeEvent) {\r\n                    var methodName = handlerMappings.events['resize'];\r\n                    let payload = LeafletEvents.LeafletResizeEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('viewreset') > -1) {\r\n                map.on('viewreset', function (ev: any) {\r\n                    var methodName = handlerMappings.events['viewreset'];\r\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('zoomlevelschange') > -1) {\r\n                map.on('zoomlevelschange', function (ev: any) {\r\n                    var methodName = handlerMappings.events['zoomlevelschange'];\r\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('zoomend') > -1) {\r\n                map.on('zoomend', function (ev: any) {\r\n                    var methodName = handlerMappings.events['zoomend'];\r\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('moveend') > -1) {\r\n                map.on('moveend', function (ev: any) {\r\n                    var methodName = handlerMappings.events['moveend'];\r\n                    let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('click') > -1) {\r\n                map.on('click', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events['click'];\r\n                    let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('dblclick') > -1) {\r\n                map.on('dblclick', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events['dblclick'];\r\n                    let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('contextmenu') > -1)\r\n            {\r\n                map.on('contextmenu', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events['contextmenu'];\r\n                    let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                map.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupopen'];\r\n                    let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                map.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupclose'];\r\n                    let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('locationerror') > -1) {\r\n                map.on('locationerror', function (ev: L.ErrorEvent) {\r\n                    var methodName = handlerMappings.events['locationerror'];\r\n                    let payload = LeafletEvents.LeafletErrorEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n            if (keys.indexOf('locationfound') > -1) {\r\n                map.on('locationfound', function (ev: L.LocationEvent) {\r\n                    var methodName = handlerMappings.events['locationfound'];\r\n                    let payload = LeafletEvents.LeafletLocationEventArgs.fromLeaflet(ev).toDto();\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Create a wrapper object that properly serializes getBounds()\r\n        const mapWrapper = Object.create(map);\r\n        \r\n        // Override getBounds to return a properly formatted object for C# serialization\r\n        mapWrapper.getBounds = function() {\r\n            const bounds = map.getBounds();\r\n            const sw = bounds.getSouthWest();\r\n            const ne = bounds.getNorthEast();\r\n            \r\n            return {\r\n                SouthWest: {\r\n                    Lat: sw.lat,\r\n                    Lng: sw.lng\r\n                },\r\n                NorthEast: {\r\n                    Lat: ne.lat,\r\n                    Lng: ne.lng\r\n                }\r\n            };\r\n        };\r\n\r\n        return mapWrapper;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const Layer = {\r\n    addTo(layer: L.Layer, map: L.Map, handlerMappings?: EventHandlerMapping): void {\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n            if (keys.indexOf('add') > -1) {\r\n                layer.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events['add'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking add handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                layer.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events['remove'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking remove handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                layer.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                layer.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                layer.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                layer.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        layer.addTo(map);\r\n    },\r\n\r\n    remove(layer: L.Layer): void {\r\n        layer.remove();\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const GridLayer = {\r\n    createGridLayer(\r\n        options?: L.GridLayerOptions,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.GridLayer {\r\n        const gridLayer = L.gridLayer();\r\n        // Attach event handlers if any\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n\r\n            if (keys.indexOf('loading') > -1) {\r\n                gridLayer.on('loading', function (ev: any) {\r\n                    var methodName = handlerMappings.events['loading'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking loading handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileunload') > -1) {\r\n                gridLayer.on('tileunload', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileunload'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileunload handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileloadstart') > -1) {\r\n                gridLayer.on('tileloadstart', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileloadstart'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileloadstart handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileerror') > -1) {\r\n                gridLayer.on('tileerror', function (ev: L.TileErrorEvent) {\r\n                    var methodName = handlerMappings.events['tileerror'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileErrorEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileerror handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileload') > -1) {\r\n                gridLayer.on('tileload', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileload'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileload handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('load') > -1) {\r\n                gridLayer.on('load', function (ev: any) {\r\n                    var methodName = handlerMappings.events['load'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking load handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('add') > -1) {\r\n                gridLayer.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events['add'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking add handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                gridLayer.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events['remove'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking remove handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                gridLayer.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                gridLayer.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                gridLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                gridLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return gridLayer;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const TileLayer = {\r\n    createTileLayer(\r\n        urlTemplate: string,\r\n        options?: L.TileLayerOptions,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.TileLayer {\r\n        const tileLayer = L.tileLayer(urlTemplate, options);\r\n        // Attach event handlers if any\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n\r\n            if (keys.indexOf('tileabort') > -1) {\r\n                tileLayer.on('tileabort', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileabort'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileabort handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('loading') > -1) {\r\n                tileLayer.on('loading', function (ev: any) {\r\n                    var methodName = handlerMappings.events['loading'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking loading handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileunload') > -1) {\r\n                tileLayer.on('tileunload', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileunload'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileunload handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileloadstart') > -1) {\r\n                tileLayer.on('tileloadstart', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileloadstart'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileloadstart handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileerror') > -1) {\r\n                tileLayer.on('tileerror', function (ev: L.TileErrorEvent) {\r\n                    var methodName = handlerMappings.events['tileerror'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileErrorEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileerror handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileload') > -1) {\r\n                tileLayer.on('tileload', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileload'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileload handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('load') > -1) {\r\n                tileLayer.on('load', function (ev: any) {\r\n                    var methodName = handlerMappings.events['load'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking load handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('add') > -1) {\r\n                tileLayer.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events['add'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking add handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                tileLayer.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events['remove'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking remove handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                tileLayer.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                tileLayer.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                tileLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                tileLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return tileLayer;\r\n    }\r\n}\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const WmsTileLayer = {\r\n    createWmsTileLayer(\r\n        baseUrl: string,\r\n        options?: L.WMSOptions,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.TileLayer.WMS {\r\n        const wmsTileLayer = L.tileLayer.wms(baseUrl, options);\r\n        // Attach event handlers if any\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n            if (keys.indexOf('tileabort') > -1) {\r\n                wmsTileLayer.on('tileabort', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileabort'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileabort handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('loading') > -1) {\r\n                wmsTileLayer.on('loading', function (ev: any) {\r\n                    var methodName = handlerMappings.events['loading'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking loading handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileunload') > -1) {\r\n                wmsTileLayer.on('tileunload', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileunload'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileunload handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileloadstart') > -1) {\r\n                wmsTileLayer.on('tileloadstart', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileloadstart'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileloadstart handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileerror') > -1) {\r\n                wmsTileLayer.on('tileerror', function (ev: L.TileErrorEvent) {\r\n                    var methodName = handlerMappings.events['tileerror'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileErrorEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileerror handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tileload') > -1) {\r\n                wmsTileLayer.on('tileload', function (ev: L.TileEvent) {\r\n                    var methodName = handlerMappings.events['tileload'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTileEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tileload handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('load') > -1) {\r\n                wmsTileLayer.on('load', function (ev: any) {\r\n                    var methodName = handlerMappings.events['load'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking load handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('add') > -1) {\r\n                wmsTileLayer.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events['add'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking add handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                wmsTileLayer.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events['remove'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking remove handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                wmsTileLayer.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                wmsTileLayer.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                wmsTileLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                wmsTileLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return wmsTileLayer;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\n// Common helper functions for vector tile layers\r\nconst VectorTileHelpers = {\r\n    getRendererFactory(rendererType?: string): any {\r\n        if (!rendererType) {\r\n            return undefined;\r\n        }\r\n\r\n        const type = rendererType.toLowerCase();\r\n        if (type === 'canvas') {\r\n            const LCanvas = (L as any).Canvas;\r\n            if (LCanvas && typeof LCanvas.tile === 'function') {\r\n                return LCanvas.tile;\r\n            }\r\n            console.warn('L.Canvas.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\r\n        } else if (type === 'svg') {\r\n            const LSVG = (L as any).SVG;\r\n            if (LSVG && typeof LSVG.tile === 'function') {\r\n                return LSVG.tile;\r\n            }\r\n            console.warn('L.SVG.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\r\n        }\r\n        return undefined;\r\n    },\r\n\r\n    setupFeatureSelection(\r\n        vectorTileLayer: any,\r\n        options: any,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): void {\r\n        // Default styles (DRY - single source of truth)\r\n        const DEFAULT_SELECTION_STYLE = {\r\n            color: '#368ce1',\r\n            weight: 3,\r\n            fillColor: '#368ce1',\r\n            fillOpacity: 0.3,\r\n            opacity: 1\r\n        };\r\n\r\n        const DEFAULT_HOVER_STYLE = {\r\n            color: 'red',\r\n            weight: 2,\r\n            opacity: 1.0\r\n        };\r\n\r\n        // Selection state management\r\n        const selectedFeatures: Map<any, any> = new Map();\r\n        const selectedLayers: Map<any, any[]> = new Map();\r\n        \r\n        // Hover state management\r\n        const hoveredLayers: Map<any, any> = new Map(); // Map of layer -> original style (for hover)\r\n        \r\n        // Track all layers by feature ID as they're added\r\n        const layersByFeatureId: Map<string, any[]> = new Map();\r\n\r\n        const selectedFeatureStyle = options?.selectedFeatureStyle ?? DEFAULT_SELECTION_STYLE;\r\n\r\n        // Helper to apply selected style\r\n        const applySelectedStyle = (layer: any) => {\r\n            if (layer && layer.setStyle) {\r\n                const leafletStyle: any = {};\r\n                \r\n                if (selectedFeatureStyle.color) leafletStyle.color = selectedFeatureStyle.color;\r\n                if (selectedFeatureStyle.weight !== undefined) leafletStyle.weight = selectedFeatureStyle.weight;\r\n                if (selectedFeatureStyle.opacity !== undefined) leafletStyle.opacity = selectedFeatureStyle.opacity;\r\n                if (selectedFeatureStyle.fillColor) leafletStyle.fillColor = selectedFeatureStyle.fillColor;\r\n                if (selectedFeatureStyle.fillOpacity !== undefined) leafletStyle.fillOpacity = selectedFeatureStyle.fillOpacity;\r\n                if (selectedFeatureStyle.fill !== undefined) leafletStyle.fill = selectedFeatureStyle.fill;\r\n                if (selectedFeatureStyle.stroke !== undefined) leafletStyle.stroke = selectedFeatureStyle.stroke;\r\n                if (selectedFeatureStyle.dashArray) leafletStyle.dashArray = selectedFeatureStyle.dashArray;\r\n                if (selectedFeatureStyle.lineCap) leafletStyle.lineCap = selectedFeatureStyle.lineCap;\r\n                if (selectedFeatureStyle.lineJoin) leafletStyle.lineJoin = selectedFeatureStyle.lineJoin;\r\n                \r\n                layer.setStyle(leafletStyle);\r\n            }\r\n        };\r\n\r\n        // Helper to reset style to original\r\n        const resetStyle = (layer: any) => {\r\n            if (layer && layer.setStyle && layer.options?.originalStyle) {\r\n                layer.setStyle(layer.options.originalStyle);\r\n            }\r\n        };\r\n\r\n        // Helper to get feature identifier\r\n        const getFeatureIdentifier = (properties: any): string => {\r\n            return properties?.id ?? properties?.ID ?? properties?.fid ?? properties?.FID ??\r\n                properties?.objectid ?? properties?.OBJECTID ?? JSON.stringify(properties);\r\n        };\r\n\r\n        // Track layers as they're created by VectorGrid\r\n        vectorTileLayer.on('click', function(e: any) {\r\n            if (e.layer && e.layer.properties) {\r\n                const featureId = getFeatureIdentifier(e.layer.properties);\r\n                \r\n                // Add this layer to our tracking map\r\n                if (!layersByFeatureId.has(featureId)) {\r\n                    layersByFeatureId.set(featureId, []);\r\n                }\r\n                const layers = layersByFeatureId.get(featureId)!;\r\n                if (!layers.includes(e.layer)) {\r\n                    layers.push(e.layer);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Helper to find and style all layers with the same feature ID\r\n        const selectAllSegments = (featureId: string) => {\r\n            const layers = layersByFeatureId.get(featureId) || [];\r\n            \r\n            layers.forEach(layer => {\r\n                // Store original style if not already stored\r\n                if (!layer.options.originalStyle) {\r\n                    layer.options.originalStyle = {\r\n                        fillColor: layer.options.fillColor,\r\n                        color: layer.options.color,\r\n                        weight: layer.options.weight,\r\n                        fillOpacity: layer.options.fillOpacity,\r\n                        fill: layer.options.fill\r\n                    };\r\n                }\r\n                \r\n                applySelectedStyle(layer);\r\n            });\r\n            \r\n            return layers;\r\n        };\r\n\r\n        // Helper to reset all segments of a feature\r\n        const unselectAllSegments = (featureId: string) => {\r\n            const layers = selectedLayers.get(featureId);\r\n            if (layers) {\r\n                layers.forEach(layer => resetStyle(layer));\r\n            }\r\n        };\r\n\r\n        // Add click handler for feature selection\r\n        if (options?.enableFeatureSelection !== false) {\r\n            vectorTileLayer.on('click', function (e: any) {\r\n                if (e.layer && e.layer.properties) {\r\n                    // Check current enableFeatureSelection state\r\n                    const currentOptions = vectorTileLayer._pyroOptions || options;\r\n                    if (currentOptions?.enableFeatureSelection === false) {\r\n                        return; // Selection disabled\r\n                    }\r\n                    \r\n                    const featureId = getFeatureIdentifier(e.layer.properties);\r\n                    const feature = {\r\n                        id: featureId,\r\n                        type: e.layer.feature?.type ?? 'Feature',\r\n                        geometry: e.layer.feature?.geometry,\r\n                        properties: e.layer.properties\r\n                    };\r\n\r\n                    const isSelected = selectedFeatures.has(featureId);\r\n\r\n                    if (isSelected) {\r\n                        // Unselect all segments of this feature\r\n                        const layers = selectedLayers.get(featureId);\r\n                        \r\n                        unselectAllSegments(featureId);\r\n                        selectedFeatures.delete(featureId);\r\n                        selectedLayers.delete(featureId);\r\n                        \r\n                        // Check if any segment is currently being hovered\r\n                        // If so, reapply hover style instead of original\r\n                        if (layers) {\r\n                            const isCurrentlyHovered = layers.some(layer => hoveredLayers.has(layer));\r\n                            \r\n                            if (isCurrentlyHovered) {\r\n                                // Reapply hover style to all segments\r\n                                const hoverStyle = currentOptions?.hoverStyle || DEFAULT_HOVER_STYLE;\r\n                                layers.forEach(layer => {\r\n                                    if (layer.setStyle) {\r\n                                        const currentStyle = {\r\n                                            color: layer.options.originalStyle?.color || layer.options.color,\r\n                                            weight: layer.options.originalStyle?.weight || layer.options.weight,\r\n                                            opacity: layer.options.originalStyle?.opacity || layer.options.opacity,\r\n                                            fillColor: layer.options.originalStyle?.fillColor || layer.options.fillColor,\r\n                                            fillOpacity: layer.options.originalStyle?.fillOpacity || layer.options.fillOpacity\r\n                                        };\r\n                                        const mergedStyle = { ...currentStyle, ...hoverStyle };\r\n                                        layer.setStyle(mergedStyle);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        // Notify C# of unselection\r\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureunselected']) {\r\n                            handlerMappings.dotNetRef.invokeMethodAsync(\r\n                                handlerMappings.events['featureunselected'],\r\n                                {\r\n                                    feature: feature,\r\n                                    latlng: e.latlng,\r\n                                    layerPoint: e.layerPoint,\r\n                                    containerPoint: e.containerPoint\r\n                                }\r\n                            );\r\n                        }\r\n                    } else {\r\n                        // Handle multiple selection based on current state\r\n                        const allowMultiple = currentOptions?.multipleFeatureSelection === true;\r\n                        \r\n                        if (!allowMultiple) {\r\n                            // Unselect all previously selected features\r\n                            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\r\n                            selectedFeatures.clear();\r\n                            selectedLayers.clear();\r\n                        }\r\n\r\n                        // Select all segments of this feature across all tiles\r\n                        const layers = selectAllSegments(featureId);\r\n                        \r\n                        // Bring all selected segments to front\r\n                        layers.forEach(layer => {\r\n                            if (layer.bringToFront) {\r\n                                layer.bringToFront();\r\n                            }\r\n                            // Note: Don't clear hover state - keep it for proper restoration\r\n                            // The selection style will override the hover style visually\r\n                        });\r\n                        \r\n                        selectedFeatures.set(featureId, feature);\r\n                        selectedLayers.set(featureId, layers);\r\n\r\n                        // Notify C# of selection\r\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureselected']) {\r\n                            handlerMappings.dotNetRef.invokeMethodAsync(\r\n                                handlerMappings.events['featureselected'],\r\n                                {\r\n                                    feature: feature,\r\n                                    latlng: e.latlng,\r\n                                    layerPoint: e.layerPoint,\r\n                                    containerPoint: e.containerPoint\r\n                                }\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    // Always fire clicked event\r\n                    if (handlerMappings?.dotNetRef && handlerMappings.events['featureclicked']) {\r\n                        handlerMappings.dotNetRef.invokeMethodAsync(\r\n                            handlerMappings.events['featureclicked'],\r\n                            {\r\n                                feature: feature,\r\n                                latlng: e.latlng,\r\n                                layerPoint: e.layerPoint,\r\n                                containerPoint: e.containerPoint\r\n                            }\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Add clearSelection method\r\n        (vectorTileLayer as any).clearSelection = function () {\r\n            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\r\n            selectedFeatures.clear();\r\n            selectedLayers.clear();\r\n            \r\n            // Clear any hover states\r\n            hoveredLayers.forEach((originalStyle, layer) => {\r\n                if (layer && layer.setStyle && originalStyle) {\r\n                    layer.setStyle(originalStyle);\r\n                }\r\n            });\r\n            hoveredLayers.clear();\r\n        };\r\n\r\n        // Hover styling (controlled by enableHoverStyle flag and interactive mode)\r\n        if (options?.interactive === true && options?.enableHoverStyle !== false) {\r\n            const hoverStyle = options?.hoverStyle || DEFAULT_HOVER_STYLE;\r\n            \r\n            vectorTileLayer.on('mouseover', function (e: any) {\r\n                if (e.layer && e.layer.properties) {\r\n                    const featureId = getFeatureIdentifier(e.layer.properties);\r\n                    \r\n                    // Track this layer for selection (even if just hovering)\r\n                    if (!layersByFeatureId.has(featureId)) {\r\n                        layersByFeatureId.set(featureId, []);\r\n                    }\r\n                    const layers = layersByFeatureId.get(featureId)!;\r\n                    if (!layers.includes(e.layer)) {\r\n                        layers.push(e.layer);\r\n                    }\r\n                    \r\n                    // Don't apply hover if feature is selected\r\n                    if (!selectedFeatures.has(featureId)) {\r\n                        // Get all segments of this feature\r\n                        const allSegments = layersByFeatureId.get(featureId) || [];\r\n                        \r\n                        // Apply hover to ALL segments\r\n                        allSegments.forEach(layer => {\r\n                            // Bring to front if possible\r\n                            if (layer.bringToFront) {\r\n                                layer.bringToFront();\r\n                            }\r\n                            \r\n                            // Store original style if not already hovering\r\n                            if (!hoveredLayers.has(layer)) {\r\n                                hoveredLayers.set(layer, {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity\r\n                                });\r\n                                \r\n                                // Apply hover style (merge with current to preserve fill)\r\n                                const currentStyle = {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity\r\n                                };\r\n                                \r\n                                const mergedStyle = { ...currentStyle, ...hoverStyle };\r\n                                if (layer.setStyle) {\r\n                                    layer.setStyle(mergedStyle);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n\r\n            vectorTileLayer.on('mouseout', function (e: any) {\r\n                if (e.layer && e.layer.properties) {\r\n                    const featureId = getFeatureIdentifier(e.layer.properties);\r\n                    \r\n                    // Get all segments that were hovered\r\n                    const allSegments = layersByFeatureId.get(featureId) || [];\r\n                    \r\n                    // Restore ALL segments\r\n                    allSegments.forEach(layer => {\r\n                        if (hoveredLayers.has(layer)) {\r\n                            const originalStyle = hoveredLayers.get(layer);\r\n                            \r\n                            // Check if feature is selected\r\n                            const isSelected = selectedFeatures.has(featureId);\r\n                            \r\n                            if (isSelected) {\r\n                                // Don't restore - reapply selection style instead\r\n                                applySelectedStyle(layer);\r\n                            } else if (originalStyle && layer.setStyle) {\r\n                                // Restore original style\r\n                                layer.setStyle(originalStyle);\r\n                            }\r\n                            \r\n                            hoveredLayers.delete(layer);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    },\r\n\r\n    attachGridLayerEvents(vectorTileLayer: any, handlerMappings?: EventHandlerMapping): void {\r\n        if (!handlerMappings?.dotNetRef || !handlerMappings.events) {\r\n            return;\r\n        }\r\n\r\n        const keys = Object.keys(handlerMappings.events);\r\n\r\n        const eventMappings: { [key: string]: { eventName: string, argType: string } } = {\r\n            'loading': { eventName: 'loading', argType: 'LeafletEventArgs' },\r\n            'tileunload': { eventName: 'tileunload', argType: 'LeafletTileEventArgs' },\r\n            'tileloadstart': { eventName: 'tileloadstart', argType: 'LeafletTileEventArgs' },\r\n            'tileerror': { eventName: 'tileerror', argType: 'LeafletTileErrorEventArgs' },\r\n            'tileload': { eventName: 'tileload', argType: 'LeafletTileEventArgs' },\r\n            'load': { eventName: 'load', argType: 'LeafletEventArgs' },\r\n            'add': { eventName: 'add', argType: 'LeafletEventArgs' },\r\n            'remove': { eventName: 'remove', argType: 'LeafletEventArgs' }\r\n        };\r\n\r\n        for (const key of keys) {\r\n            const mapping = eventMappings[key];\r\n            if (mapping) {\r\n                vectorTileLayer.on(mapping.eventName, function (ev: any) {\r\n                    const methodName = handlerMappings.events[key];\r\n                    try {\r\n                        const EventClass = (LeafletEvents as any)[mapping.argType];\r\n                        const payload = EventClass.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking ${mapping.eventName} handler:`, e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    },\r\n\r\n    attachInteractiveEvents(vectorTileLayer: any, options: any, handlerMappings?: EventHandlerMapping): void {\r\n        // Only attach interactive events if the layer is set to interactive\r\n        if (!options?.interactive || !handlerMappings?.dotNetRef || !handlerMappings.events) {\r\n            return;\r\n        }\r\n\r\n        const keys = Object.keys(handlerMappings.events);\r\n\r\n        // Mouse events on features\r\n        const interactiveEventMappings: { [key: string]: string } = {\r\n            'mouseover': 'mouseover',\r\n            'mouseout': 'mouseout',\r\n            'mousemove': 'mousemove',\r\n            'dblclick': 'dblclick',\r\n            'contextmenu': 'contextmenu'\r\n        };\r\n\r\n        for (const [eventKey, leafletEvent] of Object.entries(interactiveEventMappings)) {\r\n            if (keys.indexOf(eventKey) > -1) {\r\n                vectorTileLayer.on(leafletEvent, function (e: any) {\r\n                    const methodName = handlerMappings.events[eventKey];\r\n                    try {\r\n                        const payload = {\r\n                            latlng: e.latlng ? { lat: e.latlng.lat, lng: e.latlng.lng } : null,\r\n                            layerPoint: e.layerPoint ? { x: e.layerPoint.x, y: e.layerPoint.y } : null,\r\n                            containerPoint: e.containerPoint ? { x: e.containerPoint.x, y: e.containerPoint.y } : null,\r\n                            feature: e.layer && e.layer.properties ? {\r\n                                id: e.layer.properties.id ?? e.layer.properties.ID ?? e.layer.properties.fid ?? e.layer.properties.FID,\r\n                                type: e.layer.feature?.type ?? 'Feature',\r\n                                geometry: e.layer.feature?.geometry,\r\n                                properties: e.layer.properties\r\n                            } : null\r\n                        };\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (err) {\r\n                        console.error(`Error invoking ${eventKey} handler:`, err);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    },\r\n\r\n    setInteractive(vectorTileLayer: any, interactive: boolean): void {\r\n        // Update the interactive option\r\n        if (vectorTileLayer.options) {\r\n            vectorTileLayer.options.interactive = interactive;\r\n        }\r\n        \r\n        // VectorGrid stores interactivity at the layer level\r\n        // We need to update the actual layer's interactive state\r\n        if ((vectorTileLayer as any)._vectorTiles) {\r\n            // Iterate through all loaded tiles and update their interactive state\r\n            Object.values((vectorTileLayer as any)._vectorTiles).forEach((tile: any) => {\r\n                if (tile && tile._features) {\r\n                    Object.values(tile._features).forEach((feature: any) => {\r\n                        if (feature) {\r\n                            feature.options.interactive = interactive;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Redraw the layer to apply changes\r\n        if (vectorTileLayer.redraw) {\r\n            vectorTileLayer.redraw();\r\n        }\r\n    },\r\n\r\n    setEnableFeatureSelection(vectorTileLayer: any, enableFeatureSelection: boolean): void {\r\n        // Update the enableFeatureSelection option\r\n        if (vectorTileLayer._pyroOptions) {\r\n            vectorTileLayer._pyroOptions.enableFeatureSelection = enableFeatureSelection;\r\n        }\r\n        \r\n        // If disabling selection, clear any current selections\r\n        if (!enableFeatureSelection && vectorTileLayer.clearSelection) {\r\n            vectorTileLayer.clearSelection();\r\n        }\r\n    },\r\n\r\n    setMultipleFeatureSelection(vectorTileLayer: any, multipleFeatureSelection: boolean): void {\r\n        // Update the multipleFeatureSelection option\r\n        if (vectorTileLayer._pyroOptions) {\r\n            vectorTileLayer._pyroOptions.multipleFeatureSelection = multipleFeatureSelection;\r\n        }\r\n        \r\n        // If switching from multiple to single selection and multiple features are selected,\r\n        // keep only the most recently selected feature\r\n        if (!multipleFeatureSelection && vectorTileLayer.clearSelection) {\r\n            // Note: We don't clear here - the next selection will handle it\r\n            // The selection logic checks the multipleFeatureSelection flag\r\n        }\r\n    }\r\n};\r\n\r\nexport const ProtobufVectorTileLayer = {\r\n    createProtobufVectorTileLayer(\r\n        urlTemplate: string,\r\n        options?: any,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.Layer {\r\n        // Check if Leaflet.VectorGrid is available\r\n        if (!(L as any).vectorGrid || typeof (L as any).vectorGrid.protobuf !== 'function') {\r\n            console.error('Leaflet.VectorGrid plugin is not loaded. Please include Leaflet.VectorGrid.bundled.js');\r\n            throw new Error('Leaflet.VectorGrid plugin is required but not loaded');\r\n        }\r\n\r\n        // Replace {LayerName} placeholder if layerName is provided in options\r\n        if (options?.layerName) {\r\n            urlTemplate = urlTemplate.replace('{LayerName}', options.layerName);\r\n        }\r\n\r\n        // Build VectorGrid options with default fill style\r\n        let vectorTileLayerStyles = options?.vectorTileLayerStyles;\r\n        \r\n        // VectorGrid expects vectorTileLayerStyles to be an object where:\r\n        // - Keys are layer names (must match exactly what's in the MVT)\r\n        // - Values can be objects OR functions that return style objects\r\n        \r\n        if (vectorTileLayerStyles && typeof vectorTileLayerStyles === 'object' && Object.keys(vectorTileLayerStyles).length > 0) {\r\n            // Log each style and create a default catchall\r\n            const enhancedStyles: any = {};\r\n            \r\n            for (const [layerName, style] of Object.entries(vectorTileLayerStyles)) {\r\n                // Wrap each style in a function that VectorGrid will call per-feature\r\n                enhancedStyles[layerName] = function(properties: any) {\r\n                    return style;\r\n                };\r\n            }\r\n            \r\n            // Add a catchall for any layer name variations\r\n            const firstStyle = Object.values(vectorTileLayerStyles)[0];\r\n            const layerKeys = Object.keys(vectorTileLayerStyles);\r\n            \r\n            // Try common variations of the layer names\r\n            for (const key of layerKeys) {\r\n                // Add version without workspace prefix (e.g., \"PlannerSpatial:Township\" -> \"Township\")\r\n                const simpleName = key.split(':').pop();\r\n                if (simpleName && !enhancedStyles[simpleName]) {\r\n                    enhancedStyles[simpleName] = function(properties: any) {\r\n                        return firstStyle;\r\n                    };\r\n                }\r\n            }\r\n            \r\n            vectorTileLayerStyles = enhancedStyles;\r\n            \r\n        } else if (!vectorTileLayerStyles || Object.keys(vectorTileLayerStyles).length === 0) {\r\n            // Create a default style function for unspecified layers\r\n            vectorTileLayerStyles = {\r\n                '': function() {\r\n                    return {\r\n                        fill: true,\r\n                        fillColor: '#3388ff',\r\n                        fillOpacity: 0.2,\r\n                        stroke: true,\r\n                        color: '#3388ff',\r\n                        weight: 1,\r\n                        opacity: 1\r\n                    };\r\n                }\r\n            };\r\n        }\r\n\r\n        const vectorGridOptions: any = {\r\n            interactive: options?.interactive ?? false,\r\n            getFeatureId: options?.getFeatureId,\r\n            vectorTileLayerStyles: vectorTileLayerStyles,\r\n            minZoom: options?.minZoom ?? 0,\r\n            maxZoom: options?.maxZoom,\r\n            maxNativeZoom: options?.maxNativeZoom,\r\n            minNativeZoom: options?.minNativeZoom,\r\n            tileSize: options?.tileSize ?? 256,\r\n            opacity: options?.opacity ?? 1.0,\r\n            updateWhenIdle: options?.updateWhenIdle,\r\n            updateWhenZooming: options?.updateWhenZooming ?? true,\r\n            updateInterval: options?.updateInterval ?? 200,\r\n            zIndex: options?.zIndex ?? 1,\r\n            bounds: options?.bounds,\r\n            noWrap: options?.noWrap ?? false,\r\n            pane: options?.pane ?? 'tilePane',\r\n            className: options?.className ?? '',\r\n            keepBuffer: options?.keepBuffer ?? 2,\r\n            attribution: options?.attribution ?? ''\r\n        };\r\n\r\n        // Only add subdomains if provided, otherwise VectorGrid uses its default\r\n        if (options?.subdomains !== undefined && options.subdomains !== null) {\r\n            vectorGridOptions.subdomains = options.subdomains;\r\n        }\r\n\r\n        // Add renderer factory if specified\r\n        const rendererFactory = VectorTileHelpers.getRendererFactory(options?.rendererFactory);\r\n        if (rendererFactory !== undefined) {\r\n            vectorGridOptions.rendererFactory = rendererFactory;\r\n        }\r\n\r\n        // Create the VectorGrid Protobuf layer\r\n        const vectorTileLayer = (L as any).vectorGrid.protobuf(urlTemplate, vectorGridOptions);\r\n\r\n        // Store options for dynamic updates\r\n        (vectorTileLayer as any)._pyroOptions = {\r\n            interactive: options?.interactive ?? false,\r\n            enableFeatureSelection: options?.enableFeatureSelection !== false,\r\n            multipleFeatureSelection: options?.multipleFeatureSelection === true,\r\n            enableHoverStyle: options?.enableHoverStyle !== false,\r\n            selectedFeatureStyle: options?.selectedFeatureStyle,\r\n            hoverStyle: options?.hoverStyle\r\n        };\r\n\r\n        // Setup feature selection\r\n        VectorTileHelpers.setupFeatureSelection(vectorTileLayer, options, handlerMappings);\r\n\r\n        // Attach interactive event handlers (mouseover, mouseout, etc.)\r\n        VectorTileHelpers.attachInteractiveEvents(vectorTileLayer, options, handlerMappings);\r\n\r\n        // Attach standard event handlers\r\n        VectorTileHelpers.attachGridLayerEvents(vectorTileLayer, handlerMappings);\r\n\r\n        // Expose setInteractive method\r\n        (vectorTileLayer as any).setInteractive = function (interactive: boolean) {\r\n            VectorTileHelpers.setInteractive(vectorTileLayer, interactive);\r\n        };\r\n\r\n        // Expose setEnableFeatureSelection method\r\n        (vectorTileLayer as any).setEnableFeatureSelection = function (enableFeatureSelection: boolean) {\r\n            VectorTileHelpers.setEnableFeatureSelection(vectorTileLayer, enableFeatureSelection);\r\n        };\r\n\r\n        // Expose setMultipleFeatureSelection method\r\n        (vectorTileLayer as any).setMultipleFeatureSelection = function (multipleFeatureSelection: boolean) {\r\n            VectorTileHelpers.setMultipleFeatureSelection(vectorTileLayer, multipleFeatureSelection);\r\n        };\r\n\r\n        return vectorTileLayer;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\n// Import helpers from protobuf implementation\r\n// Note: In a real implementation, you'd extract these to a shared module\r\n// For now, we'll duplicate the minimal needed code\r\n\r\nconst getRendererFactory = (rendererType?: string): any => {\r\n    if (!rendererType) {\r\n        return undefined;\r\n    }\r\n\r\n    const type = rendererType.toLowerCase();\r\n    if (type === 'canvas') {\r\n        const LCanvas = (L as any).Canvas;\r\n        if (LCanvas && typeof LCanvas.tile === 'function') {\r\n            return LCanvas.tile;\r\n        }\r\n        console.warn('L.Canvas.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\r\n    } else if (type === 'svg') {\r\n        const LSVG = (L as any).SVG;\r\n        if (LSVG && typeof LSVG.tile === 'function') {\r\n            return LSVG.tile;\r\n        }\r\n        console.warn('L.SVG.tile is not available. Make sure Leaflet.VectorGrid plugin is loaded correctly.');\r\n    }\r\n    return undefined;\r\n};\r\n\r\nexport const SlicerVectorTileLayer = {\r\n    createSlicerVectorTileLayer(\r\n        geoJsonData: any,\r\n        options?: any,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.Layer {\r\n        // Check if Leaflet.VectorGrid is available\r\n        if (!(L as any).vectorGrid || typeof (L as any).vectorGrid.slicer !== 'function') {\r\n            console.error('Leaflet.VectorGrid plugin is not loaded. Please include Leaflet.VectorGrid.bundled.js');\r\n            throw new Error('Leaflet.VectorGrid plugin is required but not loaded');\r\n        }\r\n\r\n        // Build VectorGrid options with default fill style\r\n        let vectorTileLayerStyles = options?.vectorTileLayerStyles;\r\n        \r\n        // If no custom styles provided, use a default style with fill\r\n        if (!vectorTileLayerStyles || Object.keys(vectorTileLayerStyles).length === 0) {\r\n            vectorTileLayerStyles = function () {\r\n                return {\r\n                    fill: true,\r\n                    fillColor: '#3388ff',\r\n                    fillOpacity: 0.2,\r\n                    stroke: true,\r\n                    color: '#3388ff',\r\n                    weight: 1,\r\n                    opacity: 1\r\n                };\r\n            };\r\n        }\r\n\r\n        const vectorGridOptions: any = {\r\n            interactive: options?.interactive ?? false,\r\n            getFeatureId: options?.getFeatureId,\r\n            vectorTileLayerStyles: vectorTileLayerStyles,\r\n            minZoom: options?.minZoom ?? 0,\r\n            maxZoom: options?.maxZoom,\r\n            maxNativeZoom: options?.maxNativeZoom,\r\n            minNativeZoom: options?.minNativeZoom,\r\n            tileSize: options?.tileSize ?? 256,\r\n            opacity: options?.opacity ?? 1.0,\r\n            updateWhenIdle: options?.updateWhenIdle,\r\n            updateWhenZooming: options?.updateWhenZooming ?? true,\r\n            updateInterval: options?.updateInterval ?? 200,\r\n            zIndex: options?.zIndex ?? 1,\r\n            bounds: options?.bounds,\r\n            noWrap: options?.noWrap ?? false,\r\n            pane: options?.pane ?? 'tilePane',\r\n            className: options?.className ?? '',\r\n            keepBuffer: options?.keepBuffer ?? 2,\r\n            attribution: options?.attribution ?? ''\r\n        };\r\n\r\n        // Add renderer factory if specified\r\n        const rendererFactory = getRendererFactory(options?.rendererFactory);\r\n        if (rendererFactory !== undefined) {\r\n            vectorGridOptions.rendererFactory = rendererFactory;\r\n        }\r\n\r\n        // Create the VectorGrid Slicer layer\r\n        const vectorTileLayer = (L as any).vectorGrid.slicer(geoJsonData, vectorGridOptions);\r\n\r\n        // Store options for dynamic updates\r\n        (vectorTileLayer as any)._pyroOptions = {\r\n            interactive: options?.interactive ?? false,\r\n            enableFeatureSelection: options?.enableFeatureSelection !== false,\r\n            multipleFeatureSelection: options?.multipleFeatureSelection === true,\r\n            enableHoverStyle: options?.enableHoverStyle !== false,\r\n            selectedFeatureStyle: options?.selectedFeatureStyle,\r\n            hoverStyle: options?.hoverStyle\r\n        };\r\n\r\n        // Default styles (DRY - single source of truth)\r\n        const DEFAULT_SELECTION_STYLE = {\r\n            color: '#368ce1',\r\n            weight: 3,\r\n            fillColor: '#368ce1',\r\n            fillOpacity: 0.3,\r\n            opacity: 1\r\n        };\r\n\r\n        const DEFAULT_HOVER_STYLE = {\r\n            color: 'red',\r\n            weight: 2,\r\n            opacity: 1.0\r\n        };\r\n\r\n        // Setup feature selection with multi-segment support\r\n        const selectedFeatures: Map<any, any> = new Map();\r\n        const selectedLayers: Map<any, any[]> = new Map();\r\n        \r\n        // Hover state management\r\n        const hoveredLayers: Map<any, any> = new Map(); // Map of layer -> original style (for hover)\r\n        \r\n        // Track all layers by feature ID as they're added\r\n        const layersByFeatureId: Map<string, any[]> = new Map();\r\n\r\n        const selectedFeatureStyle = options?.selectedFeatureStyle ?? DEFAULT_SELECTION_STYLE;\r\n\r\n        const applySelectedStyle = (layer: any) => {\r\n            if (layer && layer.setStyle) {\r\n                const leafletStyle: any = {};\r\n                \r\n                if (selectedFeatureStyle.color) leafletStyle.color = selectedFeatureStyle.color;\r\n                if (selectedFeatureStyle.weight !== undefined) leafletStyle.weight = selectedFeatureStyle.weight;\r\n                if (selectedFeatureStyle.opacity !== undefined) leafletStyle.opacity = selectedFeatureStyle.opacity;\r\n                if (selectedFeatureStyle.fillColor) leafletStyle.fillColor = selectedFeatureStyle.fillColor;\r\n                if (selectedFeatureStyle.fillOpacity !== undefined) leafletStyle.fillOpacity = selectedFeatureStyle.fillOpacity;\r\n                if (selectedFeatureStyle.fill !== undefined) leafletStyle.fill = selectedFeatureStyle.fill;\r\n                if (selectedFeatureStyle.stroke !== undefined) leafletStyle.stroke = selectedFeatureStyle.stroke;\r\n                if (selectedFeatureStyle.dashArray) leafletStyle.dashArray = selectedFeatureStyle.dashArray;\r\n                if (selectedFeatureStyle.lineCap) leafletStyle.lineCap = selectedFeatureStyle.lineCap;\r\n                if (selectedFeatureStyle.lineJoin) leafletStyle.lineJoin = selectedFeatureStyle.lineJoin;\r\n                \r\n                layer.setStyle(leafletStyle);\r\n            }\r\n        };\r\n\r\n        const resetStyle = (layer: any) => {\r\n            if (layer && layer.setStyle && layer.options?.originalStyle) {\r\n                layer.setStyle(layer.options.originalStyle);\r\n            }\r\n        };\r\n\r\n        const getFeatureIdentifier = (properties: any): string => {\r\n            return properties?.id ?? properties?.ID ?? properties?.fid ?? properties?.FID ??\r\n                properties?.objectid ?? properties?.OBJECTID ?? JSON.stringify(properties);\r\n        };\r\n\r\n        // Track layers as they're interacted with\r\n        const trackLayer = (layer: any) => {\r\n            if (layer && layer.properties) {\r\n                const featureId = getFeatureIdentifier(layer.properties);\r\n                if (!layersByFeatureId.has(featureId)) {\r\n                    layersByFeatureId.set(featureId, []);\r\n                }\r\n                const layers = layersByFeatureId.get(featureId)!;\r\n                if (!layers.includes(layer)) {\r\n                    layers.push(layer);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Helper to find and style all segments with the same feature ID\r\n        const selectAllSegments = (featureId: string) => {\r\n            const layers = layersByFeatureId.get(featureId) || [];\r\n            \r\n            layers.forEach(layer => {\r\n                if (!layer.options.originalStyle) {\r\n                    layer.options.originalStyle = {\r\n                        fillColor: layer.options.fillColor,\r\n                        color: layer.options.color,\r\n                        weight: layer.options.weight,\r\n                        fillOpacity: layer.options.fillOpacity,\r\n                        fill: layer.options.fill\r\n                    };\r\n                }\r\n                \r\n                applySelectedStyle(layer);\r\n            });\r\n            \r\n            return layers;\r\n        };\r\n\r\n        const unselectAllSegments = (featureId: string) => {\r\n            const layers = selectedLayers.get(featureId);\r\n            if (layers) {\r\n                layers.forEach(layer => resetStyle(layer));\r\n            }\r\n        };\r\n\r\n        if (options?.enableFeatureSelection !== false) {\r\n            vectorTileLayer.on('click', function (e: any) {\r\n                if (e.layer && e.layer.properties) {\r\n                    // Check current enableFeatureSelection state\r\n                    const currentOptions = vectorTileLayer._pyroOptions || options;\r\n                    if (currentOptions?.enableFeatureSelection === false) {\r\n                        return; // Selection disabled\r\n                    }\r\n                    \r\n                    // Track this layer\r\n                    trackLayer(e.layer);\r\n                    \r\n                    const featureId = getFeatureIdentifier(e.layer.properties);\r\n                    const feature = {\r\n                        id: featureId,\r\n                        type: e.layer.feature?.type ?? 'Feature',\r\n                        geometry: e.layer.feature?.geometry,\r\n                        properties: e.layer.properties\r\n                    };\r\n\r\n                    const isSelected = selectedFeatures.has(featureId);\r\n\r\n                    if (isSelected) {\r\n                        // Unselect all segments of this feature\r\n                        const layers = selectedLayers.get(featureId);\r\n                        \r\n                        unselectAllSegments(featureId);\r\n                        selectedFeatures.delete(featureId);\r\n                        selectedLayers.delete(featureId);\r\n                        \r\n                        // Check if any segment is currently being hovered\r\n                        // If so, reapply hover style instead of original\r\n                        if (layers) {\r\n                            const isCurrentlyHovered = layers.some(layer => hoveredLayers.has(layer));\r\n                            \r\n                            if (isCurrentlyHovered) {\r\n                                // Reapply hover style to all segments\r\n                                const hoverStyle = currentOptions?.hoverStyle || DEFAULT_HOVER_STYLE;\r\n                                layers.forEach(layer => {\r\n                                    if (layer.setStyle) {\r\n                                        const currentStyle = {\r\n                                            color: layer.options.originalStyle?.color || layer.options.color,\r\n                                            weight: layer.options.originalStyle?.weight || layer.options.weight,\r\n                                            opacity: layer.options.originalStyle?.opacity || layer.options.opacity,\r\n                                            fillColor: layer.options.originalStyle?.fillColor || layer.options.fillColor,\r\n                                            fillOpacity: layer.options.originalStyle?.fillOpacity || layer.options.fillOpacity\r\n                                        };\r\n                                        const mergedStyle = { ...currentStyle, ...hoverStyle };\r\n                                        layer.setStyle(mergedStyle);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureunselected']) {\r\n                            handlerMappings.dotNetRef.invokeMethodAsync(\r\n                                handlerMappings.events['featureunselected'],\r\n                                {\r\n                                    feature: feature,\r\n                                    latlng: e.latlng,\r\n                                    layerPoint: e.layerPoint,\r\n                                    containerPoint: e.containerPoint\r\n                                }\r\n                            );\r\n                        }\r\n                    } else {\r\n                        // Handle multiple selection based on current state\r\n                        const allowMultiple = currentOptions?.multipleFeatureSelection === true;\r\n                        \r\n                        if (!allowMultiple) {\r\n                            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\r\n                            selectedFeatures.clear();\r\n                            selectedLayers.clear();\r\n                        }\r\n\r\n                        const layers = selectAllSegments(featureId);\r\n                        \r\n                        // Bring all selected segments to front\r\n                        layers.forEach(layer => {\r\n                            if (layer.bringToFront) {\r\n                                layer.bringToFront();\r\n                            }\r\n                            // Note: Don't clear hover state - keep it for proper restoration\r\n                            // The selection style will override the hover style visually\r\n                        });\r\n                        \r\n                        selectedFeatures.set(featureId, feature);\r\n                        selectedLayers.set(featureId, layers);\r\n\r\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featureselected']) {\r\n                            handlerMappings.dotNetRef.invokeMethodAsync(\r\n                                handlerMappings.events['featureselected'],\r\n                                {\r\n                                    feature: feature,\r\n                                    latlng: e.latlng,\r\n                                    layerPoint: e.layerPoint,\r\n                                    containerPoint: e.containerPoint\r\n                                }\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    if (handlerMappings?.dotNetRef && handlerMappings.events['featureclicked']) {\r\n                        handlerMappings.dotNetRef.invokeMethodAsync(\r\n                            handlerMappings.events['featureclicked'],\r\n                            {\r\n                                feature: feature,\r\n                                latlng: e.latlng,\r\n                                layerPoint: e.layerPoint,\r\n                                containerPoint: e.containerPoint\r\n                            }\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        (vectorTileLayer as any).clearSelection = function () {\r\n            selectedFeatures.forEach((_, id) => unselectAllSegments(id));\r\n            selectedFeatures.clear();\r\n            selectedLayers.clear();\r\n            \r\n            // Clear any hover states\r\n            hoveredLayers.forEach((originalStyle, layer) => {\r\n                if (layer && layer.setStyle && originalStyle) {\r\n                    layer.setStyle(originalStyle);\r\n                }\r\n            });\r\n            hoveredLayers.clear();\r\n        };\r\n\r\n        // Hover styling (controlled by enableHoverStyle flag and interactive mode)\r\n        if (options?.interactive === true && options?.enableHoverStyle !== false) {\r\n            const hoverStyle = options?.hoverStyle || DEFAULT_HOVER_STYLE;\r\n            \r\n            vectorTileLayer.on('mouseover', function (e: any) {\r\n                if (e.layer && e.layer.properties) {\r\n                    // Track this layer\r\n                    trackLayer(e.layer);\r\n                    \r\n                    const featureId = getFeatureIdentifier(e.layer.properties);\r\n                    \r\n                    // Don't apply hover if feature is selected\r\n                    if (!selectedFeatures.has(featureId)) {\r\n                        // Get all segments of this feature\r\n                        const allSegments = layersByFeatureId.get(featureId) || [];\r\n                        \r\n                        // Apply hover to ALL segments\r\n                        allSegments.forEach(layer => {\r\n                            // Bring to front if possible\r\n                            if (layer.bringToFront) {\r\n                                layer.bringToFront();\r\n                            }\r\n                            \r\n                            // Store original style if not already hovering\r\n                            if (!hoveredLayers.has(layer)) {\r\n                                hoveredLayers.set(layer, {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity\r\n                                });\r\n                                \r\n                                // Apply hover style (merge with current to preserve fill)\r\n                                const currentStyle = {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity\r\n                                };\r\n                                \r\n                                const mergedStyle = { ...currentStyle, ...hoverStyle };\r\n                                if (layer.setStyle) {\r\n                                    layer.setStyle(mergedStyle);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n\r\n            vectorTileLayer.on('mouseout', function (e: any) {\r\n                if (e.layer && e.layer.properties) {\r\n                    const featureId = getFeatureIdentifier(e.layer.properties);\r\n                    \r\n                    // Get all segments that were hovered\r\n                    const allSegments = layersByFeatureId.get(featureId) || [];\r\n                    \r\n                    // Restore ALL segments\r\n                    allSegments.forEach(layer => {\r\n                        if (hoveredLayers.has(layer)) {\r\n                            const originalStyle = hoveredLayers.get(layer);\r\n                            \r\n                            // Check if feature is selected\r\n                            const isSelected = selectedFeatures.has(featureId);\r\n                            \r\n                            if (isSelected) {\r\n                                // Don't restore - reapply selection style instead\r\n                                applySelectedStyle(layer);\r\n                            } else if (originalStyle && layer.setStyle) {\r\n                                // Restore original style\r\n                                layer.setStyle(originalStyle);\r\n                            }\r\n                            \r\n                            hoveredLayers.delete(layer);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // Attach standard GridLayer event handlers\r\n        if (handlerMappings?.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n            const eventMappings: { [key: string]: { eventName: string, argType: string } } = {\r\n                'loading': { eventName: 'loading', argType: 'LeafletEventArgs' },\r\n                'tileunload': { eventName: 'tileunload', argType: 'LeafletTileEventArgs' },\r\n                'tileloadstart': { eventName: 'tileloadstart', argType: 'LeafletTileEventArgs' },\r\n                'tileerror': { eventName: 'tileerror', argType: 'LeafletTileErrorEventArgs' },\r\n                'tileload': { eventName: 'tileload', argType: 'LeafletTileEventArgs' },\r\n                'load': { eventName: 'load', argType: 'LeafletEventArgs' },\r\n                'add': { eventName: 'add', argType: 'LeafletEventArgs' },\r\n                'remove': { eventName: 'remove', argType: 'LeafletEventArgs' }\r\n            };\r\n\r\n            for (const key of keys) {\r\n                const mapping = eventMappings[key];\r\n                if (mapping) {\r\n                    vectorTileLayer.on(mapping.eventName, function (ev: any) {\r\n                        const methodName = handlerMappings.events[key];\r\n                        try {\r\n                            const EventClass = (LeafletEvents as any)[mapping.argType];\r\n                            const payload = EventClass.fromLeaflet(ev).toDto();\r\n                            handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                        } catch (e) {\r\n                            console.error(`Error invoking ${mapping.eventName} handler:`, e);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Attach interactive event handlers when interactive is enabled\r\n            if (options?.interactive) {\r\n                const interactiveEventMappings: { [key: string]: string } = {\r\n                    'mouseover': 'mouseover',\r\n                    'mouseout': 'mouseout',\r\n                    'mousemove': 'mousemove',\r\n                    'dblclick': 'dblclick',\r\n                    'contextmenu': 'contextmenu'\r\n                };\r\n\r\n                for (const [eventKey, leafletEvent] of Object.entries(interactiveEventMappings)) {\r\n                    if (keys.indexOf(eventKey) > -1) {\r\n                        vectorTileLayer.on(leafletEvent, function (e: any) {\r\n                            const methodName = handlerMappings.events[eventKey];\r\n                            try {\r\n                                const payload = {\r\n                                    latlng: e.latlng ? { lat: e.latlng.lat, lng: e.latlng.lng } : null,\r\n                                    layerPoint: e.layerPoint ? { x: e.layerPoint.x, y: e.layerPoint.y } : null,\r\n                                    containerPoint: e.containerPoint ? { x: e.containerPoint.x, y: e.containerPoint.y } : null,\r\n                                    feature: e.layer && e.layer.properties ? {\r\n                                        id: e.layer.properties.id ?? e.layer.properties.ID ?? e.layer.properties.fid ?? e.layer.properties.FID,\r\n                                        type: e.layer.feature?.type ?? 'Feature',\r\n                                        geometry: e.layer.feature?.geometry,\r\n                                        properties: e.layer.properties\r\n                                    } : null\r\n                                };\r\n                                handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                            } catch (err) {\r\n                                console.error(`Error invoking ${eventKey} handler:`, err);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Expose setInteractive method\r\n        (vectorTileLayer as any).setInteractive = function (interactive: boolean) {\r\n            // Update the interactive option\r\n            if (vectorTileLayer.options) {\r\n                vectorTileLayer.options.interactive = interactive;\r\n            }\r\n            \r\n            // VectorGrid stores interactivity at the layer level\r\n            // We need to update the actual layer's interactive state\r\n            if ((vectorTileLayer as any)._vectorTiles) {\r\n                // Iterate through all loaded tiles and update their interactive state\r\n                Object.values((vectorTileLayer as any)._vectorTiles).forEach((tile: any) => {\r\n                    if (tile && tile._features) {\r\n                        Object.values(tile._features).forEach((feature: any) => {\r\n                            if (feature) {\r\n                                feature.options.interactive = interactive;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            \r\n            // Redraw the layer to apply changes\r\n            if (vectorTileLayer.redraw) {\r\n                vectorTileLayer.redraw();\r\n            }\r\n        };\r\n\r\n        // Expose setEnableFeatureSelection method\r\n        (vectorTileLayer as any).setEnableFeatureSelection = function (enableFeatureSelection: boolean) {\r\n            // Update the enableFeatureSelection option\r\n            if (vectorTileLayer._pyroOptions) {\r\n                vectorTileLayer._pyroOptions.enableFeatureSelection = enableFeatureSelection;\r\n            }\r\n            \r\n            // If disabling selection, clear any current selections\r\n            if (!enableFeatureSelection && vectorTileLayer.clearSelection) {\r\n                vectorTileLayer.clearSelection();\r\n            }\r\n        };\r\n\r\n        // Expose setMultipleFeatureSelection method\r\n        (vectorTileLayer as any).setMultipleFeatureSelection = function (multipleFeatureSelection: boolean) {\r\n            // Update the multipleFeatureSelection option\r\n            if (vectorTileLayer._pyroOptions) {\r\n                vectorTileLayer._pyroOptions.multipleFeatureSelection = multipleFeatureSelection;\r\n            }\r\n        };\r\n\r\n        return vectorTileLayer;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const LayerGroup = {\n    createLayerGroup(\n        layers: L.Layer[] = [],\n        options?: L.LayerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.LayerGroup {\n        const layerGroup = L.layerGroup(layers, options);\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            // Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                layerGroup.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                layerGroup.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                layerGroup.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                layerGroup.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                layerGroup.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                layerGroup.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                layerGroup.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                layerGroup.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                layerGroup.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                layerGroup.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                layerGroup.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                layerGroup.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                layerGroup.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n        return layerGroup;\n    }\n};\n","declare const L: typeof import('leaflet');\n\nimport { EventHandlerMapping } from './eventHandling';\nimport { LeafletEvents } from './events';\n\nexport const FeatureGroup = {\n    createFeatureGroup(\n        layers: L.Layer[] = [],\n        options?: L.LayerOptions,\n        handlerMappings?: EventHandlerMapping\n    ): L.FeatureGroup {\n        const featureGroup = L.featureGroup(layers, options);\n        // Attach event handlers if any\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\n            const keys = Object.keys(handlerMappings.events);\n\n            // Layer Events specific to FeatureGroup\n            if (keys.indexOf('layeradd') > -1) {\n                featureGroup.on('layeradd', function (ev: L.LayerEvent) {\n                    var methodName = handlerMappings.events['layeradd'];\n                    try {\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking layeradd handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('layerremove') > -1) {\n                featureGroup.on('layerremove', function (ev: L.LayerEvent) {\n                    var methodName = handlerMappings.events['layerremove'];\n                    try {\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking layerremove handler:', e);\n                    }\n                });\n            }\n\n            // Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                featureGroup.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                featureGroup.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                featureGroup.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                featureGroup.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                featureGroup.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                featureGroup.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                featureGroup.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                featureGroup.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                featureGroup.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                featureGroup.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                featureGroup.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                featureGroup.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                featureGroup.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }// Mouse Events from Interactive Layer\n            if (keys.indexOf('click') > -1) {\n                featureGroup.on('click', function (ev: any) {\n                    var methodName = handlerMappings.events['click'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking click handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('dblclick') > -1) {\n                featureGroup.on('dblclick', function (ev: any) {\n                    var methodName = handlerMappings.events['dblclick'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking dblclick handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mousedown') > -1) {\n                featureGroup.on('mousedown', function (ev: any) {\n                    var methodName = handlerMappings.events['mousedown'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mousedown handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseup') > -1) {\n                featureGroup.on('mouseup', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseup'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseup handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseover') > -1) {\n                featureGroup.on('mouseover', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseover'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseover handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('mouseout') > -1) {\n                featureGroup.on('mouseout', function (ev: any) {\n                    var methodName = handlerMappings.events['mouseout'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking mouseout handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('contextmenu') > -1) {\n                featureGroup.on('contextmenu', function (ev: any) {\n                    var methodName = handlerMappings.events['contextmenu'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking contextmenu handler:', e);\n                    }\n                });\n            }\n            // Events from Layer\n            if (keys.indexOf('add') > -1) {\n                featureGroup.on('add', function (ev: any) {\n                    var methodName = handlerMappings.events['add'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking add handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('remove') > -1) {\n                featureGroup.on('remove', function (ev: any) {\n                    var methodName = handlerMappings.events['remove'];\n                    try {\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking remove handler:', e);\n                    }\n                });\n            }\n            // Popup and Tooltip Events from Layer\n            if (keys.indexOf('popupopen') > -1) {\n                featureGroup.on('popupopen', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('popupclose') > -1) {\n                featureGroup.on('popupclose', function (ev: L.PopupEvent) {\n                    var methodName = handlerMappings.events['popupclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking popupclose handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipopen') > -1) {\n                featureGroup.on('tooltipopen', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipopen'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipopen handler:', e);\n                    }\n                });\n            }\n            if (keys.indexOf('tooltipclose') > -1) {\n                featureGroup.on('tooltipclose', function (ev: L.TooltipEvent) {\n                    var methodName = handlerMappings.events['tooltipclose'];\n                    try {\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\n                    } catch (e) {\n                        console.error('Error invoking tooltipclose handler:', e);\n                    }\n                });\n            }\n        }\n\n        return featureGroup;\n    }\n};\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const GeoJsonLayer = {\r\n    createGeoJsonLayer(\r\n        geoJsonData: any,\r\n        options?: any,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.GeoJSON {\r\n        // Build Leaflet GeoJSON options\r\n        const leafletOptions: L.GeoJSONOptions = {\r\n            markersInheritOptions: options?.markersInheritOptions ?? false\r\n        };\r\n\r\n        // Map onEachFeature callback (no return value)\r\n        if (options?.interop && options.onEachFeatureEnabled) {\r\n            leafletOptions.onEachFeature = function (feature, layer) {\r\n                const layerInfo = LeafletEvents.minimalLayerInfo(layer);\r\n                options.interop.invokeMethodAsync('OnEachFeature', feature, layerInfo);\r\n            };\r\n        }\r\n\r\n        // Map pointToLayer callback (returns Layer/Marker)\r\n        if (options?.interop && options.pointToLayerEnabled) {\r\n            leafletOptions.pointToLayer = function (feature, latlng) {\r\n                // TODO: Make this properly async and await the result\r\n                // For now, return default marker and invoke callback\r\n                options.interop.invokeMethodAsync('PointToLayer', feature, latlng)\r\n                    .then((result: any) => {\r\n                        // Result contains marker options from C#\r\n                        // We could potentially update the marker here\r\n                        console.log('PointToLayer result:', result);\r\n                    });\r\n                return L.marker(latlng);\r\n            };\r\n        }\r\n\r\n        // Map style callback (returns PathOptions/Style)\r\n        if (options?.interop && options.styleEnabled) {\r\n            // Create a Map to store precomputed styles keyed by feature\r\n            const styleCache = new Map<any, any>();\r\n            \r\n            leafletOptions.style = function (feature) {\r\n                // Return precomputed style from cache if available\r\n                if (styleCache.has(feature)) {\r\n                    return styleCache.get(feature);\r\n                }\r\n                // Fallback to empty style if not in cache (shouldn't happen if precomputeStylesAsync ran)\r\n                return {};\r\n            };\r\n            \r\n            // Store the cache reference so precomputeStylesAsync can access it\r\n            (leafletOptions as any).styleCache = styleCache;\r\n        }\r\n\r\n        // Map filter callback (returns boolean)\r\n        // Note: Filter is handled in addData wrapper to support async callbacks\r\n        // Leaflet's filter must be synchronous, so we pre-filter the data before passing to Leaflet\r\n        // This is also more efficient as it avoids adding unwanted features to the layer\r\n\r\n        // Map coordsToLatLng callback (returns LatLng)\r\n        if (options?.interop && options.coordsToLatLngEnabled) {\r\n            leafletOptions.coordsToLatLng = function (coords) {\r\n                // Leaflet expects synchronous return\r\n                // Return default and invoke async callback\r\n                let latlng = L.latLng(coords[1], coords[0], coords[2]);\r\n                options.interop.invokeMethodAsync('CoordsToLatLng', coords)\r\n                    .then((result: any) => {\r\n                        if (result) {\r\n                            latlng = L.latLng(result.lat, result.lng, result.alt);\r\n                        }\r\n                    });\r\n                return latlng;\r\n            };\r\n        }\r\n\r\n        const geoJsonLayer = L.geoJSON(null, leafletOptions); // Always start with null data\r\n\r\n        // Default styles (DRY - single source of truth)\r\n        const DEFAULT_SELECTION_STYLE = {\r\n            color: '#3388ff',\r\n            weight: 3,\r\n            opacity: 1,\r\n            fillOpacity: 0.5,\r\n            fillColor: '#3388ff'\r\n        };\r\n\r\n        const DEFAULT_HOVER_STYLE = {\r\n            color: 'red',\r\n            weight: 2,\r\n            opacity: 1.0\r\n        };\r\n\r\n        // Store selection state\r\n        // For single selection mode\r\n        let selectedLayer: any = null;\r\n        let originalStyle: any = null;\r\n        // Runtime flag to enable/disable selection (can be toggled)\r\n        let selectionEnabledFlag: boolean = options?.enableFeatureSelection !== false;\r\n        \r\n        // For multiple selection mode\r\n        const selectedLayers: Map<any, any> = new Map(); // Map of layer -> original style\r\n\r\n        // Store hover state\r\n        const hoveredLayers: Map<any, any> = new Map(); // Map of layer -> original style (for hover)\r\n\r\n        // Helper function to create a lightweight version of a feature for C# callbacks\r\n        // This strips geometry coordinates from large features to avoid serialization issues\r\n        // while preserving properties and metadata needed for filtering/styling\r\n        function createCallbackFeature(feature: any, sizeThreshold: number = 50000, debug: boolean = false): any {\r\n            if (!feature) {\r\n                return feature;\r\n            }\r\n            \r\n            try {\r\n                const featureJson = JSON.stringify(feature);\r\n                \r\n                if (debug) {\r\n                    console.log(`Feature size: ${featureJson.length} characters`);\r\n                }\r\n                \r\n                // If feature is small enough, return as-is\r\n                if (featureJson.length <= sizeThreshold) {\r\n                    return feature;\r\n                }\r\n                \r\n                // Feature is large, create lightweight version\r\n                if (debug) {\r\n                    console.warn(`Feature is large (${featureJson.length} chars), creating lightweight version`);\r\n                }\r\n                \r\n                const lightweightFeature = {\r\n                    type: feature.type,\r\n                    id: feature.id,\r\n                    properties: feature.properties,\r\n                    geometry: feature.geometry ? {\r\n                        type: feature.geometry.type\r\n                        // Coordinates omitted to reduce size\r\n                    } : undefined\r\n                };\r\n                \r\n                if (debug) {\r\n                    const lightweightSize = JSON.stringify(lightweightFeature).length;\r\n                    console.log(`Lightweight feature size: ${lightweightSize} characters (reduced by ${featureJson.length - lightweightSize})`);\r\n                }\r\n                \r\n                return lightweightFeature;\r\n            } catch (error) {\r\n                console.error('Error creating callback feature:', error);\r\n                // On error, return original feature and let caller handle any issues\r\n                return feature;\r\n            }\r\n        }\r\n        \r\n        // Expose the helper function on the layer instance for future use\r\n        // This allows it to be called from outside (e.g., in setStyle, custom methods)\r\n        (geoJsonLayer as any).createCallbackFeature = createCallbackFeature;\r\n\r\n        // Wrap the addData method to handle async callbacks and filtering\r\n        const originalAddData = geoJsonLayer.addData.bind(geoJsonLayer);\r\n        (geoJsonLayer as any).addData = async function(data: any) {\r\n            let processedData = data;\r\n            \r\n            // Handle async filtering before adding data\r\n            if (options?.interop && options.filterEnabled) {\r\n                try {\r\n                    if (options.debugLogging) {\r\n                        console.log('Starting async filtering...');\r\n                    }\r\n                    processedData = await filterGeoJsonAsync(data, options.interop, options.debugLogging);\r\n                    if (options.debugLogging) {\r\n                        console.log('Filtering complete, processed data:', processedData);\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Error during filtering:', error);\r\n                    throw error;\r\n                }\r\n            }\r\n            \r\n            // Handle async styling before adding data\r\n            if (options?.interop && options.styleEnabled) {\r\n                try {\r\n                    if (options.debugLogging) {\r\n                        console.log('Starting async styling...');\r\n                    }\r\n                    await precomputeStylesAsync(processedData, options.interop, options.debugLogging);\r\n                    if (options.debugLogging) {\r\n                        console.log('Styling complete');\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Error during styling:', error);\r\n                    throw error;\r\n                }\r\n            }\r\n            \r\n            const promises: Promise<any>[] = [];\r\n            \r\n            // Wrap onEachFeature (only this one collects promises as it's void)\r\n            const originalOnEachFeature = (geoJsonLayer as any).options.onEachFeature;\r\n            if (originalOnEachFeature && options?.interop && options.onEachFeatureEnabled) {\r\n                (geoJsonLayer as any).options.onEachFeature = function(feature: any, layer: any) {\r\n                    const layerInfo = LeafletEvents.minimalLayerInfo(layer);\r\n                    const promise = options.interop.invokeMethodAsync('OnEachFeature', feature, layerInfo);\r\n                    promises.push(promise);\r\n                };\r\n            }\r\n            \r\n            // Call the original addData with potentially filtered data\r\n            if (options?.debugLogging) {\r\n                console.log('Calling Leaflet addData with:', processedData);\r\n            }\r\n            originalAddData(processedData);\r\n            \r\n            // Restore original onEachFeature\r\n            if (originalOnEachFeature) {\r\n                (geoJsonLayer as any).options.onEachFeature = originalOnEachFeature;\r\n            }\r\n            \r\n            // Wait for all onEachFeature callbacks to complete\r\n            if (promises.length > 0) {\r\n                await Promise.all(promises);\r\n            }\r\n            \r\n            return geoJsonLayer;\r\n        };\r\n        \r\n        // Helper function to filter GeoJSON asynchronously\r\n        async function filterGeoJsonAsync(data: any, interop: any, debug: boolean = false): Promise<any> {\r\n            try {\r\n                if (!data) {\r\n                    if (debug) {\r\n                        console.log('Filter: data is null or undefined, returning as-is');\r\n                    }\r\n                    return data;\r\n                }\r\n                \r\n                if (debug) {\r\n                    console.log('Filtering GeoJSON data, type:', data.type, 'data:', JSON.stringify(data).substring(0, 200));\r\n                }\r\n                \r\n                // Handle single Feature\r\n                if (data.type === 'Feature') {\r\n                    if (debug) {\r\n                        console.log('Filtering single feature:', data.id || 'no-id');\r\n                    }\r\n                    \r\n                    // Create lightweight version for callback if needed\r\n                    const featureToFilter = createCallbackFeature(data, 50000, debug);\r\n                    \r\n                    const shouldInclude = await interop.invokeMethodAsync('Filter', featureToFilter, null);\r\n                    if (debug) {\r\n                        console.log('Filter result for feature:', shouldInclude);\r\n                    }\r\n                    \r\n                    if (!shouldInclude) {\r\n                        // Return an empty FeatureCollection instead of null\r\n                        return { type: 'FeatureCollection', features: [] };\r\n                    }\r\n                    return data;\r\n                }\r\n                \r\n                // Handle FeatureCollection\r\n                if (data.type === 'FeatureCollection') {\r\n                    if (!data.features) {\r\n                        if (debug) {\r\n                            console.log('FeatureCollection has no features property, returning empty collection');\r\n                        }\r\n                        return { type: 'FeatureCollection', features: [] };\r\n                    }\r\n                    \r\n                    if (!Array.isArray(data.features)) {\r\n                        console.error('FeatureCollection.features is not an array:', typeof data.features);\r\n                        return { type: 'FeatureCollection', features: [] };\r\n                    }\r\n                    \r\n                    if (debug) {\r\n                        console.log(`Filtering FeatureCollection with ${data.features.length} features`);\r\n                    }\r\n                    \r\n                    if (data.features.length === 0) {\r\n                        if (debug) {\r\n                            console.log('FeatureCollection is empty, returning as-is');\r\n                        }\r\n                        return data;\r\n                    }\r\n                    \r\n                    // Call filter for each feature and collect results\r\n                    const filterResults: boolean[] = [];\r\n                    for (let idx = 0; idx < data.features.length; idx++) {\r\n                        const feature = data.features[idx];\r\n                        try {\r\n                            if (debug) {\r\n                                console.log(`Calling filter for feature ${idx}:`, feature?.id || feature?.properties?.id || 'no-id', 'type:', feature?.geometry?.type);\r\n                            }\r\n                            \r\n\r\n                            // Create lightweight version for callback if needed\r\n                            const featureToFilter = createCallbackFeature(feature, 50000, debug);\r\n                            \r\n\r\n                            const result = await interop.invokeMethodAsync('Filter', featureToFilter, null);\r\n                            if (debug) {\r\n                                console.log(`Filter result for feature ${idx}:`, result);\r\n                            }\r\n                            filterResults.push(result === true); // Ensure boolean\r\n                        } catch (error) {\r\n                            console.error(`Error filtering feature ${idx}:`, error);\r\n                            console.error(`Feature ${idx} type:`, feature?.geometry?.type);\r\n                            console.error(`Feature ${idx} id:`, feature?.id);\r\n                            // Try to show first part of the feature\r\n                            try {\r\n                                const featureStr = JSON.stringify(feature);\r\n                                console.error(`Feature ${idx} size:`, featureStr.length, 'chars');\r\n                                console.error(`Feature ${idx} preview:`, featureStr.substring(0, 500));\r\n                            } catch (e) {\r\n                                console.error('Could not stringify feature');\r\n                            }\r\n                            // Default to true (include) if filter fails - safer than excluding\r\n                            filterResults.push(true);\r\n                        }\r\n                    }\r\n                    \r\n                    if (debug) {\r\n                        console.log('All filter results:', filterResults);\r\n                    }\r\n                    \r\n                    const filteredFeatures = data.features.filter((_: any, index: number) => filterResults[index]);\r\n                    if (debug) {\r\n                        console.log(`Filtered from ${data.features.length} to ${filteredFeatures.length} features`);\r\n                    }\r\n                    \r\n                    return {\r\n                        ...data,\r\n                        features: filteredFeatures\r\n                    };\r\n                }\r\n                \r\n                // Handle GeometryCollection or other types - return as is\r\n                if (debug) {\r\n                    console.log('Unknown or unsupported GeoJSON type:', data.type, 'returning as-is');\r\n                }\r\n                return data;\r\n                \r\n            } catch (error) {\r\n                console.error('Exception in filterGeoJsonAsync:', error);\r\n                console.error('Data that caused error:', data);\r\n                throw error;\r\n            }\r\n        }\r\n        \r\n        // Helper function to precompute styles for all features asynchronously\r\n        async function precomputeStylesAsync(data: any, interop: any, debug: boolean = false): Promise<void> {\r\n            try {\r\n                if (!data) {\r\n                    return;\r\n                }\r\n                \r\n                const styleCache = (leafletOptions as any).styleCache;\r\n                if (!styleCache) {\r\n                    if (debug) {\r\n                        console.log('No style cache found, skipping style precomputation');\r\n                    }\r\n                    return;\r\n                }\r\n                \r\n                if (debug) {\r\n                    console.log('Precomputing styles for GeoJSON data, type:', data.type);\r\n                }\r\n                \r\n                // Handle single Feature\r\n                if (data.type === 'Feature') {\r\n                    if (debug) {\r\n                        console.log('Computing style for single feature:', data.id || 'no-id');\r\n                    }\r\n                    \r\n                    // Create lightweight version for callback if needed\r\n                    const featureToStyle = createCallbackFeature(data, 50000, debug);\r\n                    \r\n                    const style = await interop.invokeMethodAsync('Style', featureToStyle);\r\n                    styleCache.set(data, style || {});\r\n                    if (debug) {\r\n                        console.log('Style computed:', style);\r\n                    }\r\n                    return;\r\n                }\r\n                \r\n                // Handle FeatureCollection\r\n                if (data.type === 'FeatureCollection' && Array.isArray(data.features)) {\r\n                    if (debug) {\r\n                        console.log(`Computing styles for ${data.features.length} features`);\r\n                    }\r\n                    \r\n                    for (let idx = 0; idx < data.features.length; idx++) {\r\n                        const feature = data.features[idx];\r\n                        try {\r\n                            if (debug) {\r\n                                console.log(`Computing style for feature ${idx}:`, feature?.id || feature?.properties?.id || 'no-id');\r\n                            }\r\n                            \r\n                            // Create lightweight version for callback if needed\r\n                            const featureToStyle = createCallbackFeature(feature, 50000, debug);\r\n                            \r\n                            const style = await interop.invokeMethodAsync('Style', featureToStyle);\r\n                            styleCache.set(feature, style || {});\r\n                            \r\n                            if (debug) {\r\n                                console.log(`Style for feature ${idx}:`, style);\r\n                            }\r\n                        } catch (error) {\r\n                            console.error(`Error computing style for feature ${idx}:`, error);\r\n                            console.error(`Feature ${idx} type:`, feature?.geometry?.type);\r\n                            console.error(`Feature ${idx} id:`, feature?.id);\r\n                            // Try to show first part of the feature\r\n                            try {\r\n                                const featureStr = JSON.stringify(feature);\r\n                                console.error(`Feature ${idx} size:`, featureStr.length, 'chars');\r\n                                console.error(`Feature ${idx} preview:`, featureStr.substring(0, 500));\r\n                            } catch (e) {\r\n                                console.error('Could not stringify feature');\r\n                            }\r\n                            // Use default/empty style on error\r\n                            styleCache.set(feature, {});\r\n                        }\r\n                    }\r\n                    \r\n                    if (debug) {\r\n                        console.log(`Precomputed styles for ${styleCache.size} features`);\r\n                    }\r\n                }\r\n            } catch (error) {\r\n                console.error('Exception in precomputeStylesAsync:', error);\r\n                throw error;\r\n            }\r\n        }\r\n\r\n        // Attach event handlers if provided\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n\r\n            // Layer Events specific to geoJsonLayer\r\n            if (keys.indexOf('layeradd') > -1) {\r\n                geoJsonLayer.on('layeradd', function (ev: L.LayerEvent) {\r\n                    var methodName = handlerMappings.events['layeradd'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking layeradd handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('layerremove') > -1) {\r\n                geoJsonLayer.on('layerremove', function (ev: L.LayerEvent) {\r\n                    var methodName = handlerMappings.events['layerremove'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletLayerEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking layerremove handler:', e);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Feature-specific click event\r\n            if (keys.indexOf('featureclicked') > -1) {\r\n                geoJsonLayer.on('click', function (ev: any) {\r\n                    var methodName = handlerMappings.events['featureclicked'];\r\n                    try {\r\n                        // Extract feature and layer info from the event\r\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\r\n                        const layer = ev.layer || ev.propagatedFrom;\r\n                        \r\n                        if (feature && layer) {\r\n                            // Create lightweight feature for callback if needed\r\n                            const featureToSend = (geoJsonLayer as any).createCallbackFeature(feature, 50000, false);\r\n                            \r\n\r\n                            const payload = {\r\n                                ...LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto(),\r\n                                layer: LeafletEvents.minimalLayerInfo(layer),\r\n                                feature: featureToSend\r\n                            };\r\n                            handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                        }\r\n                    } catch (e) {\r\n                        console.error('Error invoking featureclicked handler:', e);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Feature selection handling (enabled by default)\r\n            // We create a named handler so it can be added/removed at runtime\r\n            const selectionClickHandler = function (ev: any) {\r\n                try {\r\n                    // Respect runtime flag to disable feature selection even if handler is attached\r\n                    if (!selectionEnabledFlag) {\r\n                        return;\r\n                    }\r\n\r\n                    const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\r\n                    const layer = ev.layer || ev.propagatedFrom;\r\n\r\n                    if (!feature || !layer) {\r\n                        return;\r\n                    }\r\n\r\n                    // Don't allow selection/unselection if the layer is currently being edited\r\n                    if ((layer as any)._editingEnabled) {\r\n                        return;\r\n                    }\r\n\r\n                    // Create lightweight feature for callback\r\n                    const featureToSend = (geoJsonLayer as any).createCallbackFeature(feature, 50000, false);\r\n\r\n                    const payload = {\r\n                        ...LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto(),\r\n                        layer: LeafletEvents.minimalLayerInfo(layer),\r\n                        feature: featureToSend\r\n                    };\r\n\r\n                    const multipleSelection = options?.multipleFeatureSelection === true;\r\n\r\n                    if (multipleSelection) {\r\n                        // Multiple selection mode\r\n                        if (selectedLayers.has(layer)) {\r\n                            // Unselect this feature\r\n                            const originalStyle = selectedLayers.get(layer);\r\n                            if (originalStyle && layer.setStyle) {\r\n                                // Clear any hover state first\r\n                                if (hoveredLayers.has(layer)) {\r\n                                    hoveredLayers.delete(layer);\r\n                                }\r\n                                layer.setStyle(originalStyle);\r\n                            }\r\n                            selectedLayers.delete(layer);\r\n\r\n                            // Notify of selection state change first so C# has authoritative list\r\n                            if (handlerMappings?.events['selectionchanged']) {\r\n                                try {\r\n                                    const raw = (geoJsonLayer as any).SelectedFeatures || [];\r\n                                    const dto = raw.map((f: any) => (geoJsonLayer as any).createCallbackFeature(f, 50000, false));\r\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                                } catch (e) {\r\n                                    console.error('Error invoking selectionchanged after unselect:', e);\r\n                                }\r\n                            }\r\n                            // Notify C# of unselection\r\n                            if (handlerMappings?.events['featureunselected']) {\r\n                                handlerMappings.dotNetRef!.invokeMethodAsync(\r\n                                    handlerMappings.events['featureunselected'],\r\n                                    payload\r\n                                );\r\n                            }\r\n                        } else {\r\n                            // Select this feature\r\n                            // Store original style (get from hover cache if currently hovering, otherwise from layer)\r\n                            let styleToStore;\r\n                            if (hoveredLayers.has(layer)) {\r\n                                // Use the original style from before hover\r\n                                styleToStore = hoveredLayers.get(layer);\r\n                                hoveredLayers.delete(layer);\r\n                            } else if (layer.options) {\r\n                                // Capture current style\r\n                                styleToStore = {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity,\r\n                                    dashArray: layer.options.dashArray\r\n                                };\r\n                            }\r\n\r\n                            if (styleToStore) {\r\n                                selectedLayers.set(layer, styleToStore);\r\n                            }\r\n\r\n                            // Bring layer to front so selection is clearly visible\r\n                            if (layer.bringToFront) {\r\n                                layer.bringToFront();\r\n                            }\r\n\r\n                            // Apply selected style (use provided or default)\r\n                            if (layer.setStyle) {\r\n                                const selectionStyle = options?.selectedFeatureStyle || DEFAULT_SELECTION_STYLE;\r\n                                layer.setStyle(selectionStyle);\r\n                            }\r\n                            // Notify of selection state change before individual event so C# receives authoritative list first\r\n                            if (handlerMappings?.events['selectionchanged']) {\r\n                                try {\r\n                                    const raw = (geoJsonLayer as any).SelectedFeatures || [];\r\n                                    const dto = raw.map((f: any) => (geoJsonLayer as any).createCallbackFeature(f, 50000, false));\r\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                                } catch (e) {\r\n                                    console.error('Error invoking selectionchanged before featureselected (single):', e);\r\n                                }\r\n                            }\r\n\r\n                            // Notify C# of selection\r\n                            if (handlerMappings?.events['featureselected']) {\r\n                                handlerMappings.dotNetRef!.invokeMethodAsync(\r\n                                    handlerMappings.events['featureselected'],\r\n                                    payload\r\n                                );\r\n                            }\r\n                            // Notify of selection state change (single-select)\r\n                            if (handlerMappings?.events['selectionchanged']) {\r\n                                try {\r\n                                    const dto = (geoJsonLayer as any).SelectedFeatures || [];\r\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                                } catch (e) {\r\n                                    console.error('Error invoking selectionchanged after select (single-final):', e);\r\n                                }\r\n                            }\r\n                            // Notify of selection state change (single-select)\r\n                            if (handlerMappings?.events['selectionchanged']) {\r\n                                try {\r\n                                    const raw = (geoJsonLayer as any).SelectedFeatures || [];\r\n                                    const dto = raw.map((f: any) => (geoJsonLayer as any).createCallbackFeature(f, 50000, false));\r\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                                } catch (e) {\r\n                                    console.error('Error invoking selectionchanged after select (single):', e);\r\n                                }\r\n                            }\r\n                            // Always notify of selection state change\r\n                            if (handlerMappings?.events['selectionchanged']) {\r\n                                try {\r\n                                    const raw = (geoJsonLayer as any).SelectedFeatures || [];\r\n                                    const dto = raw.map((f: any) => (geoJsonLayer as any).createCallbackFeature(f, 50000, false));\r\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                                } catch (e) {\r\n                                    console.error('Error invoking selectionchanged after select:', e);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // Single selection mode\r\n                        // Check if this is the currently selected layer\r\n                        if (selectedLayer === layer) {\r\n                            // Unselect\r\n                            if (originalStyle && layer.setStyle) {\r\n                                // Clear any hover state first\r\n                                if (hoveredLayers.has(layer)) {\r\n                                    hoveredLayers.delete(layer);\r\n                                }\r\n                                layer.setStyle(originalStyle);\r\n                            }\r\n                            selectedLayer = null;\r\n                            originalStyle = null;\r\n\r\n                            // Notify of selection state change first so C# has authoritative list\r\n                            if (handlerMappings?.events['selectionchanged']) {\r\n                                try {\r\n                                    const raw = (geoJsonLayer as any).SelectedFeatures || [];\r\n                                    const dto = raw.map((f: any) => (geoJsonLayer as any).createCallbackFeature(f, 50000, false));\r\n                                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                                } catch (e) {\r\n                                    console.error('Error invoking selectionchanged after unselect (single):', e);\r\n                                }\r\n                            }\r\n                            // Notify C# of unselection\r\n                            if (handlerMappings?.events['featureunselected']) {\r\n                                handlerMappings.dotNetRef!.invokeMethodAsync(\r\n                                    handlerMappings.events['featureunselected'],\r\n                                    payload\r\n                                );\r\n                            }\r\n                        } else {\r\n                            // Unselect previous selection if any\r\n                            if (selectedLayer && originalStyle && selectedLayer.setStyle) {\r\n                                // Restore previous layer style\r\n                                selectedLayer.setStyle(originalStyle);\r\n                                // Notify .NET that the previous feature was unselected so C# can update its list\r\n                                try {\r\n                                    if (handlerMappings?.events['featureunselected']) {\r\n                                        const prevFeature = (selectedLayer as any).feature;\r\n                                        const prevPayload = {\r\n                                            layer: LeafletEvents.minimalLayerInfo(selectedLayer),\r\n                                            feature: (geoJsonLayer as any).createCallbackFeature(prevFeature, 50000, false)\r\n                                        };\r\n                                        handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['featureunselected'], prevPayload);\r\n                                    }\r\n                                } catch (e) {\r\n                                    console.error('Error invoking featureunselected for previous selection:', e);\r\n                                }\r\n                            }\r\n\r\n                            // Select new feature\r\n                            selectedLayer = layer;\r\n\r\n                            // Store original style (get from hover cache if currently hovering, otherwise from layer)\r\n                            if (hoveredLayers.has(layer)) {\r\n                                // Use the original style from before hover\r\n                                originalStyle = hoveredLayers.get(layer);\r\n                                hoveredLayers.delete(layer);\r\n                            } else if (layer.options) {\r\n                                // Capture current style\r\n                                originalStyle = {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity,\r\n                                    dashArray: layer.options.dashArray\r\n                                };\r\n                            }\r\n\r\n                            // Bring layer to front so selection is clearly visible\r\n                            if (layer.bringToFront) {\r\n                                layer.bringToFront();\r\n                            }\r\n\r\n                            // Apply selected style (use provided or default)\r\n                            if (layer.setStyle) {\r\n                                const selectionStyle = options?.selectedFeatureStyle || DEFAULT_SELECTION_STYLE;\r\n                                layer.setStyle(selectionStyle);\r\n                            }\r\n\r\n                            // Notify C# of selection\r\n                            if (handlerMappings?.events['featureselected']) {\r\n                                handlerMappings.dotNetRef!.invokeMethodAsync(\r\n                                    handlerMappings.events['featureselected'],\r\n                                    payload\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    console.error('Error handling feature selection:', e);\r\n                }\r\n            };\r\n\r\n            // Attach initially if configured\r\n            if (options?.enableFeatureSelection !== false) {\r\n                geoJsonLayer.on('click', selectionClickHandler);\r\n            }\r\n\r\n            // Hover styling (controlled by enableHoverStyle flag)\r\n            // Default to true if not specified\r\n            if (options?.enableHoverStyle !== false) {\r\n                console.log('Hover enabled, enableHoverStyle value:', options?.enableHoverStyle);\r\n                // Use provided hoverStyle or default to red stroke\r\n                const hoverStyle = options?.hoverStyle || DEFAULT_HOVER_STYLE;\r\n                \r\n                geoJsonLayer.on('mouseover', function (ev: any) {\r\n                    try {\r\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\r\n                        const layer = ev.layer || ev.propagatedFrom;\r\n                        \r\n                        if (!feature || !layer || !layer.setStyle) {\r\n                            return;\r\n                        }\r\n\r\n                        // Bring layer to front so hover stroke is visible\r\n                        if (layer.bringToFront) {\r\n                            layer.bringToFront();\r\n                        }\r\n\r\n                        // Store original style if not already hovering\r\n                        if (!hoveredLayers.has(layer)) {\r\n                            if (layer.options) {\r\n                                const originalHoverStyle = {\r\n                                    color: layer.options.color,\r\n                                    weight: layer.options.weight,\r\n                                    opacity: layer.options.opacity,\r\n                                    fillColor: layer.options.fillColor,\r\n                                    fillOpacity: layer.options.fillOpacity,\r\n                                    dashArray: layer.options.dashArray\r\n                                };\r\n                                hoveredLayers.set(layer, originalHoverStyle);\r\n                            }\r\n                            \r\n                            // Apply hover style (merge with current style to only override specified properties)\r\n                            const currentStyle = {\r\n                                color: layer.options.color,\r\n                                weight: layer.options.weight,\r\n                                opacity: layer.options.opacity,\r\n                                fillColor: layer.options.fillColor,\r\n                                fillOpacity: layer.options.fillOpacity,\r\n                                dashArray: layer.options.dashArray\r\n                            };\r\n                            \r\n                            // Merge hover style properties with current style\r\n                            const mergedStyle = { ...currentStyle, ...hoverStyle };\r\n                            layer.setStyle(mergedStyle);\r\n                        }\r\n                    } catch (e) {\r\n                        console.error('Error applying hover style:', e);\r\n                    }\r\n                });\r\n\r\n                geoJsonLayer.on('mouseout', function (ev: any) {\r\n                    try {\r\n                        const feature = ev.layer?.feature || ev.propagatedFrom?.feature;\r\n                        const layer = ev.layer || ev.propagatedFrom;\r\n                        \r\n                        if (!feature || !layer || !layer.setStyle) {\r\n                            return;\r\n                        }\r\n\r\n                        // Restore original style if we were hovering\r\n                        if (hoveredLayers.has(layer)) {\r\n                            const originalHoverStyle = hoveredLayers.get(layer);\r\n                            \r\n                            // Check if this layer is currently selected\r\n                            const multipleSelection = options?.multipleFeatureSelection === true;\r\n                            const isSelected = multipleSelection \r\n                                ? selectedLayers.has(layer) \r\n                                : selectedLayer === layer;\r\n                            \r\n                            if (isSelected) {\r\n                                // Don't restore original style - reapply selection style instead\r\n                                const selectionStyle = options?.selectedFeatureStyle || DEFAULT_SELECTION_STYLE;\r\n                                layer.setStyle(selectionStyle);\r\n                            } else if (originalHoverStyle) {\r\n                                // Not selected - restore original style\r\n                                layer.setStyle(originalHoverStyle);\r\n                            }\r\n                            \r\n                            hoveredLayers.delete(layer);\r\n                        }\r\n                    } catch (e) {\r\n                        console.error('Error restoring hover style:', e);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Mouse Events from Interactive Layer\r\n            if (keys.indexOf('click') > -1) {\r\n                geoJsonLayer.on('click', function (ev: any) {\r\n                    var methodName = handlerMappings.events['click'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking click handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('dblclick') > -1) {\r\n                geoJsonLayer.on('dblclick', function (ev: any) {\r\n                    var methodName = handlerMappings.events['dblclick'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking dblclick handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mousedown') > -1) {\r\n                geoJsonLayer.on('mousedown', function (ev: any) {\r\n                    var methodName = handlerMappings.events['mousedown'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking mousedown handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseup') > -1) {\r\n                geoJsonLayer.on('mouseup', function (ev: any) {\r\n                    var methodName = handlerMappings.events['mouseup'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking mouseup handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseover') > -1) {\r\n                geoJsonLayer.on('mouseover', function (ev: any) {\r\n                    var methodName = handlerMappings.events['mouseover'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking mouseover handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseout') > -1) {\r\n                geoJsonLayer.on('mouseout', function (ev: any) {\r\n                    var methodName = handlerMappings.events['mouseout'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking mouseout handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('contextmenu') > -1) {\r\n                geoJsonLayer.on('contextmenu', function (ev: any) {\r\n                    var methodName = handlerMappings.events['contextmenu'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking contextmenu handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            // Events from Layer\r\n            if (keys.indexOf('add') > -1) {\r\n                geoJsonLayer.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events['add'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking add handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                geoJsonLayer.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events['remove'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking remove handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            // Popup and Tooltip Events from Layer\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                geoJsonLayer.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                geoJsonLayer.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events['popupclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking popupclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                geoJsonLayer.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipopen'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipopen handler:', e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                geoJsonLayer.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events['tooltipclose'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error('Error invoking tooltipclose handler:', e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Add clearSelection method\r\n        (geoJsonLayer as any).clearSelection = function() {\r\n            // Clear single selection\r\n            if (selectedLayer && originalStyle && selectedLayer.setStyle) {\r\n                selectedLayer.setStyle(originalStyle);\r\n            }\r\n            selectedLayer = null;\r\n            originalStyle = null;\r\n            \r\n            // Clear multiple selections\r\n            selectedLayers.forEach((originalStyle, layer) => {\r\n                if (originalStyle && layer.setStyle) {\r\n                    layer.setStyle(originalStyle);\r\n                }\r\n            });\r\n            selectedLayers.clear();\r\n\r\n            // Clear any hover states\r\n            hoveredLayers.forEach((originalStyle, layer) => {\r\n                if (originalStyle && layer.setStyle) {\r\n                    layer.setStyle(originalStyle);\r\n                }\r\n            });\r\n            hoveredLayers.clear();\r\n            // Notify .NET of cleared selection\r\n            if (handlerMappings?.events['selectionchanged']) {\r\n                try {\r\n                    handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], []);\r\n                } catch (e) {\r\n                    console.error('Error invoking selectionchanged after clearSelection:', e);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Allow toggling feature selection at runtime from C#\r\n        (geoJsonLayer as any).setEnableFeatureSelection = function(enabled: boolean) {\r\n            try {\r\n                selectionEnabledFlag = enabled === true;\r\n                if (enabled) {\r\n                    // Attach selection handler if not already attached\r\n                    geoJsonLayer.on('click', selectionClickHandler);\r\n                    options.enableFeatureSelection = true;\r\n                } else {\r\n                    // Detach selection handler and clear selection\r\n                    geoJsonLayer.off('click', selectionClickHandler);\r\n                    options.enableFeatureSelection = false;\r\n                    (geoJsonLayer as any).clearSelection();\r\n                }\r\n            } catch (e) {\r\n                console.error('Error toggling feature selection:', e);\r\n            }\r\n        };\r\n\r\n        // Allow toggling multiple selection mode at runtime from C#\r\n        (geoJsonLayer as any).setMultipleFeatureSelection = function(enabled: boolean) {\r\n            try {\r\n                if (!options) return;\r\n                const wasMultiple = options.multipleFeatureSelection === true;\r\n                options.multipleFeatureSelection = enabled;\r\n\r\n                if (wasMultiple && !enabled) {\r\n                    // switching to single-select: keep last selected feature\r\n                    if (selectedLayers.size > 0) {\r\n                        const layers = Array.from(selectedLayers.keys());\r\n                        const keep = layers[layers.length - 1];\r\n\r\n                        // Restore styles for others\r\n                        for (let i = 0; i < layers.length - 1; i++) {\r\n                            const l = layers[i];\r\n                            const orig = selectedLayers.get(l);\r\n                            if (orig && l.setStyle) l.setStyle(orig);\r\n                        }\r\n\r\n                        // Set single selection\r\n                        selectedLayer = keep;\r\n                        originalStyle = selectedLayers.get(keep) || originalStyle;\r\n                        selectedLayers.clear();\r\n                    }\r\n                }\r\n\r\n                // Notify .NET of selection change\r\n                    if (handlerMappings?.events['selectionchanged']) {\r\n                        try {\r\n                            const raw = (geoJsonLayer as any).SelectedFeatures || [];\r\n                            const dto = raw.map((f: any) => (geoJsonLayer as any).createCallbackFeature(f, 50000, false));\r\n                            handlerMappings.dotNetRef!.invokeMethodAsync(handlerMappings.events['selectionchanged'], dto);\r\n                        } catch (e) {\r\n                            console.error('Error invoking selectionchanged after setMultipleFeatureSelection:', e);\r\n                        }\r\n                    }\r\n            } catch (e) {\r\n                console.error('Error setting multiple selection mode:', e);\r\n            }\r\n        };\r\n\r\n        // Expose selected features for editableGeoJsonLayer to access\r\n        Object.defineProperty(geoJsonLayer, 'SelectedFeatures', {\r\n            get: function() {\r\n                const multipleSelection = options?.multipleFeatureSelection === true;\r\n                if (multipleSelection) {\r\n                    // Return array of features from selectedLayers Map\r\n                    return Array.from(selectedLayers.keys()).map(layer => layer.feature).filter(f => f != null);\r\n                } else {\r\n                    // Return single selected feature or empty array\r\n                    return selectedLayer && selectedLayer.feature ? [selectedLayer.feature] : [];\r\n                }\r\n            }\r\n        });\r\n\r\n        // If initial data was provided, add it through our custom addData method\r\n        if (geoJsonData) {\r\n            // Use setTimeout to ensure this happens after the layer is returned and ready\r\n            setTimeout(() => {\r\n                (geoJsonLayer as any).addData(geoJsonData);\r\n            }, 0);\r\n        }\r\n\r\n        return geoJsonLayer;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { GeoJsonLayer } from './geoJsonLayer';\r\n\r\nexport const EditableGeoJsonLayer = {\r\n    createEditableGeoJsonLayer(\r\n        geoJsonData: any,\r\n        options?: any,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): any {\r\n        // Create the base GeoJSON layer\r\n        const geoJsonLayer = GeoJsonLayer.createGeoJsonLayer(geoJsonData, options, handlerMappings) as any;\r\n\r\n        // Drawing state\r\n        let isEditing = false;\r\n        let drawingPoints: L.LatLng[] = [];\r\n        let drawingType: 'polygon' | 'polyline' | null = null;\r\n        let tempMarkers: L.CircleMarker[] = [];\r\n        let tempPolyline: L.Polyline | null = null;\r\n        let editableLayers: Map<any, any> = new Map();\r\n        \r\n        // Store original geometries for cancel operation\r\n        let originalGeometries: Map<any, any> = new Map();\r\n\r\n        // Default styles\r\n        const DEFAULT_DRAWING_STYLE = {\r\n            color: '#ff7800',\r\n            weight: 3,\r\n            opacity: 0.8,\r\n            fillOpacity: 0.3,\r\n            dashArray: '5, 5'\r\n        };\r\n\r\n        const DEFAULT_EDITING_STYLE = {\r\n            color: '#ff0000',\r\n            weight: 3,\r\n            opacity: 1.0,\r\n            fillOpacity: 0.4\r\n        };\r\n\r\n        const drawingStyle = options?.drawingStyle || DEFAULT_DRAWING_STYLE;\r\n        const editingStyle = options?.editingStyle || DEFAULT_EDITING_STYLE;\r\n        const enableSnapping = options?.enableSnapping !== false;\r\n        const snapDistance = options?.snapDistance || 15;\r\n        const showDrawingGuides = options?.showDrawingGuides !== false;\r\n        const allowDoubleClickFinish = options?.allowDoubleClickFinish !== false;\r\n        const minPolygonPoints = options?.minPolygonPoints || 3;\r\n        const minLinePoints = options?.minLinePoints || 2;\r\n\r\n        // Get the map from the layer\r\n        const getMap = (): L.Map | null => {\r\n            return (geoJsonLayer as any)._map || null;\r\n        };\r\n\r\n        // Helper to set cursor on map container\r\n        const setMapCursor = (cursor: string | null) => {\r\n            const map = getMap();\r\n            if (!map) return;\r\n            try {\r\n                const container = map.getContainer() as HTMLElement;\r\n                if (cursor === null || cursor === '') {\r\n                    // Reset to default cursor\r\n                    container.style.cursor = '';\r\n                } else {\r\n                    container.style.cursor = cursor;\r\n                }\r\n            } catch (e) {\r\n                console.error('Error setting cursor:', e);\r\n            }\r\n        };\r\n\r\n        // Helper to create data URL from SVG string\r\n        const svgToDataUrl = (svg: string) => {\r\n            return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);\r\n        };\r\n\r\n        // Get cursor SVGs from options\r\n        const addCursorSvg = options?.addCursor || '';\r\n        const removeCursorSvg = options?.removeCursor || '';\r\n        \r\n        const addCursorUrl = addCursorSvg ? svgToDataUrl(addCursorSvg) : null;\r\n        const removeCursorUrl = removeCursorSvg ? svgToDataUrl(removeCursorSvg) : null;\r\n        \r\n        // Helper to create vertex markers\r\n        const createVertexMarker = (latlng: L.LatLng): L.CircleMarker => {\r\n            const map = getMap();\r\n            if (!map) {\r\n                throw new Error('Layer is not added to a map');\r\n            }\r\n\r\n            const marker = L.circleMarker(latlng, {\r\n                radius: 6,\r\n                fillColor: '#ff7800',\r\n                color: '#fff',\r\n                weight: 2,\r\n                opacity: 1,\r\n                fillOpacity: 0.8\r\n            });\r\n            marker.addTo(map);\r\n            return marker;\r\n        };\r\n\r\n        // Helper to clear temporary drawing elements\r\n        const clearDrawingElements = () => {\r\n            tempMarkers.forEach(marker => {\r\n                const map = getMap();\r\n                if (map) {\r\n                    map.removeLayer(marker);\r\n                }\r\n            });\r\n            tempMarkers = [];\r\n\r\n            if (tempPolyline) {\r\n                const map = getMap();\r\n                if (map) {\r\n                    map.removeLayer(tempPolyline);\r\n                }\r\n                tempPolyline = null;\r\n            }\r\n        };\r\n\r\n        // Helper to update drawing polyline\r\n        const updateDrawingPolyline = () => {\r\n            const map = getMap();\r\n            if (!map) return;\r\n\r\n            if (tempPolyline) {\r\n                map.removeLayer(tempPolyline);\r\n            }\r\n\r\n            if (drawingPoints.length > 0) {\r\n                tempPolyline = L.polyline(drawingPoints, drawingStyle);\r\n                tempPolyline.addTo(map);\r\n            }\r\n        };\r\n\r\n        // Helper to find nearby vertex for snapping\r\n        const findSnapPoint = (latlng: L.LatLng, map: L.Map): L.LatLng | null => {\r\n            if (!enableSnapping) return null;\r\n\r\n            const point = map.latLngToContainerPoint(latlng);\r\n            let closestPoint: L.LatLng | null = null;\r\n            let closestDistance = snapDistance;\r\n\r\n            geoJsonLayer.eachLayer((layer: any) => {\r\n                if (layer.getLatLngs) {\r\n                    const latlngs = layer.getLatLngs();\r\n                    const flatLatLngs = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;\r\n\r\n                    flatLatLngs.forEach((ll: L.LatLng) => {\r\n                        const llPoint = map.latLngToContainerPoint(ll);\r\n                        const distance = point.distanceTo(llPoint);\r\n                        if (distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestPoint = ll;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n\r\n            drawingPoints.forEach(dp => {\r\n                const dpPoint = map.latLngToContainerPoint(dp);\r\n                const distance = point.distanceTo(dpPoint);\r\n                if (distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestPoint = dp;\r\n                }\r\n            });\r\n\r\n            return closestPoint;\r\n        };\r\n\r\n        // Start editing mode\r\n        (geoJsonLayer as any).startEditing = function() {\r\n            isEditing = true;\r\n            const map = getMap();\r\n            if (!map) {\r\n                console.error('Cannot start editing: layer not added to map');\r\n                return;\r\n            }\r\n\r\n            map.doubleClickZoom.disable();\r\n            // Don't set cursor here - let the drawing/editing mode set it\r\n        };\r\n\r\n        // Stop editing mode\r\n        (geoJsonLayer as any).stopEditing = function() {\r\n            isEditing = false;\r\n            clearDrawingElements();\r\n            drawingPoints = [];\r\n            drawingType = null;\r\n            \r\n            const map = getMap();\r\n            if (map) {\r\n                map.doubleClickZoom.enable();\r\n            }\r\n\r\n            // Reset to default cursor when completely stopping editing\r\n            setMapCursor('default');\r\n        };\r\n\r\n        // Start drawing a polygon\r\n        (geoJsonLayer as any).addPolygon = function() {\r\n            if (!isEditing) {\r\n                console.error('Cannot start drawing: editing mode not enabled');\r\n                return;\r\n            }\r\n\r\n            clearDrawingElements();\r\n            drawingPoints = [];\r\n            drawingType = 'polygon';\r\n\r\n            const map = getMap();\r\n            if (!map) return;\r\n\r\n            // Set cursor to crosshair for drawing\r\n            setMapCursor('crosshair');\r\n\r\n            const onMapClick = (e: L.LeafletMouseEvent) => {\r\n                if (drawingType !== 'polygon') return;\r\n\r\n                let latlng = e.latlng;\r\n                const snapPoint = findSnapPoint(latlng, map);\r\n                if (snapPoint) {\r\n                    latlng = snapPoint;\r\n                }\r\n\r\n                drawingPoints.push(latlng);\r\n                const marker = createVertexMarker(latlng);\r\n                tempMarkers.push(marker);\r\n                updateDrawingPolyline();\r\n\r\n                // Show guide\r\n                if (showDrawingGuides && drawingPoints.length === 1) {\r\n                    console.log('Click to add points. Double-click or press Enter to finish.');\r\n                }\r\n            };\r\n\r\n            const onMapDblClick = (e: L.LeafletMouseEvent) => {\r\n                if (drawingType !== 'polygon') return;\r\n                if (allowDoubleClickFinish && drawingPoints.length >= minPolygonPoints) {\r\n                    e.originalEvent.preventDefault();\r\n                    (geoJsonLayer as any).confirmDrawing();\r\n                }\r\n            };\r\n\r\n            map.on('click', onMapClick);\r\n            map.on('dblclick', onMapDblClick);\r\n\r\n            // Store handlers for cleanup\r\n            (geoJsonLayer as any)._drawingHandlers = { onMapClick, onMapDblClick };\r\n        };\r\n\r\n        // Start drawing a line\r\n        (geoJsonLayer as any).addLine = function() {\r\n            if (!isEditing) {\r\n                console.error('Cannot start drawing: editing mode not enabled');\r\n                return;\r\n            }\r\n\r\n            clearDrawingElements();\r\n            drawingPoints = [];\r\n            drawingType = 'polyline';\r\n\r\n            const map = getMap();\r\n            if (!map) return;\r\n\r\n            // Set cursor to crosshair for drawing\r\n            setMapCursor('crosshair');\r\n\r\n            const onMapClick = (e: L.LeafletMouseEvent) => {\r\n                if (drawingType !== 'polyline') return;\r\n\r\n                let latlng = e.latlng;\r\n                const snapPoint = findSnapPoint(latlng, map);\r\n                if (snapPoint) {\r\n                    latlng = snapPoint;\r\n                }\r\n\r\n                drawingPoints.push(latlng);\r\n                const marker = createVertexMarker(latlng);\r\n                tempMarkers.push(marker);\r\n                updateDrawingPolyline();\r\n\r\n                if (showDrawingGuides && drawingPoints.length === 1) {\r\n                    console.log('Click to add points. Double-click or press Enter to finish.');\r\n                }\r\n            };\r\n\r\n            const onMapDblClick = (e: L.LeafletMouseEvent) => {\r\n                if (drawingType !== 'polyline') return;\r\n                if (allowDoubleClickFinish && drawingPoints.length >= minLinePoints) {\r\n                    e.originalEvent.preventDefault();\r\n                    (geoJsonLayer as any).confirmDrawing();\r\n                }\r\n            };\r\n\r\n            map.on('click', onMapClick);\r\n            map.on('dblclick', onMapDblClick);\r\n\r\n            (geoJsonLayer as any)._drawingHandlers = { onMapClick, onMapDblClick };\r\n        };\r\n\r\n        // Confirm drawing and add to layer\r\n        (geoJsonLayer as any).confirmDrawing = function() {\r\n            if (!drawingType || drawingPoints.length === 0) {\r\n                console.warn('No drawing to confirm');\r\n                return;\r\n            }\r\n\r\n            const minPoints = drawingType === 'polygon' ? minPolygonPoints : minLinePoints;\r\n            if (drawingPoints.length < minPoints) {\r\n                console.warn(`Need at least ${minPoints} points to complete a ${drawingType}`);\r\n                return;\r\n            }\r\n\r\n            const coordinates = drawingPoints.map(p => [p.lng, p.lat]);\r\n            if (drawingType === 'polygon') {\r\n                coordinates.push(coordinates[0]); // Close the polygon\r\n            }\r\n\r\n            const feature: any = {\r\n                type: 'Feature',\r\n                geometry: {\r\n                    type: drawingType === 'polygon' ? 'Polygon' : 'LineString',\r\n                    coordinates: drawingType === 'polygon' ? [coordinates] : coordinates\r\n                },\r\n                properties: {\r\n                    created: new Date().toISOString()\r\n                }\r\n            };\r\n\r\n            geoJsonLayer.addData(feature);\r\n\r\n            if (handlerMappings?.dotNetRef && handlerMappings.events['featurecreated']) {\r\n                handlerMappings.dotNetRef.invokeMethodAsync(\r\n                    handlerMappings.events['featurecreated'],\r\n                    { feature, layer: null }\r\n                );\r\n            }\r\n\r\n            const map = getMap();\r\n            if (map && (geoJsonLayer as any)._drawingHandlers) {\r\n                const handlers = (geoJsonLayer as any)._drawingHandlers;\r\n                map.off('click', handlers.onMapClick);\r\n                map.off('dblclick', handlers.onMapDblClick);\r\n                delete (geoJsonLayer as any)._drawingHandlers;\r\n            }\r\n\r\n            clearDrawingElements();\r\n            drawingPoints = [];\r\n            drawingType = null;\r\n\r\n            // Reset to default cursor after confirming drawing\r\n            setMapCursor('default');\r\n        };\r\n\r\n        // Cancel drawing\r\n        (geoJsonLayer as any).cancelDrawing = function() {\r\n            const map = getMap();\r\n            if (map && (geoJsonLayer as any)._drawingHandlers) {\r\n                const handlers = (geoJsonLayer as any)._drawingHandlers;\r\n                map.off('click', handlers.onMapClick);\r\n                map.off('dblclick', handlers.onMapDblClick);\r\n                delete (geoJsonLayer as any)._drawingHandlers;\r\n            }\r\n\r\n            clearDrawingElements();\r\n            drawingPoints = [];\r\n            drawingType = null;\r\n\r\n            // Reset to default cursor after cancelling\r\n            setMapCursor('default');\r\n\r\n            if (handlerMappings?.dotNetRef && handlerMappings.events['drawingcancelled']) {\r\n                handlerMappings.dotNetRef.invokeMethodAsync(\r\n                    handlerMappings.events['drawingcancelled']\r\n                );\r\n            }\r\n        };\r\n\r\n        // Edit selected features\r\n        (geoJsonLayer as any).editSelectedFeatures = function() {\r\n            const selectedFeatures = (geoJsonLayer as any).SelectedFeatures || [];\r\n            \r\n            if (selectedFeatures.length === 0) {\r\n                console.warn('No features selected for editing');\r\n                return;\r\n            }\r\n\r\n            const map = getMap();\r\n            if (!map) {\r\n                console.error('Cannot edit features: layer not added to map');\r\n                return;\r\n            }\r\n\r\n            originalGeometries.clear();\r\n\r\n            selectedFeatures.forEach((feature: any) => {\r\n                geoJsonLayer.eachLayer((layer: any) => {\r\n                    if (layer.feature === feature && (layer instanceof L.Polygon || layer instanceof L.Polyline)) {\r\n                        const isPolygon = layer instanceof L.Polygon;\r\n                        const currentLatLngs = layer.getLatLngs();\r\n                        const coords = isPolygon ? currentLatLngs[0] : currentLatLngs;\r\n                        \r\n                        const originalCoords = coords.map((latlng: L.LatLng) => ({ lat: latlng.lat, lng: latlng.lng }));\r\n                        originalGeometries.set(feature, { coords: originalCoords, isPolygon });\r\n                        \r\n                        // Initialize with move cursor\r\n                        (layer as any)._currentCursor = 'move';\r\n                        \r\n                        if (!layer.editing) {\r\n                            enableVertexEditing(layer, feature);\r\n                        } else {\r\n                            layer.editing.enable();\r\n                        }\r\n                        \r\n                        // Set cursor on the feature layer itself\r\n                        const featureElem = layer.getElement ? layer.getElement() : null;\r\n                        if (featureElem) {\r\n                            featureElem.style.cursor = 'move';\r\n                        }\r\n                        \r\n                        editableLayers.set(feature, layer);\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // Set move cursor when entering edit mode (default edit cursor)\r\n            setMapCursor('move');\r\n        };\r\n\r\n        // Disable editing on features\r\n        (geoJsonLayer as any).disableEditingFeatures = function() {\r\n            editableLayers.forEach((layer: any, feature: any) => {\r\n                if (layer.editing && layer.editing.enabled()) {\r\n                    layer.editing.disable();\r\n                } else {\r\n                    disableVertexEditing(layer);\r\n                }\r\n            });\r\n            editableLayers.clear();\r\n        };\r\n\r\n        // Confirm editing\r\n        (geoJsonLayer as any).confirmEditing = function() {\r\n            editableLayers.forEach((layer: any, feature: any) => {\r\n                if (layer.editing && layer.editing.enabled()) {\r\n                    layer.editing.disable();\r\n                } else {\r\n                    disableVertexEditing(layer);\r\n                }\r\n                \r\n                const isPolygon = layer instanceof L.Polygon;\r\n                const currentLatLngs = layer.getLatLngs();\r\n                const coords = isPolygon ? currentLatLngs[0] : currentLatLngs;\r\n                \r\n                const newCoords = coords.map((ll: L.LatLng) => [ll.lng, ll.lat]);\r\n                if (isPolygon) {\r\n                    newCoords.push(newCoords[0]);\r\n                    feature.geometry.coordinates = [newCoords];\r\n                } else {\r\n                    feature.geometry.coordinates = newCoords;\r\n                }\r\n                \r\n                // Reset cursor on the feature layer\r\n                const featureElem = layer.getElement ? layer.getElement() : null;\r\n                if (featureElem) {\r\n                    featureElem.style.cursor = '';\r\n                }\r\n                \r\n                if (handlerMappings?.dotNetRef && handlerMappings.events['featuremodified']) {\r\n                    handlerMappings.dotNetRef.invokeMethodAsync(\r\n                        handlerMappings.events['featuremodified'],\r\n                        { feature, layer: null }\r\n                    );\r\n                }\r\n            });\r\n            \r\n            editableLayers.clear();\r\n            originalGeometries.clear();\r\n            \r\n            // Reset to default cursor after confirming edit\r\n            setMapCursor('default');\r\n        };\r\n\r\n        // Cancel editing\r\n        (geoJsonLayer as any).cancelEditing = function() {\r\n            editableLayers.forEach((layer: any, feature: any) => {\r\n                if (layer.editing && layer.editing.enabled()) {\r\n                    layer.editing.disable();\r\n                } else {\r\n                    disableVertexEditing(layer);\r\n                }\r\n                \r\n                const originalGeometry = originalGeometries.get(feature);\r\n                if (originalGeometry) {\r\n                    const { coords, isPolygon } = originalGeometry;\r\n                    const restoredLatLngs = coords.map((c: any) => L.latLng(c.lat, c.lng));\r\n                    \r\n                    if (isPolygon) {\r\n                        layer.setLatLngs([restoredLatLngs]);\r\n                    } else {\r\n                        layer.setLatLngs(restoredLatLngs);\r\n                    }\r\n                    \r\n                    const originalCoords = coords.map((c: any) => [c.lng, c.lat]);\r\n                    if (isPolygon) {\r\n                        originalCoords.push(originalCoords[0]);\r\n                        feature.geometry.coordinates = [originalCoords];\r\n                    } else {\r\n                        feature.geometry.coordinates = originalCoords;\r\n                    }\r\n                }\r\n                \r\n                // Reset cursor on the feature layer\r\n                const featureElem = layer.getElement ? layer.getElement() : null;\r\n                if (featureElem) {\r\n                    featureElem.style.cursor = '';\r\n                }\r\n            });\r\n            \r\n            editableLayers.clear();\r\n            originalGeometries.clear();\r\n            \r\n            // Reset to default cursor after cancelling edit\r\n            setMapCursor('default');\r\n        };\r\n\r\n        // Delete selected features\r\n        (geoJsonLayer as any).deleteSelectedFeatures = async function() {\r\n            const selectedFeatures = (geoJsonLayer as any).SelectedFeatures || [];\r\n            \r\n            if (selectedFeatures.length === 0) return;\r\n\r\n            const map = getMap();\r\n            if (!map) return;\r\n\r\n            // Raise the deleting event with cancellation support\r\n            if (handlerMappings?.dotNetRef && handlerMappings.events['featuredeleting']) {\r\n                try {\r\n                    const result = await handlerMappings.dotNetRef.invokeMethodAsync(\r\n                        handlerMappings.events['featuredeleting'],\r\n                        { \r\n                            features: selectedFeatures,\r\n                            cancel: false\r\n                        }\r\n                    );\r\n                    \r\n                    // Check if the operation was cancelled\r\n                    // Check both camelCase and PascalCase since C# might return PascalCase\r\n                    if (result && (result.cancel === true || result.Cancel === true)) {\r\n                        return;\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Error calling featuredeleting event:', error);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            (geoJsonLayer as any).disableEditingFeatures();\r\n\r\n            selectedFeatures.forEach((feature: any) => {\r\n                geoJsonLayer.eachLayer((layer: any) => {\r\n                    if (layer.feature === feature) {\r\n                        geoJsonLayer.removeLayer(layer);\r\n                        \r\n                        if (handlerMappings?.dotNetRef && handlerMappings.events['featuredeleted']) {\r\n                            handlerMappings.dotNetRef.invokeMethodAsync(\r\n                                handlerMappings.events['featuredeleted'],\r\n                                { feature, layer: null }\r\n                            );\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n\r\n            const selectedFeaturesArray = (geoJsonLayer as any).SelectedFeatures;\r\n            if (selectedFeaturesArray && Array.isArray(selectedFeaturesArray)) {\r\n                selectedFeaturesArray.splice(0, selectedFeaturesArray.length);\r\n            }\r\n            (geoJsonLayer as any).SelectedFeature = null;\r\n            \r\n            if (handlerMappings?.dotNetRef && handlerMappings.events['featureunselected']) {\r\n                handlerMappings.dotNetRef.invokeMethodAsync(\r\n                    handlerMappings.events['featureunselected'],\r\n                    { feature: null, layer: null }\r\n                );\r\n            }\r\n        };\r\n\r\n        // Manual vertex editing implementation\r\n        const enableVertexEditing = (layer: any, feature: any) => {\r\n            if ((layer as any)._editingEnabled) return;\r\n\r\n            const map = getMap();\r\n            if (!map) return;\r\n\r\n            const originalLatLngs = layer.getLatLngs();\r\n            const isPolygon = layer instanceof L.Polygon;\r\n            const coords = isPolygon ? originalLatLngs[0] : originalLatLngs;\r\n            const minVertices = isPolygon ? 3 : 2;\r\n            const vertexMarkers: L.CircleMarker[] = [];\r\n            \r\n            const updateVertexMarkers = () => {\r\n                vertexMarkers.forEach(marker => {\r\n                    const map = getMap();\r\n                    if (map) {\r\n                        map.removeLayer(marker);\r\n                    }\r\n                });\r\n                vertexMarkers.length = 0;\r\n                \r\n                coords.forEach((latlng: L.LatLng, index: number) => {\r\n                    const marker = createEditableVertexMarker(latlng, index);\r\n                    vertexMarkers.push(marker);\r\n                });\r\n                \r\n                (layer as any)._vertexMarkers = vertexMarkers;\r\n            };\r\n            \r\n            const createEditableVertexMarker = (latlng: L.LatLng, index: number) => {\r\n                const marker = L.circleMarker(latlng, {\r\n                    radius: 8,\r\n                    fillColor: '#ffffff',\r\n                    color: '#ff0000',\r\n                    weight: 2,\r\n                    opacity: 1,\r\n                    fillOpacity: 1,\r\n                    interactive: true,\r\n                    bubblingMouseEvents: false,\r\n                    pane: 'markerPane'\r\n                } as any);\r\n                \r\n                marker.addTo(map);\r\n                if (marker.bringToFront) marker.bringToFront();\r\n                \r\n                // Set cursor on the marker element after it's added to the map\r\n                const elem = marker.getElement();\r\n                if (elem) {\r\n                    elem.style.cursor = (layer as any)._currentCursor || 'move';\r\n                }\r\n\r\n                const deleteVertexHandler = (e: any) => {\r\n                    L.DomEvent.stopPropagation(e);\r\n                    L.DomEvent.preventDefault(e);\r\n                    \r\n                    if (coords.length <= minVertices) return;\r\n                    \r\n                    coords.splice(index, 1);\r\n                    \r\n                    if (isPolygon) {\r\n                        layer.setLatLngs([coords]);\r\n                    } else {\r\n                        layer.setLatLngs(coords);\r\n                    }\r\n                    \r\n                    updateVertexMarkers();\r\n                };\r\n                \r\n                (marker as any)._deleteHandler = deleteVertexHandler;\r\n                \r\n                marker.on('mousedown', (e: any) => {\r\n                    L.DomEvent.stopPropagation(e);\r\n                    \r\n                    if (map.dragging) map.dragging.disable();\r\n                    \r\n                    const onMouseMove = (e: L.LeafletMouseEvent) => {\r\n                        const newLatLng = e.latlng;\r\n                        marker.setLatLng(newLatLng);\r\n                        coords[index] = newLatLng;\r\n                        \r\n                        if (isPolygon) {\r\n                            layer.setLatLngs([coords]);\r\n                        } else {\r\n                            layer.setLatLngs(coords);\r\n                        }\r\n                    };\r\n                    \r\n                    const onMouseUp = () => {\r\n                        map.off('mousemove', onMouseMove);\r\n                        map.off('mouseup', onMouseUp);\r\n                        \r\n                        if (map.dragging) map.dragging.enable();\r\n                    };\r\n                    \r\n                    map.on('mousemove', onMouseMove);\r\n                    map.on('mouseup', onMouseUp);\r\n                });\r\n                \r\n                return marker;\r\n            };\r\n            \r\n            updateVertexMarkers();\r\n            \r\n            (layer as any)._vertexMarkers = vertexMarkers;\r\n            (layer as any)._editingEnabled = true;\r\n            (layer as any)._updateVertexMarkers = updateVertexMarkers;\r\n            (layer as any)._coords = coords;\r\n            (layer as any)._isPolygon = isPolygon;\r\n            (layer as any)._minVertices = minVertices;\r\n            \r\n            layer.setStyle(editingStyle);\r\n        };\r\n\r\n        const disableVertexEditing = (layer: any) => {\r\n            if (!(layer as any)._editingEnabled) return;\r\n            \r\n            const map = getMap();\r\n            \r\n            if (map && (layer as any)._vertexMarkers) {\r\n                (layer as any)._vertexMarkers.forEach((marker: L.CircleMarker) => {\r\n                    map.removeLayer(marker);\r\n                });\r\n            }\r\n            \r\n            if ((layer as any)._addVertexClickHandler) {\r\n                layer.off('click', (layer as any)._addVertexClickHandler);\r\n                delete (layer as any)._addVertexClickHandler;\r\n            }\r\n            \r\n            delete (layer as any)._vertexMarkers;\r\n            delete (layer as any)._editingEnabled;\r\n            delete (layer as any)._updateVertexMarkers;\r\n            delete (layer as any)._coords;\r\n            delete (layer as any)._isPolygon;\r\n            delete (layer as any)._minVertices;\r\n            \r\n            if ((layer as any).feature) {\r\n                const selectedFeatures = (geoJsonLayer as any).SelectedFeatures || [];\r\n                if (selectedFeatures.includes((layer as any).feature) && options?.selectedFeatureStyle) {\r\n                    layer.setStyle(options.selectedFeatureStyle);\r\n                } else {\r\n                    const style = options?.style || {};\r\n                    layer.setStyle(style);\r\n                }\r\n            }\r\n        };\r\n        \r\n        // Set add vertex mode\r\n        (geoJsonLayer as any).setAddVertexMode = function(enabled: boolean) {\r\n            let cursorStyle = 'move';\r\n            if (enabled) {\r\n                if (addCursorUrl) {\r\n                    cursorStyle = `url('${addCursorUrl}') 0 0, crosshair`;\r\n                    setMapCursor(cursorStyle);\r\n                } else {\r\n                    cursorStyle = 'crosshair';\r\n                    setMapCursor(cursorStyle);\r\n                }\r\n            } else {\r\n                cursorStyle = 'move';\r\n                setMapCursor(cursorStyle);\r\n            }\r\n            \r\n            editableLayers.forEach((layer: any) => {\r\n                if (!layer._editingEnabled) return;\r\n                \r\n                // Store current cursor on layer for vertex markers\r\n                layer._currentCursor = cursorStyle;\r\n                \r\n                // Set cursor on the feature layer itself\r\n                const featureElem = layer.getElement ? layer.getElement() : null;\r\n                if (featureElem) {\r\n                    featureElem.style.cursor = cursorStyle;\r\n                }\r\n                \r\n                // Update cursor on all existing vertex markers\r\n                if (layer._vertexMarkers) {\r\n                    layer._vertexMarkers.forEach((marker: any) => {\r\n                        const elem = marker.getElement();\r\n                        if (elem) {\r\n                            elem.style.cursor = cursorStyle;\r\n                        }\r\n                    });\r\n                }\r\n                \r\n                if (enabled) {\r\n                    const addVertexClickHandler = (e: L.LeafletMouseEvent) => {\r\n                        L.DomEvent.stopPropagation(e);\r\n                        \r\n                        const coords = layer._coords;\r\n                        const isPolygon = layer._isPolygon;\r\n                        \r\n                        if (!coords) return;\r\n                        \r\n                        const clickPoint = e.latlng;\r\n                        let minDist = Infinity;\r\n                        let insertIndex = 0;\r\n                        \r\n                        for (let i = 0; i < coords.length; i++) {\r\n                            const nextIndex = (i + 1) % coords.length;\r\n                            \r\n                            if (!isPolygon && nextIndex === 0) continue;\r\n                            \r\n                            const p1 = coords[i];\r\n                            const p2 = coords[nextIndex];\r\n                            \r\n                            const dist = getDistanceToSegment(clickPoint, p1, p2);\r\n                            \r\n                            if (dist < minDist) {\r\n                                minDist = dist;\r\n                                insertIndex = nextIndex;\r\n                            }\r\n                        }\r\n                        \r\n                        coords.splice(insertIndex, 0, clickPoint);\r\n                        \r\n                        if (isPolygon) {\r\n                            layer.setLatLngs([coords]);\r\n                        } else {\r\n                            layer.setLatLngs(coords);\r\n                        }\r\n                        \r\n                        if (layer._updateVertexMarkers) {\r\n                            layer._updateVertexMarkers();\r\n                        }\r\n                    };\r\n                    \r\n                    layer.on('click', addVertexClickHandler);\r\n                    layer._addVertexClickHandler = addVertexClickHandler;\r\n                } else {\r\n                    if (layer._addVertexClickHandler) {\r\n                        layer.off('click', layer._addVertexClickHandler);\r\n                        delete layer._addVertexClickHandler;\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        \r\n        // Set remove vertex mode\r\n        (geoJsonLayer as any).setRemoveVertexMode = function(enabled: boolean) {\r\n            let cursorStyle = 'move';\r\n            if (enabled) {\r\n                if (removeCursorUrl) {\r\n                    cursorStyle = `url('${removeCursorUrl}') 0 0, crosshair`;\r\n                    setMapCursor(cursorStyle);\r\n                } else {\r\n                    cursorStyle = 'crosshair';\r\n                    setMapCursor(cursorStyle);\r\n                }\r\n            } else {\r\n                cursorStyle = 'move';\r\n                setMapCursor(cursorStyle);\r\n            }\r\n            \r\n            editableLayers.forEach((layer: any) => {\r\n                if (!layer._editingEnabled || !layer._vertexMarkers) return;\r\n                \r\n                // Store current cursor on layer for vertex markers\r\n                layer._currentCursor = cursorStyle;\r\n                \r\n                // Set cursor on the feature layer itself\r\n                const featureElem = layer.getElement ? layer.getElement() : null;\r\n                if (featureElem) {\r\n                    featureElem.style.cursor = cursorStyle;\r\n                }\r\n                \r\n                // Update cursor on all existing vertex markers\r\n                layer._vertexMarkers.forEach((marker: any) => {\r\n                    const elem = marker.getElement();\r\n                    if (elem) {\r\n                        elem.style.cursor = cursorStyle;\r\n                    }\r\n                    \r\n                    if (enabled) {\r\n                        if (marker._deleteHandler) {\r\n                            marker.on('click', marker._deleteHandler);\r\n                        }\r\n                    } else {\r\n                        if (marker._deleteHandler) {\r\n                            marker.off('click', marker._deleteHandler);\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        \r\n        // Set move vertex mode\r\n        (geoJsonLayer as any).setMoveVertexMode = function(enabled: boolean) {\r\n            if (enabled) {\r\n                (geoJsonLayer as any).setAddVertexMode(false);\r\n                (geoJsonLayer as any).setRemoveVertexMode(false);\r\n                \r\n                const cursorStyle = 'move';\r\n                setMapCursor(cursorStyle);\r\n                \r\n                // Update cursor on all vertex markers and feature layers\r\n                editableLayers.forEach((layer: any) => {\r\n                    if (!layer._editingEnabled) return;\r\n                    \r\n                    layer._currentCursor = cursorStyle;\r\n                    \r\n                    // Set cursor on the feature layer itself\r\n                    const featureElem = layer.getElement ? layer.getElement() : null;\r\n                    if (featureElem) {\r\n                        featureElem.style.cursor = cursorStyle;\r\n                    }\r\n                    \r\n                    if (layer._vertexMarkers) {\r\n                        layer._vertexMarkers.forEach((marker: any) => {\r\n                            const elem = marker.getElement();\r\n                            if (elem) {\r\n                                elem.style.cursor = cursorStyle;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                // When disabling move mode, don't change cursor - let next mode set it\r\n                // or confirm/cancel will set it to default\r\n            }\r\n        };\r\n        \r\n        // Helper function to calculate distance from point to line segment\r\n        function getDistanceToSegment(point: L.LatLng, p1: L.LatLng, p2: L.LatLng): number {\r\n            const map = getMap();\r\n            if (!map) return Infinity;\r\n            \r\n            const pt = map.latLngToContainerPoint(point);\r\n            const pt1 = map.latLngToContainerPoint(p1);\r\n            const pt2 = map.latLngToContainerPoint(p2);\r\n            \r\n            const x = pt.x, y = pt.y;\r\n            const x1 = pt1.x, y1 = pt1.y;\r\n            const x2 = pt2.x, y2 = pt2.y;\r\n            \r\n            const A = x - x1;\r\n            const B = y - y1;\r\n            const C = x2 - x1;\r\n            const D = y2 - y1;\r\n            \r\n            const dot = A * C + B * D;\r\n            const lenSq = C * C + D * D;\r\n            let param = -1;\r\n            \r\n            if (lenSq !== 0) {\r\n                param = dot / lenSq;\r\n            }\r\n            \r\n            let xx: number, yy: number;\r\n            \r\n            if (param < 0) {\r\n                xx = x1;\r\n                yy = y1;\r\n            } else if (param > 1) {\r\n                xx = x2;\r\n                yy = y2;\r\n            } else {\r\n                xx = x1 + param * C;\r\n                yy = y1 + param * D;\r\n            }\r\n            \r\n            const dx = x - xx;\r\n            const dy = y - yy;\r\n            \r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        }\r\n        \r\n        return geoJsonLayer;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nexport const Polyline = {\r\n    addLatLng(polyline: L.Polyline, latlng: L.LatLng, latlngs?: L.LatLng[]): void {\r\n polyline.addLatLng(latlng, latlngs);\r\n    },\r\n    setLatLngs(polyline: L.Polyline, latlngs: L.LatLng[]): void {\r\n        polyline.setLatLngs(latlngs);\r\n    },\r\n    closestLayerPoint(polyline: L.Polyline, point: L.Point): L.Point {\r\n        return polyline.closestLayerPoint(point);\r\n }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nexport const Polygon = {\r\n // placeholder for polygon helper methods\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nexport const Rectangle = {\r\n    setBounds(rectangle: L.Rectangle, bounds: L.LatLngBounds): void {\r\n        rectangle.setBounds(bounds);\r\n    }\r\n};\r\n","import { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\ndeclare const L: typeof import('leaflet');\r\n\r\nexport const Marker = {\r\n    createMarker(\r\n        latLng: L.LatLng,\r\n        options?: L.MarkerOptions,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.Marker {\r\n        const marker = L.marker(latLng, options);\r\n        // Attach event handlers if provided\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n\r\n            if (keys.indexOf('move') > -1) {\r\n                marker.on('move', function (ev: any) {\r\n                    var methodName = handlerMappings.events['move'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for marker move event`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('dragstart') > -1) {\r\n                marker.on('dragstart', function (ev: any) {\r\n                    var methodName = handlerMappings.events['dragstart'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        //console.log('payload', payload);\r\n                        //console.log('json', JSON.stringify(payload));\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for marker dragstart event`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('movestart') > -1) {\r\n                marker.on('movestart', function (ev: any) {\r\n                    var methodName = handlerMappings.events['movestart'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for marker movestart event`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('drag') > -1) {\r\n                marker.on('drag', function (ev: any) {\r\n                    var methodName = handlerMappings.events['drag'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for marker drag event`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('dragend') > -1) {\r\n                marker.on('dragend', function (ev: L.DragEndEvent) {\r\n                    var methodName = handlerMappings.events['dragend'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletDragEndEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for marker dragend event`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('moveend') > -1) {\r\n                marker.on('moveend', function (ev: any) {\r\n                    var methodName = handlerMappings.events['moveend'];\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for marker moveend event`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('click') > -1) {\r\n                marker.on('click', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['click'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event click`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('dblclick') > -1) {\r\n                marker.on('dblclick', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['dblclick'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event dblclick`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mousedown') > -1) {\r\n                marker.on('mousedown', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mousedown'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mousedown`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseup') > -1) {\r\n                marker.on('mouseup', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mouseup'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mouseup`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseover') > -1) {\r\n                marker.on('mouseover', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mouseover'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mouseover`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseout') > -1) {\r\n                marker.on('mouseout', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mouseout'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mouseout`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('contextmenu') > -1) {\r\n                marker.on('contextmenu', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['contextmenu'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event contextmenu`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('add') > -1) {\r\n                marker.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events!['add'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event add`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                marker.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events!['remove'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event remove`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                marker.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events!['popupopen'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event popupopen`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                marker.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events!['popupclose'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event popupclose`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                marker.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events!['tooltipopen'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event tooltipopen`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                marker.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events!['tooltipclose'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event tooltipclose`, e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return marker;\r\n    }\r\n}\r\n","declare const L: typeof import('leaflet');\r\n\r\nexport const CircleMarker = {\r\n    setLatLng(marker: L.CircleMarker, latLng: L.LatLng): void {\r\n        marker.setLatLng(latLng);\r\n    },\r\n    setRadius(marker: L.CircleMarker, radius: number): void {\r\n        marker.setRadius(radius);\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const Popup = {\r\n    createPopup(\r\n        latLng: L.LatLng,\r\n        options?: L.PopupOptions,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.Popup {\r\n        const popup = L.popup(latLng, options);\r\n\r\n        // Attach event handlers if provided\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n\r\n            if (keys.indexOf('click') > -1) {\r\n                var methodName = handlerMappings.events['click'];\r\n                popup.on('click', function (ev: L.LeafletMouseEvent) {\r\n                    try {\r\n                        let payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for popup click event`, e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return popup;\r\n    }\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nimport { EventHandlerMapping } from './eventHandling';\r\nimport { LeafletEvents } from './events';\r\n\r\nexport const Tooltip = {\r\n    createTooltip(\r\n        latLng: L.LatLng,\r\n        options?: L.TooltipOptions,\r\n        handlerMappings?: EventHandlerMapping\r\n    ): L.Tooltip {\r\n        const tooltip = L.tooltip(latLng, options);\r\n        // Attach event handlers if provided\r\n        if (handlerMappings && handlerMappings.dotNetRef && handlerMappings.events) {\r\n            const keys = Object.keys(handlerMappings.events);\r\n\r\n            if (keys.indexOf('contentupdate') > -1) {\r\n                tooltip.on('contentupdate', function (ev: any) {\r\n                    var methodName = handlerMappings.events!['contentupdate'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event contentupdate`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('click') > -1) {\r\n                tooltip.on('click', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['click'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event click`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('dblclick') > -1) {\r\n                tooltip.on('dblclick', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['dblclick'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event dblclick`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mousedown') > -1) {\r\n                tooltip.on('mousedown', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mousedown'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mousedown`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseup') > -1) {\r\n                tooltip.on('mouseup', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mouseup'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mouseup`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseover') > -1) {\r\n                tooltip.on('mouseover', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mouseover'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mouseover`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('mouseout') > -1) {\r\n                tooltip.on('mouseout', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['mouseout'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event mouseout`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('contextmenu') > -1) {\r\n                tooltip.on('contextmenu', function (ev: L.LeafletMouseEvent) {\r\n                    var methodName = handlerMappings.events!['contextmenu'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletMouseEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event contextmenu`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('add') > -1) {\r\n                tooltip.on('add', function (ev: any) {\r\n                    var methodName = handlerMappings.events!['add'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event add`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('remove') > -1) {\r\n                tooltip.on('remove', function (ev: any) {\r\n                    var methodName = handlerMappings.events!['remove'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event remove`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupopen') > -1) {\r\n                tooltip.on('popupopen', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events!['popupopen'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event popupopen`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('popupclose') > -1) {\r\n                tooltip.on('popupclose', function (ev: L.PopupEvent) {\r\n                    var methodName = handlerMappings.events!['popupclose'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletPopupEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event popupclose`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipopen') > -1) {\r\n                tooltip.on('tooltipopen', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events!['tooltipopen'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event tooltipopen`, e);\r\n                    }\r\n                });\r\n            }\r\n            if (keys.indexOf('tooltipclose') > -1) {\r\n                tooltip.on('tooltipclose', function (ev: L.TooltipEvent) {\r\n                    var methodName = handlerMappings.events!['tooltipclose'];\r\n                    try {\r\n                        var payload = LeafletEvents.LeafletTooltipEventArgs.fromLeaflet(ev).toDto();\r\n                        handlerMappings.dotNetRef!.invokeMethodAsync(methodName, payload);\r\n                    } catch (e) {\r\n                        console.error(`Error invoking dotnet handler for event tooltipclose`, e);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return tooltip;\r\n    }\r\n}\r\n","declare const L: typeof import('leaflet');\r\n\r\n/** Get an existing CRS instance by name, e.g., \"EPSG3857\", \"EPSG4326\", \"Simple\". */\r\nexport function getCrs(name: string): L.CRS {\r\n    const crs = L.CRS?.[name];\r\n    if (!crs) {\r\n        const keys = Object.keys(L.CRS || {});\r\n        throw new Error(\r\n            `Unknown CRS '${name}'. Available CRS keys: ${keys.join(\", \")}`\r\n        );\r\n    }\r\n    // Return the *existing* object; Blazor will receive an object reference.\r\n    return crs;\r\n}\r\n\r\n// The next parts are not currently used.\r\n// Overrides to build a custom CRS as a plain object (no `new`).\r\nexport interface CrsOverrides {\r\n    code?: string;\r\n    wrapLng?: [number, number];\r\n    wrapLat?: [number, number];\r\n    infinite?: boolean;\r\n    // Function overrides\r\n    scale?(zoom: number): number;\r\n    zoom?(scale: number): number;\r\n    project?(latlng: any): any;\r\n    unproject?(point: any): any;\r\n    // You can extend this with additional members if you need them.\r\n}\r\n\r\n// Minimal shape for a CRS-like object. We keep it permissive because CRS are plain objects.\r\nexport type CrsLike = {\r\n    scale(zoom: number): number;\r\n    zoom(scale: number): number;\r\n    latLngToPoint(latLng: any, zoom: number): any;\r\n    pointToLatLng(point: any, zoom: number): any;\r\n    // Optionally other members exist (project/unproject, transformation, etc.)\r\n};\r\n","declare const L: typeof import('leaflet');\r\n\r\nexport interface EditingControlOptions {\r\n    position?: 'topleft' | 'topright' | 'bottomleft' | 'bottomright';\r\n    dotNetRef?: any;\r\n    polygonIcon?: string;\r\n    lineIcon?: string;\r\n    editIcon?: string;\r\n    deleteIcon?: string;\r\n    confirmIcon?: string;\r\n    cancelIcon?: string;\r\n    addVertexIcon?: string;\r\n    removeVertexIcon?: string;\r\n    moveVertexIcon?: string;\r\n    polygonTooltip?: string;\r\n    lineTooltip?: string;\r\n    editTooltip?: string;\r\n    deleteTooltip?: string;\r\n    confirmTooltip?: string;\r\n    cancelTooltip?: string;\r\n    addVertexTooltip?: string;\r\n    removeVertexTooltip?: string;\r\n    moveVertexTooltip?: string;\r\n    buttonSize?: number;\r\n    iconSize?: number;\r\n}\r\n\r\nexport class EditingControl extends L.Control {\r\n    private container: HTMLDivElement | null = null;\r\n    private dotNetRef: any;\r\n    private isDrawing: boolean = false;\r\n    private isEditing: boolean = false;\r\n    private selectedCount: number = 0;\r\n    private isAddingVertices: boolean = false;\r\n    private isRemovingVertices: boolean = false;\r\n    private isMovingVertices: boolean = false;\r\n    private controlOptions: EditingControlOptions;\r\n\r\n    constructor(options?: EditingControlOptions) {\r\n        super(options);\r\n        this.dotNetRef = options?.dotNetRef;\r\n        this.controlOptions = options || {};\r\n    }\r\n\r\n    onAdd(map: L.Map): HTMLElement {\r\n        // Create the control container\r\n        this.container = L.DomUtil.create('div', 'leaflet-editing-control leaflet-bar');\r\n        \r\n        // Add inline styles to ensure visibility\r\n        this.container.style.cssText = `\r\n            background: white !important;\r\n            padding: 10px !important;\r\n            border-radius: 4px !important;\r\n            box-shadow: 0 1px 5px rgba(0,0,0,0.4) !important;\r\n            display: flex !important;\r\n            gap: 8px !important;\r\n            visibility: visible !important;\r\n            opacity: 1 !important;\r\n        `;\r\n        \r\n        // Prevent map interactions when clicking on the control\r\n        L.DomEvent.disableClickPropagation(this.container);\r\n        L.DomEvent.disableScrollPropagation(this.container);\r\n\r\n        // Initial render\r\n        this.render();\r\n\r\n        return this.container;\r\n    }\r\n\r\n    onRemove(map: L.Map): void {\r\n        // Cleanup if needed\r\n        if (this.container) {\r\n            L.DomEvent.off(this.container);\r\n        }\r\n    }\r\n\r\n    private render(): void {\r\n        if (!this.container) return;\r\n\r\n        // Clear existing content\r\n        this.container.innerHTML = '';\r\n\r\n        // Button visibility logic:\r\n        // - Normal mode: show polygon/line, hide others\r\n        // - Feature selected: show polygon/line/edit/delete, hide vertex buttons\r\n        // - Editing mode: show vertex buttons and confirm/cancel, hide others\r\n        // - Drawing mode: show only confirm/cancel\r\n        \r\n        const isInActiveSession = this.isDrawing || this.isEditing;\r\n        \r\n        // Basic drawing buttons (always show unless in active session)\r\n        this.addButton('btn-polygon', () => this.handlePolygonClick(), isInActiveSession);\r\n        this.addButton('btn-line', () => this.handleLineClick(), isInActiveSession);\r\n        \r\n        // Edit and delete buttons (show when feature selected, hide during sessions)\r\n        this.addButton('btn-edit', () => this.handleEditClick(), this.selectedCount === 0 || isInActiveSession);\r\n        this.addButton('btn-delete', () => this.handleDeleteClick(), this.selectedCount === 0 || isInActiveSession);\r\n        \r\n        // Vertex edit buttons (only show during editing session)\r\n        if (this.isEditing) {\r\n            this.addButton('btn-move-vertex', () => this.handleMoveVertexClick(), false, this.isMovingVertices);\r\n            this.addButton('btn-add-vertex', () => this.handleAddVertexClick(), false, this.isAddingVertices);\r\n            this.addButton('btn-remove-vertex', () => this.handleRemoveVertexClick(), false, this.isRemovingVertices);\r\n        }\r\n        \r\n        // Confirm and cancel (show during any active session)\r\n        this.addButton('btn-confirm', () => this.handleConfirmClick(), !isInActiveSession);\r\n        this.addButton('btn-cancel', () => this.handleCancelClick(), !isInActiveSession);\r\n    }\r\n\r\n    private addButton(id: string, onClick: () => void, disabled: boolean = false, isActive: boolean = false): void {\r\n        const button = L.DomUtil.create('button', 'leaflet-editing-button', this.container!);\r\n        button.id = id;\r\n        button.type = 'button';\r\n        button.disabled = disabled;\r\n        \r\n        const buttonSize = this.controlOptions.buttonSize || 40;\r\n        const iconSize = this.controlOptions.iconSize || 24;\r\n        \r\n        // Highlight button if it's active\r\n        const shouldHighlight = isActive;\r\n        \r\n        // Add inline styles to ensure visibility\r\n        button.style.cssText = `\r\n            background: ${shouldHighlight ? '#4CAF50' : 'white'};\r\n            border: 2px solid ${shouldHighlight ? '#4CAF50' : 'rgba(0,0,0,0.2)'};\r\n            border-radius: 4px;\r\n            padding: 8px;\r\n            font-size: 14px;\r\n            font-weight: 600;\r\n            cursor: pointer;\r\n            white-space: nowrap;\r\n            margin: 0 4px;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            min-width: ${buttonSize}px;\r\n            min-height: ${buttonSize}px;\r\n            color: ${shouldHighlight ? 'white' : 'currentColor'};\r\n            box-shadow: ${shouldHighlight ? '0 2px 8px rgba(76, 175, 80, 0.4)' : 'none'};\r\n        `;\r\n        \r\n        if (disabled) {\r\n            button.style.opacity = '0.4';\r\n            button.style.cursor = 'not-allowed';\r\n        }\r\n\r\n        // Get SVG icon and tooltip from options (guaranteed to be present from C#)\r\n        let svgContent = '';\r\n        let ariaLabel = '';\r\n        \r\n        if (id === 'btn-polygon') {\r\n            ariaLabel = this.controlOptions.polygonTooltip || 'Draw new polygon';\r\n            svgContent = this.controlOptions.polygonIcon || '';\r\n        } else if (id === 'btn-line') {\r\n            ariaLabel = this.controlOptions.lineTooltip || 'Draw new line';\r\n            svgContent = this.controlOptions.lineIcon || '';\r\n        } else if (id === 'btn-edit') {\r\n            ariaLabel = this.controlOptions.editTooltip || 'Edit selected features';\r\n            svgContent = this.controlOptions.editIcon || '';\r\n        } else if (id === 'btn-delete') {\r\n            ariaLabel = this.controlOptions.deleteTooltip || 'Delete selected features';\r\n            svgContent = this.controlOptions.deleteIcon || '';\r\n        } else if (id === 'btn-confirm') {\r\n            ariaLabel = this.controlOptions.confirmTooltip || 'Confirm drawing';\r\n            svgContent = this.controlOptions.confirmIcon || '';\r\n        } else if (id === 'btn-cancel') {\r\n            ariaLabel = this.controlOptions.cancelTooltip || 'Cancel drawing';\r\n            svgContent = this.controlOptions.cancelIcon || '';\r\n        } else if (id === 'btn-add-vertex') {\r\n            ariaLabel = this.controlOptions.addVertexTooltip || 'Add vertex';\r\n            svgContent = this.controlOptions.addVertexIcon || '';\r\n        } else if (id === 'btn-remove-vertex') {\r\n            ariaLabel = this.controlOptions.removeVertexTooltip || 'Remove vertex';\r\n            svgContent = this.controlOptions.removeVertexIcon || '';\r\n        } else if (id === 'btn-move-vertex') {\r\n            ariaLabel = this.controlOptions.moveVertexTooltip || 'Move vertex';\r\n            svgContent = this.controlOptions.moveVertexIcon || '';\r\n        }\r\n\r\n        // Set button HTML with just the SVG (no text)\r\n        button.innerHTML = svgContent;\r\n        button.setAttribute('aria-label', ariaLabel);\r\n        button.setAttribute('title', ariaLabel);\r\n\r\n        // Use Leaflet's event system\r\n        L.DomEvent.on(button, 'click', (e: Event) => {\r\n            L.DomEvent.stopPropagation(e);\r\n            L.DomEvent.preventDefault(e);\r\n            onClick();\r\n        });\r\n    }\r\n\r\n    private async handlePolygonClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlPolygonClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlPolygonClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleLineClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlLineClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlLineClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleEditClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlEditClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlEditClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleConfirmClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlConfirmClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlConfirmClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleCancelClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlCancelClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlCancelClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleDeleteClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlDeleteClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlDeleteClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleAddVertexClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlAddVertexClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlAddVertexClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleRemoveVertexClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlRemoveVertexClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlRemoveVertexClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleMoveVertexClick(): Promise<void> {\r\n        if (this.dotNetRef) {\r\n            try {\r\n                await this.dotNetRef.invokeMethodAsync('OnControlMoveVertexClick');\r\n            } catch (error) {\r\n                console.error('Error calling OnControlMoveVertexClick:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Public methods to update state from C#\r\n    public setDrawing(isDrawing: boolean): void {\r\n        this.isDrawing = isDrawing;\r\n        this.render();\r\n    }\r\n\r\n    public setSelectedCount(count: number): void {\r\n        this.selectedCount = count;\r\n        this.render();\r\n    }\r\n\r\n    public setEditing(isEditing: boolean): void {\r\n        this.isEditing = isEditing;\r\n        this.render();\r\n    }\r\n\r\n    public setAddingVertices(isAdding: boolean): void {\r\n        this.isAddingVertices = isAdding;\r\n        this.render();\r\n    }\r\n\r\n    public setRemovingVertices(isRemoving: boolean): void {\r\n        this.isRemovingVertices = isRemoving;\r\n        this.render();\r\n    }\r\n\r\n    public setMovingVertices(isMoving: boolean): void {\r\n        this.isMovingVertices = isMoving;\r\n        this.render();\r\n    }\r\n}\r\n\r\n// Export for use in interop\r\nexport const LeafletEditingControl = {\r\n    create(mapElementId: string, options: EditingControlOptions): EditingControl {\r\n        const control = new EditingControl(options);\r\n        return control;\r\n    },\r\n\r\n    remove(control: EditingControl): void {\r\n        control.remove();\r\n    },\r\n\r\n    setDrawing(control: EditingControl, isDrawing: boolean): void {\r\n        control.setDrawing(isDrawing);\r\n    },\r\n\r\n    setSelectedCount(control: EditingControl, count: number): void {\r\n        control.setSelectedCount(count);\r\n    },\r\n\r\n    setEditing(control: EditingControl, isEditing: boolean): void {\r\n        control.setEditing(isEditing);\r\n    },\r\n\r\n    setAddingVertices(control: EditingControl, isAdding: boolean): void {\r\n        control.setAddingVertices(isAdding);\r\n    },\r\n\r\n    setRemovingVertices(control: EditingControl, isRemoving: boolean): void {\r\n        control.setRemovingVertices(isRemoving);\r\n    },\r\n\r\n    setMovingVertices(control: EditingControl, isMoving: boolean): void {\r\n        control.setMovingVertices(isMoving);\r\n    }\r\n};\r\n\r\n// Make it available globally\r\n(window as any).LeafletEditingControl = LeafletEditingControl;\r\n","import { Map } from './map';\r\nimport { Layer } from './layer';\r\nimport { GridLayer } from './gridLayer';\r\nimport { TileLayer } from './tileLayer';\r\nimport { WmsTileLayer } from './wmsTileLayer';\r\nimport { ProtobufVectorTileLayer } from './protobufVectorTileLayer';\r\nimport { SlicerVectorTileLayer } from './slicerVectorTileLayer';\r\nimport { LayerGroup } from './layerGroup';\r\nimport { FeatureGroup } from './featureGroup';\r\nimport { GeoJsonLayer } from './geoJsonLayer';\r\nimport { EditableGeoJsonLayer } from './editableGeoJsonLayer';\r\nimport { Polyline } from './polyline';\r\nimport { Polygon } from './polygon';\r\nimport { Rectangle } from './rectangle';\r\nimport { Marker } from './marker';\r\nimport { CircleMarker } from './circleMarker';\r\nimport { Popup } from './popup';\r\nimport { Tooltip } from './tooltip';\r\nimport { getCrs } from './crs';\r\nimport { LeafletEditingControl } from './editingControl';\r\n\r\nexport const LeafletMap = {\r\n    Map, Layer, GridLayer, TileLayer, WmsTileLayer, ProtobufVectorTileLayer, SlicerVectorTileLayer, LayerGroup, FeatureGroup, GeoJsonLayer, EditableGeoJsonLayer, Polyline, Polygon, Rectangle, Marker, CircleMarker, Popup, Tooltip, getCrs, LeafletEditingControl\r\n};\r\n\r\n// For consumers that expect a default export or a global on window\r\nexport default LeafletMap;\r\n\r\n// Attach to window for direct script usage in non-module contexts\r\nif (typeof window !== 'undefined') {\r\n    (window as any).LeafletMap = LeafletMap;\r\n}\r\n"],"names":["LeafletEvents","minimalLayerInfo","obj","info","LeafletEventArgs","init","ev","dto","LeafletMouseEventArgs","base","LeafletResizeEventArgs","LeafletPopupEventArgs","LeafletDragEndEventArgs","LeafletErrorEventArgs","_a","msg","code","LeafletGeoJsonEventArgs","_b","_c","_d","_e","_f","_g","LeafletKeyboardEventArgs","LeafletLayerEventArgs","LeafletLayersControlEventArgs","LeafletLocationEventArgs","boundsDto","ne","sw","LeafletTileErrorEventArgs","LeafletTileEventArgs","LeafletTooltipEventArgs","LeafletZoomAnimEventArgs","center","zoom","noUpdate","LeafletFeatureMouseEventArgs","layerName","feature","LeafletTileFetchErrorEventArgs","Map","elementId","options","handlerMappings","map","keys","methodName","payload","mapWrapper","bounds","Layer","layer","e","GridLayer","gridLayer","TileLayer","urlTemplate","tileLayer","WmsTileLayer","baseUrl","wmsTileLayer","VectorTileHelpers","rendererType","type","LCanvas","LSVG","vectorTileLayer","DEFAULT_SELECTION_STYLE","DEFAULT_HOVER_STYLE","selectedFeatures","selectedLayers","hoveredLayers","layersByFeatureId","selectedFeatureStyle","applySelectedStyle","leafletStyle","resetStyle","getFeatureIdentifier","properties","featureId","layers","selectAllSegments","unselectAllSegments","currentOptions","hoverStyle","mergedStyle","_","id","originalStyle","eventMappings","key","mapping","interactiveEventMappings","eventKey","leafletEvent","err","interactive","tile","enableFeatureSelection","multipleFeatureSelection","ProtobufVectorTileLayer","vectorTileLayerStyles","enhancedStyles","style","firstStyle","layerKeys","simpleName","vectorGridOptions","rendererFactory","getRendererFactory","SlicerVectorTileLayer","geoJsonData","trackLayer","LayerGroup","layerGroup","FeatureGroup","featureGroup","GeoJsonLayer","leafletOptions","layerInfo","latlng","result","styleCache","coords","geoJsonLayer","selectedLayer","selectionEnabledFlag","createCallbackFeature","sizeThreshold","debug","featureJson","lightweightFeature","lightweightSize","error","originalAddData","data","processedData","filterGeoJsonAsync","precomputeStylesAsync","promises","originalOnEachFeature","promise","interop","featureToFilter","shouldInclude","filterResults","idx","featureStr","filteredFeatures","index","featureToStyle","featureToSend","selectionClickHandler","f","styleToStore","selectionStyle","prevFeature","prevPayload","originalHoverStyle","enabled","wasMultiple","keep","i","l","orig","EditableGeoJsonLayer","isEditing","drawingPoints","drawingType","tempMarkers","tempPolyline","editableLayers","originalGeometries","DEFAULT_DRAWING_STYLE","DEFAULT_EDITING_STYLE","drawingStyle","editingStyle","enableSnapping","snapDistance","showDrawingGuides","allowDoubleClickFinish","minPolygonPoints","minLinePoints","getMap","setMapCursor","cursor","container","svgToDataUrl","svg","addCursorSvg","removeCursorSvg","addCursorUrl","removeCursorUrl","createVertexMarker","marker","clearDrawingElements","updateDrawingPolyline","findSnapPoint","point","closestPoint","closestDistance","latlngs","ll","llPoint","distance","dp","dpPoint","onMapClick","snapPoint","onMapDblClick","minPoints","coordinates","p","handlers","isPolygon","currentLatLngs","originalCoords","enableVertexEditing","featureElem","disableVertexEditing","newCoords","originalGeometry","restoredLatLngs","c","selectedFeaturesArray","originalLatLngs","minVertices","vertexMarkers","updateVertexMarkers","createEditableVertexMarker","elem","deleteVertexHandler","onMouseMove","newLatLng","onMouseUp","cursorStyle","addVertexClickHandler","clickPoint","minDist","insertIndex","nextIndex","p1","p2","dist","getDistanceToSegment","pt","pt1","pt2","x","y","x1","y1","x2","y2","A","B","C","D","dot","lenSq","param","xx","yy","dx","dy","Polyline","polyline","Polygon","Rectangle","rectangle","Marker","latLng","CircleMarker","radius","Popup","popup","Tooltip","tooltip","getCrs","name","crs","EditingControl","isInActiveSession","onClick","disabled","isActive","button","buttonSize","shouldHighlight","svgContent","ariaLabel","isDrawing","count","isAdding","isRemoving","isMoving","LeafletEditingControl","mapElementId","control","LeafletMap"],"mappings":"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"}